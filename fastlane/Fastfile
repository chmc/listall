# Fastlane configuration
# Docs: https://docs.fastlane.tools
require 'base64'
require 'fileutils'
require 'shellwords'
require_relative 'lib/version_helper'
require_relative 'lib/watch_screenshot_helper'
require_relative 'lib/screenshot_helper'

default_platform(:ios)

def require_asc_env!
  missing = ["ASC_KEY_ID", "ASC_ISSUER_ID", "ASC_KEY_BASE64"].reject { |k| ENV[k].to_s.strip.size > 0 }
  UI.user_error!("Missing App Store Connect API key env vars: #{missing.join(', ')}") unless missing.empty?
end

# Prepare screenshots for deliver by copying only framed versions to a clean directory
def prepare_screenshots_for_delivery(framed_path)
  delivery_path = File.expand_path("screenshots/delivery", __dir__)
  FileUtils.rm_rf(delivery_path)
  FileUtils.mkdir_p(delivery_path)
  
  locales = %w[en-US fi]
  locales.each do |locale|
    src_dir = File.join(framed_path, locale)
    dst_dir = File.join(delivery_path, locale)
    FileUtils.mkdir_p(dst_dir)
    
    # Copy only framed screenshots (exclude non-framed variants)
    Dir.glob(File.join(src_dir, "*_framed.png")).each do |framed_file|
      FileUtils.cp(framed_file, dst_dir)
    end
  end
  
  delivery_path
end

platform :ios do
  desc "Run unit and UI tests (xcodebuild like CI)"
  lane :test do
    # Mirror CI behavior with xcodebuild and non-failing exit
    sh "cd ../ListAll && xcodebuild clean build -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' -configuration Debug CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
    sh "cd ../ListAll && xcodebuild test -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' -resultBundlePath ../fastlane/test_output/ListAll.xcresult CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
  end

  desc "Run tests via scan (Fastlane)"
  lane :test_scan do
    # Prefer project since workspace is embedded in .xcodeproj
    scan(
      project: "ListAll/ListAll.xcodeproj",
      scheme: "ListAll",
      clean: true,
      result_bundle: true,
      derived_data_path: "./ListAll/build",
      devices: ["iPhone 16 Pro"], # falls back to default if not available
      fail_build: false
    )
  end

  desc "Build and upload to TestFlight"
  desc "Options:"
  desc "  bump_type: 'patch' (default), 'minor', or 'major' - Type of version increment"
  desc "  skip_version_bump: true to skip version increment (use current version)"
  lane :beta do |options|
    # Setup CI environment (creates temporary keychain)
    if ENV['CI']
      setup_ci
      # Set keychain password for Match to use when importing certs
      ENV["KEYCHAIN_PASSWORD"] = ""  # setup_ci creates keychain with empty password
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    # Handle version numbering with semantic versioning
    unless options[:skip_version_bump]
      bump_type = options[:bump_type] || 'patch'
      
      # Read current version from file
      current_version = VersionHelper.read_version
      UI.message("ðŸ“¦ Current version: #{current_version}")
      
      # Increment version
      new_version = VersionHelper.increment_version(current_version, bump_type)
      UI.important("ðŸ“¦ Bumping version (#{bump_type}): #{current_version} â†’ #{new_version}")
      
      # Update version in all targets
      VersionHelper.update_xcodeproj_version(xcodeproj_path, new_version)
      
      # Save new version to file
      VersionHelper.write_version(new_version)
      
      # Validate all targets have the same version
      unless VersionHelper.validate_versions(xcodeproj_path)
        UI.user_error!("Version validation failed. Please check that all targets have matching versions.")
      end
      
      UI.success("âœ… Version updated to #{new_version}")
    else
      current_version = VersionHelper.read_version
      UI.message("â­ï¸  Skipping version bump, using current version: #{current_version}")
    end
    
    # Increment build number automatically
    # In CI: use GitHub Actions run number, otherwise just increment by 1
    if ENV['GITHUB_RUN_NUMBER']
      increment_build_number(
        build_number: ENV['GITHUB_RUN_NUMBER'],
        xcodeproj: xcodeproj_path
      )
    else
      increment_build_number(
        xcodeproj: xcodeproj_path
      )
    end
    
    # Sync code signing with verbose output
    match(
      type: 'appstore',
      verbose: true,
      keychain_password: ENV["KEYCHAIN_PASSWORD"] || "",
      skip_set_partition_list: true  # Skip partition list in CI to avoid SecItemCopyMatching error
    )
    
    # Disable automatic code signing for Release configuration
    disable_automatic_code_signing(
      path: "ListAll/ListAll.xcodeproj",
      targets: ["ListAll", "ListAllWatch Watch App"],
      code_sign_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Update Xcode project to use the provisioning profiles from Match
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll_appstore_profile-path"],
      target_filter: "ListAll",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll.watchkitapp_appstore_profile-path"],
      target_filter: "ListAllWatch Watch App",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Build archive (gym/build_app handles exporting ipa)
    ipa_path = build_app(
      project: xcodeproj_path,
      scheme: "ListAll",
      export_method: "app-store",
      output_directory: "./ListAll/build",
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        provisioningProfiles: {
          "io.github.chmc.ListAll" => "match AppStore io.github.chmc.ListAll",
          "io.github.chmc.ListAll.watchkitapp" => "match AppStore io.github.chmc.ListAll.watchkitapp"
        }
      }
    )

    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_KEY_BASE64"]
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
        is_key_content_base64: false,
        in_house: false
      )
      pilot(
        ipa: ipa_path,
        api_key: api_key,
        distribute_external: false
      )
    else
      UI.important("ASC_* env vars not set. Skipping TestFlight upload. Archive built at: #{ipa_path}")
    end
  end

  desc "Deliver metadata/screenshots to App Store (no auto-submit)"
  lane :release do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist before attempting delivery
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("ðŸ“¸ Using framed screenshots from: #{delivery_path}")

    deliver(
      api_key: api_key,
      screenshots_path: delivery_path,
      skip_screenshots: false,
      overwrite_screenshots: true,
      skip_binary_upload: true,
      submit_for_review: false,
      force: true
    )
  end

  desc "Dry-run: Verify framed screenshots would be detected by deliver (no upload)"
  lane :release_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("ðŸ“¸ Verifying screenshots prepared for delivery from: #{delivery_path}")
    
    # List what deliver would find
    locales = %w[en-US fi]
    locales.each do |locale|
      locale_path = File.join(delivery_path, locale)
      if Dir.exist?(locale_path)
        screenshots = Dir.glob(File.join(locale_path, "*.png")).sort
        UI.header("#{locale} (#{screenshots.count} screenshots)")
        screenshots.each do |shot|
          basename = File.basename(shot)
          size = `identify -format '%wx%h' "#{shot}"`.strip rescue "unknown"
          UI.message("  #{basename} (#{size})")
        end
      else
        UI.error("Missing locale directory: #{locale_path}")
      end
    end
    
    UI.success("âœ… Framed screenshots are ready for delivery")
    UI.message("ðŸ’¡ Run 'bundle exec fastlane release' to upload to App Store Connect")
  end

  desc "Validate App Store Connect auth via API key (no uploads)"
  lane :asc_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # This will authenticate and fetch app metadata without uploading anything
    deliver(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_binary_upload: true,
      submit_for_review: false,
      run_precheck_before_submit: false,  # Precheck doesn't work with API keys
      force: true
    )
  end

  # Version management lanes
  
  desc "Show current version from all targets"
  lane :show_version do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.header("ðŸ“¦ Version Information")
    
    # Read from version file
    file_version = VersionHelper.read_version
    UI.message("Version file (.version): #{file_version}")
    
    # Read from git tag (if available)
    git_version = VersionHelper.version_from_git_tag
    UI.message("Latest git tag: #{git_version || 'none'}") if git_version
    
    # Read from Xcode project
    UI.message("\nXcode Project Versions:")
    targets = ['ListAll', 'ListAllWatch Watch App']
    targets.each do |target|
      begin
        version = get_version_number(
          xcodeproj: xcodeproj_path,
          target: target
        )
        build = get_build_number(xcodeproj: xcodeproj_path)
        UI.message("  #{target}: #{version} (#{build})")
      rescue => e
        UI.error("  #{target}: Error - #{e.message}")
      end
    end
    
    # Validate consistency
    UI.message("\n")
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("âœ… All versions are consistent")
    else
      UI.error("âŒ Version mismatch detected")
    end
  end
  
  desc "Manually set version number"
  desc "Usage: fastlane set_version version:1.2.0"
  lane :set_version do |options|
    unless options[:version]
      UI.user_error!("Please specify version with version:X.Y.Z")
    end
    
    version = options[:version]
    
    # Validate semantic version format
    unless version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Version must be in format X.Y.Z (e.g., 1.2.0)")
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.important("ðŸ“¦ Setting version to: #{version}")
    
    # Update version in all targets
    VersionHelper.update_xcodeproj_version(xcodeproj_path, version)
    
    # Save to version file
    VersionHelper.write_version(version)
    
    # Validate
    unless VersionHelper.validate_versions(xcodeproj_path)
      UI.user_error!("Version validation failed")
    end
    
    UI.success("âœ… Version set to #{version}")
    UI.message("ðŸ’¡ Don't forget to commit the changes and create a git tag:")
    UI.message("   git add .version ListAll/ListAll.xcodeproj/project.pbxproj")
    UI.message("   git commit -m 'Bump version to #{version}'")
    UI.message("   git tag v#{version}")
    UI.message("   git push origin main --tags")
  end
  
  desc "Validate that all targets have matching versions"
  lane :validate_versions do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("âœ… All versions are valid and consistent")
    else
      UI.user_error!("âŒ Version validation failed")
    end
  end
  
  desc "Generate screenshots for App Store"
  desc "Runs automated UI tests to capture screenshots for all configured devices and locales"
  lane :screenshots do
    # Capture screenshots using the snapshot tool
    snapshot
    
    UI.success("âœ… Screenshots generated successfully")
    UI.message("ðŸ“ Screenshots saved to: fastlane/screenshots")
  end

  desc "Generate and frame screenshots (snapshot + frameit)"
  lane :screenshots_framed do
    # 1. Raw screenshots
    snapshot

    # 2. Normalize new device sizes to Frameit-supported canvases
    UI.header("Normalizing screenshot sizes for Frameit compatibility")
    compat_root = File.expand_path("screenshots_compat", __dir__)
    sh "rm -rf #{compat_root}"
    locales = %w[en-US fi]
    require 'fileutils'
    require 'shellwords'
    FileUtils.mkdir_p(compat_root)
    UI.message("Compat root: #{compat_root}")
    locales.each do |loc|
      src = File.expand_path(File.join("screenshots", loc), __dir__)
      dst = File.join(compat_root, loc)
      FileUtils.mkdir_p(dst)
      Dir.glob(File.join(src, "*.png")).each do |png|
        # Skip obvious non-screenshot assets like icons
        basename = File.basename(png)
        # Only process our 5 numbered screenshots
        next unless basename =~ /-(01|02|03|04|05)-/

        # Detect size
        size = sh("identify -format '%w %h' #{Shellwords.escape(png)}").strip.split.map(&:to_i) rescue []
        target_w = target_h = nil
        if size == [1320, 2868]
          target_w, target_h = [1290, 2796]       # iPhone 6.7" classic
        elsif size == [2064, 2752]
          target_w, target_h = [2048, 2732]       # iPad Pro 12.9"
        else
          # Pass-through if already supported sizes
          target_w, target_h = size
        end

        out = File.join(dst, basename)
        if target_w && target_h && size != [0,0]
          if [target_w, target_h] == size
            FileUtils.cp(png, out)
          else
            UI.message("Resizing #{basename} #{size.inspect} -> [#{target_w}, #{target_h}]")
            sh "magick convert #{Shellwords.escape(png)} -resize #{target_w}x#{target_h}! #{Shellwords.escape(out)}"
          end
        end
      end
    end

    UI.header("Framing screenshots with Frameit")
    # 3. Frame them into a separate 'framed' directory to keep raw images
    # Frameit uses ENV['SNAPSHOT_SCREENSHOTS_PATH'] by default; override by temporarily moving/pointing path
    ENV['SNAPSHOT_SCREENSHOTS_PATH'] = compat_root
    ENV['FRAMEIT_CONFIG_PATH'] = File.expand_path('Framefile.json', __dir__)
    frameit(
      path: compat_root,
      white: true
    )

    # Move framed output to dedicated directory preserving locale structure
    framed_root = File.expand_path(File.join('screenshots','framed'), __dir__)
    FileUtils.rm_rf(framed_root)
    FileUtils.mkdir_p(framed_root)
    Dir.glob(File.join(compat_root,'*.png')) # ignore top-level stray pngs
    Dir.glob(File.join(compat_root,'*')).select { |d| File.directory?(d) }.each do |locdir|
      loc = File.basename(locdir)
      target_loc = File.join(framed_root, loc)
      FileUtils.mkdir_p(target_loc)
      Dir.glob(File.join(locdir,'*.png')).each do |png|
        FileUtils.cp(png, target_loc)
      end
    end

    UI.success("ðŸ–¼  Framed screenshots generated at #{framed_root}")
  end

  desc "Verify framed screenshots exist for all locales"
  lane :verify_framed do
    locales = %w[en-US fi]
    prefixes = %w[01-WelcomeScreen 02-ListsHome 03-ListDetail 04-ItemDetail 05-Settings]
    missing = []
    locales.each do |loc|
      base = File.expand_path(File.join('screenshots','framed', loc), __dir__)
      unless Dir.exist?(base)
        missing << "Directory missing: #{base}"
        next
      end
      prefixes.each do |p|
        # Require framed variant specifically
        glob = Dir.glob(File.join(base, "*-", "#{p}_framed.png")) + Dir.glob(File.join(base, "*#{p}*_framed.png"))
        if glob.empty?
          missing << "#{loc}: #{p}*_framed.png"
        end
      end
    end
    if missing.any?
      UI.user_error!("Framed screenshot verification failed. Missing: \n- #{missing.join("\n- ")}")
    else
      UI.success("âœ… All framed screenshots present for #{locales.join(', ')}")
    end
  end

  desc "Generate watchOS screenshots (fully automated via UITests + simctl)"
  desc "Captures screenshots from Apple Watch Series 10 (46mm) for EN and FI locales"
  lane :watch_screenshots do
    UI.header("ðŸŽâŒšï¸ Generating watchOS Screenshots")
    
    # Use snapshot with watch-specific configuration
    snapshot(
      project: "./ListAll/ListAll.xcodeproj",
      scheme: "ListAllWatch Watch App",
      testplan: "ListAllWatch Watch App",
      devices: ["Apple Watch Series 10 (46mm)"],
      languages: ["en-US", "fi"],
      output_directory: "./fastlane/screenshots/watch",
      clear_previous_screenshots: true,
      override_status_bar: true,
      reinstall_app: true,
      test_without_building: false,
      concurrent_simulators: false,
      skip_helper_version_check: true
    )
    
    UI.success("ðŸŽâŒšï¸ Watch screenshots generation complete!")
    UI.message("ðŸ“ Raw screenshots saved to: fastlane/screenshots/watch")
    
    # Normalize watch screenshots to App Store Connect required dimensions
    UI.header("ðŸ“ Normalizing watchOS screenshots to App Store Connect dimensions")
    watch_raw_dir = File.expand_path("screenshots/watch", __dir__)
    watch_normalized_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    
    begin
      WatchScreenshotHelper.normalize_screenshots(
        watch_raw_dir,
        watch_normalized_dir,
        target_size: :series7plus  # 396x484 - Apple Watch Series 7+ (45mm)
      )
    rescue => e
      UI.user_error!("Failed to normalize watch screenshots: #{e.message}")
    end
    
    # Copy normalized watch screenshots to framed directory (no framing for watchOS - standard practice)
    UI.header("ðŸ“‚ Copying normalized watchOS screenshots to unified directory")
    unified_framed_root = File.expand_path("screenshots/framed", __dir__)
    locales = %w[en-US fi]

    locales.each do |loc|
      normalized_dir = File.join(watch_normalized_dir, loc)
      next unless Dir.exist?(normalized_dir)
      framed_locale_dir = File.join(unified_framed_root, loc)
      FileUtils.mkdir_p(framed_locale_dir)

      # Copy normalized watch screenshots as-is (naked, no frame) - this is standard for watchOS
      Dir.glob(File.join(normalized_dir, "*.png")).each do |normalized|
        base = File.basename(normalized)
        target = File.join(framed_locale_dir, base)
        FileUtils.cp(normalized, target)
      end
    end

    UI.success("âœ… Normalized watch screenshots copied to #{unified_framed_root} (396x484, unframed)")
  end

  desc "Validate watch screenshot sizes and naming (uses App Store Connect requirements)"
  lane :verify_watch_screenshots do
    UI.header("ðŸ” Validating watchOS Screenshots")
    watch_normalized_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    
    begin
      WatchScreenshotHelper.validate_screenshots(
        watch_normalized_dir,
        expected_count: 5,
        allowed_sizes: [:series7plus]  # Only accept 396x484 (45mm)
      )
      UI.success("âœ… All watch screenshots validated successfully!")
    rescue WatchScreenshotHelper::ValidationError => e
      UI.user_error!("Watch screenshot validation failed: #{e.message}")
    end
  end

  desc "Validate all delivery-ready screenshots (framed iPhone/iPad + naked Watch)"
  lane :validate_delivery_screenshots do
    UI.header("ï¿½ Validating delivery-ready screenshots for App Store submission")
    
    locales = %w[en-US fi]
    errors = []
    warnings = []
    
    # Expected framed dimensions (Frameit output with device frames)
    iphone_framed_size = { width: 1421, height: 2909, tolerance: 50 }
    ipad_framed_size = { width: 2286, height: 3168, tolerance: 50 }
    watch_size = { width: 396, height: 484, tolerance: 0 }  # Exact match required
    
    # Check framed iPhone/iPad screenshots
    framed_dir = File.expand_path("screenshots/framed", __dir__)
    locales.each do |locale|
      locale_dir = File.join(framed_dir, locale)
      unless Dir.exist?(locale_dir)
        errors << "âŒ Missing framed screenshots directory: #{locale_dir}"
        next
      end
      
      # Check iPhone framed screenshots
      iphone_framed = Dir.glob(File.join(locale_dir, "iPhone*_framed.png"))
      if iphone_framed.count != 5
        warnings << "âš ï¸  #{locale}: Expected 5 iPhone framed screenshots, found #{iphone_framed.count}"
      end
      
      iphone_framed.each do |shot|
        dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
        w, h = dims.split('x').map(&:to_i)
        if (w - iphone_framed_size[:width]).abs > iphone_framed_size[:tolerance] ||
           (h - iphone_framed_size[:height]).abs > iphone_framed_size[:tolerance]
          errors << "âŒ #{locale}/#{File.basename(shot)}: #{dims} (expected ~#{iphone_framed_size[:width]}x#{iphone_framed_size[:height]})"
        else
          puts "âœ… #{locale}/#{File.basename(shot)}: #{dims}"
        end
      end
      
      # Check iPad framed screenshots
      ipad_framed = Dir.glob(File.join(locale_dir, "iPad*_framed.png"))
      if ipad_framed.count != 5
        warnings << "âš ï¸  #{locale}: Expected 5 iPad framed screenshots, found #{ipad_framed.count}"
      end
      
      ipad_framed.each do |shot|
        dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
        w, h = dims.split('x').map(&:to_i)
        if (w - ipad_framed_size[:width]).abs > ipad_framed_size[:tolerance] ||
           (h - ipad_framed_size[:height]).abs > ipad_framed_size[:tolerance]
          errors << "âŒ #{locale}/#{File.basename(shot)}: #{dims} (expected ~#{ipad_framed_size[:width]}x#{ipad_framed_size[:height]})"
        else
          puts "âœ… #{locale}/#{File.basename(shot)}: #{dims}"
        end
      end
    end
    
    # Check watch naked screenshots
    watch_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    if Dir.exist?(watch_dir)
      locales.each do |locale|
        locale_dir = File.join(watch_dir, locale)
        unless Dir.exist?(locale_dir)
          errors << "âŒ Missing watch screenshots directory: #{locale_dir}"
          next
        end
        
        watch_shots = Dir.glob(File.join(locale_dir, "*.png"))
        if watch_shots.count != 5
          warnings << "âš ï¸  #{locale}: Expected 5 watch screenshots, found #{watch_shots.count}"
        end
        
        watch_shots.each do |shot|
          dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
          w, h = dims.split('x').map(&:to_i)
          if w != watch_size[:width] || h != watch_size[:height]
            errors << "âŒ #{locale}/#{File.basename(shot)}: #{dims} (expected exactly #{watch_size[:width]}x#{watch_size[:height]})"
          else
            puts "âœ… #{locale}/#{File.basename(shot)}: #{dims}"
          end
        end
      end
    else
      warnings << "âš ï¸  Watch screenshots directory not found: #{watch_dir}"
    end
    
    # Print summary
    puts "\n" + "=" * 70
    puts "Delivery Screenshot Validation Summary"
    puts "=" * 70
    
    if warnings.any?
      puts "\nWarnings:"
      warnings.each { |w| puts w }
    end
    
    if errors.any?
      puts "\nErrors:"
      errors.each { |e| puts e }
      puts "\nâŒ Validation FAILED: #{errors.count} error(s)"
      UI.user_error!("Delivery screenshots validation failed")
    else
      puts "\nâœ… All delivery screenshots are valid and ready for App Store submission!"
      puts "\nReady for upload:"
      puts "  â€¢ iPhone: 10 framed screenshots (~1421x2909)"
      puts "  â€¢ iPad: 10 framed screenshots (~2286x3168)"
      puts "  â€¢ Watch: 10 naked screenshots (396x484)"
      puts "  â€¢ Total: 30 screenshots across EN + FI locales"
    end
  end
end
