# Fastlane configuration
# Docs: https://docs.fastlane.tools
require 'base64'
require 'fileutils'
require 'shellwords'
require_relative 'lib/version_helper'
require_relative 'lib/watch_screenshot_helper'
require_relative 'lib/screenshot_helper'

default_platform(:ios)

def require_asc_env!
  missing = ["ASC_KEY_ID", "ASC_ISSUER_ID", "ASC_KEY_BASE64"].reject { |k| ENV[k].to_s.strip.size > 0 }
  UI.user_error!("Missing App Store Connect API key env vars: #{missing.join(', ')}") unless missing.empty?
end

# Prepare screenshots for deliver by copying only framed versions to a clean directory
def prepare_screenshots_for_delivery(framed_path)
  delivery_path = File.expand_path("screenshots/delivery", __dir__)
  FileUtils.rm_rf(delivery_path)
  FileUtils.mkdir_p(delivery_path)
  
  locales = %w[en-US fi]
  locales.each do |locale|
    src_dir = File.join(framed_path, locale)
    dst_dir = File.join(delivery_path, locale)
    FileUtils.mkdir_p(dst_dir)
    
    # Copy only framed screenshots (exclude non-framed variants)
    Dir.glob(File.join(src_dir, "*_framed.png")).each do |framed_file|
      FileUtils.cp(framed_file, dst_dir)
    end
  end
  
  delivery_path
end


platform :ios do
  desc "Run unit and UI tests (xcodebuild like CI)"
  lane :test do
    # Mirror CI behavior with xcodebuild and non-failing exit
    sh "cd ../ListAll && xcodebuild clean build -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 17 Pro,OS=latest' -configuration Debug CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
    sh "cd ../ListAll && xcodebuild test -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 17 Pro,OS=latest' -resultBundlePath ../fastlane/test_output/ListAll.xcresult CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
  end

  desc "Run tests via scan (Fastlane)"
  lane :test_scan do
    # Prefer project since workspace is embedded in .xcodeproj
    scan(
      project: "ListAll/ListAll.xcodeproj",
      scheme: "ListAll",
      clean: true,
      result_bundle: true,
      derived_data_path: "./ListAll/build",
      devices: ["iPhone 17 Pro"], # falls back to default if not available
      fail_build: false
    )
  end

  desc "Build and upload to TestFlight"
  desc "Options:"
  desc "  bump_type: 'patch' (default), 'minor', or 'major' - Type of version increment"
  desc "  skip_version_bump: true to skip version increment (use current version)"
  lane :beta do |options|
    # Setup CI environment (creates temporary keychain)
    if ENV['CI']
      setup_ci
      # Set keychain password for Match to use when importing certs
      ENV["KEYCHAIN_PASSWORD"] = ""  # setup_ci creates keychain with empty password
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    # Handle version numbering with semantic versioning
    unless options[:skip_version_bump]
      bump_type = options[:bump_type] || 'patch'
      
      # Read current version from file
      current_version = VersionHelper.read_version
      UI.message("üì¶ Current version: #{current_version}")
      
      # Increment version
      new_version = VersionHelper.increment_version(current_version, bump_type)
      UI.important("üì¶ Bumping version (#{bump_type}): #{current_version} ‚Üí #{new_version}")
      
      # Update version in all targets
      VersionHelper.update_xcodeproj_version(xcodeproj_path, new_version)
      
      # Save new version to file
      VersionHelper.write_version(new_version)
      
      # Validate all targets have the same version
      unless VersionHelper.validate_versions(xcodeproj_path)
        UI.user_error!("Version validation failed. Please check that all targets have matching versions.")
      end
      
      UI.success("‚úÖ Version updated to #{new_version}")
    else
      current_version = VersionHelper.read_version
      UI.message("‚è≠Ô∏è  Skipping version bump, using current version: #{current_version}")
    end
    
    # Increment build number automatically
    # In CI: use GitHub Actions run number, otherwise just increment by 1
    if ENV['GITHUB_RUN_NUMBER']
      increment_build_number(
        build_number: ENV['GITHUB_RUN_NUMBER'],
        xcodeproj: xcodeproj_path
      )
    else
      increment_build_number(
        xcodeproj: xcodeproj_path
      )
    end
    
    # Sync code signing with verbose output
    match(
      type: 'appstore',
      verbose: true,
      keychain_password: ENV["KEYCHAIN_PASSWORD"] || "",
      skip_set_partition_list: true  # Skip partition list in CI to avoid SecItemCopyMatching error
    )
    
    # Disable automatic code signing for Release configuration
    disable_automatic_code_signing(
      path: "ListAll/ListAll.xcodeproj",
      targets: ["ListAll", "ListAllWatch Watch App"],
      code_sign_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Update Xcode project to use the provisioning profiles from Match
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll_appstore_profile-path"],
      target_filter: "ListAll",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll.watchkitapp_appstore_profile-path"],
      target_filter: "ListAllWatch Watch App",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Build archive (gym/build_app handles exporting ipa)
    ipa_path = build_app(
      project: xcodeproj_path,
      scheme: "ListAll",
      export_method: "app-store",
      output_directory: "./ListAll/build",
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        provisioningProfiles: {
          "io.github.chmc.ListAll" => "match AppStore io.github.chmc.ListAll",
          "io.github.chmc.ListAll.watchkitapp" => "match AppStore io.github.chmc.ListAll.watchkitapp"
        }
      }
    )

    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_KEY_BASE64"]
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
        is_key_content_base64: false,
        in_house: false
      )
      pilot(
        ipa: ipa_path,
        api_key: api_key,
        distribute_external: false
      )
    else
      UI.important("ASC_* env vars not set. Skipping TestFlight upload. Archive built at: #{ipa_path}")
    end
  end

  desc "Deliver metadata/screenshots to App Store (no auto-submit)"
  lane :release do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist before attempting delivery
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("üì∏ Using framed screenshots from: #{delivery_path}")

    deliver(
      api_key: api_key,
      screenshots_path: delivery_path,
      skip_screenshots: false,
      overwrite_screenshots: true,
      skip_binary_upload: true,
      submit_for_review: false,
      force: true
    )
  end

  desc "Dry-run: Verify framed screenshots would be detected by deliver (no upload)"
  lane :release_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("üì∏ Verifying screenshots prepared for delivery from: #{delivery_path}")
    
    # List what deliver would find
    locales = %w[en-US fi]
    locales.each do |locale|
      locale_path = File.join(delivery_path, locale)
      if Dir.exist?(locale_path)
        screenshots = Dir.glob(File.join(locale_path, "*.png")).sort
        UI.header("#{locale} (#{screenshots.count} screenshots)")
        screenshots.each do |shot|
          basename = File.basename(shot)
          size = `identify -format '%wx%h' "#{shot}"`.strip rescue "unknown"
          UI.message("  #{basename} (#{size})")
        end
      else
        UI.error("Missing locale directory: #{locale_path}")
      end
    end
    
    UI.success("‚úÖ Framed screenshots are ready for delivery")
    UI.message("üí° Run 'bundle exec fastlane release' to upload to App Store Connect")
  end

  desc "Validate App Store Connect auth via API key (no uploads)"
  lane :asc_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # This will authenticate and fetch app metadata without uploading anything
    deliver(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_binary_upload: true,
      submit_for_review: false,
      run_precheck_before_submit: false,  # Precheck doesn't work with API keys
      force: true
    )
  end

  # Version management lanes
  
  desc "Show current version from all targets"
  lane :show_version do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.header("üì¶ Version Information")
    
    # Read from version file
    file_version = VersionHelper.read_version
    UI.message("Version file (.version): #{file_version}")
    
    # Read from git tag (if available)
    git_version = VersionHelper.version_from_git_tag
    UI.message("Latest git tag: #{git_version || 'none'}") if git_version
    
    # Read from Xcode project
    UI.message("\nXcode Project Versions:")
    targets = ['ListAll', 'ListAllWatch Watch App']
    targets.each do |target|
      begin
        version = get_version_number(
          xcodeproj: xcodeproj_path,
          target: target
        )
        build = get_build_number(xcodeproj: xcodeproj_path)
        UI.message("  #{target}: #{version} (#{build})")
      rescue => e
        UI.error("  #{target}: Error - #{e.message}")
      end
    end
    
    # Validate consistency
    UI.message("\n")
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("‚úÖ All versions are consistent")
    else
      UI.error("‚ùå Version mismatch detected")
    end
  end
  
  desc "Manually set version number"
  desc "Usage: fastlane set_version version:1.2.0"
  lane :set_version do |options|
    unless options[:version]
      UI.user_error!("Please specify version with version:X.Y.Z")
    end
    
    version = options[:version]
    
    # Validate semantic version format
    unless version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Version must be in format X.Y.Z (e.g., 1.2.0)")
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.important("üì¶ Setting version to: #{version}")
    
    # Update version in all targets
    VersionHelper.update_xcodeproj_version(xcodeproj_path, version)
    
    # Save to version file
    VersionHelper.write_version(version)
    
    # Validate
    unless VersionHelper.validate_versions(xcodeproj_path)
      UI.user_error!("Version validation failed")
    end
    
    UI.success("‚úÖ Version set to #{version}")
    UI.message("üí° Don't forget to commit the changes and create a git tag:")
    UI.message("   git add .version ListAll/ListAll.xcodeproj/project.pbxproj")
    UI.message("   git commit -m 'Bump version to #{version}'")
    UI.message("   git tag v#{version}")
    UI.message("   git push origin main --tags")
  end
  
  desc "Validate that all targets have matching versions"
  lane :validate_versions do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("‚úÖ All versions are valid and consistent")
    else
      UI.user_error!("‚ùå Version validation failed")
    end
  end
  
  desc "Generate screenshots for App Store"
  desc "Runs automated UI tests to capture screenshots for all configured devices and locales"
  lane :screenshots do
    # Capture screenshots using the snapshot tool
    snapshot
    
    UI.success("‚úÖ Screenshots generated successfully")
    UI.message("üìÅ Screenshots saved to: fastlane/screenshots")
  end

  desc "Unified App Store screenshot generation pipeline"
  desc "Generates all screenshots (iPhone, iPad, Watch) with validation and fail-fast checks"
  desc "This is the main entry point for CI/CD pipelines"
  lane :prepare_appstore do
    UI.header("üöÄ Starting App Store Screenshot Generation Pipeline")
    
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']
    
    begin
      # 1. Generate iPhone and iPad screenshots (with framing)
      # TEMPORARY SPEEDUP (task 5.5): Only Finnish iPad
      UI.header("Step 1/1: Generating iPad screenshots (Finnish only - speedup mode)")
      screenshots_framed

      # TEMPORARY SPEEDUP (task 5.5): Skip Watch screenshots
      # TODO: Revert in task 5.6
      # # 2. Generate Watch screenshots
      # UI.header("Step 2/2: Generating Watch screenshots")
      # watch_screenshots

      # 3. Final validation: ensure all expected screenshots exist
      UI.header("Final Validation: Verifying all screenshots were generated")
      validate_delivery_screenshots
      
      UI.success("üéâ App Store screenshot generation pipeline completed successfully!")
      UI.message("üìÅ All screenshots ready in: fastlane/screenshots/framed/")
      UI.message("   - iPhone/iPad: Framed screenshots")
      UI.message("   - Watch: Normalized screenshots (unframed)")
      
    rescue => e
      UI.error("‚ùå Pipeline failed: #{e.message}")
      UI.error("Stack trace: #{e.backtrace.join("\n")}")
      raise
    end
  end

  desc "Generate and frame screenshots (snapshot + frameit)"
  lane :screenshots_framed do
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']

    # Clean up old screenshot subdirectories that accumulate in local development
    # CI doesn't need this as it starts with clean workspace
    screenshots_dir = File.expand_path("screenshots", __dir__)
    UI.message("üßπ Cleaning old screenshot subdirectories...")
    %w[test_output watch delivery attachments].each do |subdir|
      subdir_path = File.join(screenshots_dir, subdir)
      if Dir.exist?(subdir_path)
        UI.message("  Removing #{subdir}...")
        FileUtils.rm_rf(subdir_path)
      end
    end
    # Also clean subdirectories within language folders
    %w[en-US fi].each do |lang|
      lang_dir = File.join(screenshots_dir, lang)
      next unless Dir.exist?(lang_dir)
      Dir.glob(File.join(lang_dir, "*")).select { |p| File.directory?(p) }.each do |subdir|
        UI.message("  Removing #{File.basename(lang_dir)}/#{File.basename(subdir)}...")
        FileUtils.rm_rf(subdir)
      end
    end

    # Shared derived data path for prebuild and snapshot
    # CRITICAL: Use absolute path for derived data to ensure xcresult bundle extraction works
    # Use Dir.pwd to get project root (not fastlane directory)
    project_root = File.expand_path("..", __dir__)
    derived = File.join(project_root, "fastlane", "derivedDataSnapshot")
    
    # REMOVED: ONE-TIME BUILD-FOR-TESTING OPTIMIZATION
    # Method-level only_testing does not work reliably with test_without_building - tests hang after "Testing started"
    # Fallback approach: Let snapshot build and run tests for each device/locale combination
    # This is slower (~40-50 minutes total vs ~20-30 with optimization) but more reliable
    # Full build+test fully supports only_testing at method level
    UI.header("Using full build+test approach for maximum reliability")
    
    # 1. Raw screenshots using pre-built products
    # Run snapshot per device/language combination for incremental verification
    # This provides immediate feedback instead of waiting 30+ minutes
    screenshots_dir = File.expand_path("screenshots", __dir__)
    # TEMPORARY SPEEDUP (task 5.5): Only Finnish iPad to debug pipeline faster
    # TODO: Revert in task 5.6
    # devices = ["iPhone 16 Pro Max", "iPad Pro 13-inch (M4)"]
    # locales = %w[en-US fi]
    devices = ["iPad Pro 13-inch (M4)"]
    locales = %w[fi]
    
    # Track expected screenshots (5 per test method √ó 2 test methods = 10 per device/locale)
    expected_per_combination = 10
    
    # Set environment variable to reduce simulator boot wait time (default is 120s)
    # This significantly speeds up failure detection - fail fast if simulators are slow
    ENV['SNAPSHOT_SIMULATOR_WAIT_FOR_BOOT_TIMEOUT'] = '30'
    
    # CRITICAL: Set SIMULATOR_HOST_HOME environment variable for SnapshotHelper
    # SnapshotHelper requires this to find the cache directory where screenshots are saved
    # Fastlane snapshot should set this automatically, but with test_without_building it may not work
    simulator_host_home = ENV['HOME'] || Dir.home
    ENV['SIMULATOR_HOST_HOME'] = simulator_host_home
    UI.message("üîß Setting SIMULATOR_HOST_HOME=#{simulator_host_home} for SnapshotHelper")
    
    devices.each_with_index do |device, device_idx|
      locales.each_with_index do |locale, locale_idx|
        is_first = device_idx == 0 && locale_idx == 0
        UI.header("üì∏ Generating screenshots for #{device} (#{locale})")
        
        # Run snapshot for this specific device/language combination
        # Only clear screenshots on first run, then append
        # CRITICAL FIX: Use result_bundle: false to enable Fastlane log parsing for automatic screenshot extraction
        # With xcodebuild_formatter: "" and NSUnbufferedIO=YES, log parsing works correctly with test_without_building
        # Fastlane parses NSLog("snapshot: ...") entries from logs to automatically extract screenshots
        # result_bundle_path is kept for fallback manual extraction if needed
        result_bundle_path = File.join(screenshots_dir, "test_output", locale, "ListAll.xcresult")
        FileUtils.mkdir_p(File.dirname(result_bundle_path)) unless File.directory?(File.dirname(result_bundle_path))
        
        # CRITICAL: Set NSUnbufferedIO=YES to ensure xcodebuild outputs logs in correct order
        # This is especially important in CI environments where log buffering can cause issues
        # Research shows this is essential for proper log capture with test_without_building
        # Set as environment variable so xcodebuild inherits it (snapshot doesn't support xcodebuild_command parameter)
        ENV['NSUnbufferedIO'] = 'YES'
        
        # CRITICAL: Ensure SIMULATOR_HOST_HOME is set so SnapshotHelper can find the cache directory
        # This is essential for screenshot saving in CI environments
        # When using test_without_building, we need to pass this through xcodebuild's environment
        simulator_host_home = ENV['SIMULATOR_HOST_HOME'] || ENV['HOME'] || Dir.home
        ENV['SIMULATOR_HOST_HOME'] = simulator_host_home
        UI.message("üîß Setting SIMULATOR_HOST_HOME=#{simulator_host_home} for SnapshotHelper")
        
        # CRITICAL FIX: Set SIMULATOR_DEVICE_NAME explicitly so SnapshotHelper can save screenshots with correct filename
        # Fastlane snapshot normally sets this, but with test_without_building it may not work correctly
        # Device name format: Remove spaces and special characters (e.g., "iPhone 16 Pro Max" -> "iPhone16ProMax")
        device_name_sanitized = device.gsub(/[^a-zA-Z0-9]/, "")
        ENV['SIMULATOR_DEVICE_NAME'] = device_name_sanitized
        UI.message("üîß Setting SIMULATOR_DEVICE_NAME=#{device_name_sanitized} for SnapshotHelper")
        
        # CRITICAL FIX: Fastlane snapshot may not pass environment variables correctly with test_without_building
        # Use xcargs to pass environment variables via test environment (works more reliably)
        # However, xcargs is for build settings, not environment variables
        # Instead, we rely on Fastlane's automatic passing AND ensure cache files are created
        
        # CRITICAL DIAGNOSTICS: Log environment variables before snapshot runs
        UI.message("üîç DIAGNOSTICS: Environment variables before snapshot:")
        UI.message("   SIMULATOR_HOST_HOME=#{ENV['SIMULATOR_HOST_HOME']}")
        UI.message("   SIMULATOR_DEVICE_NAME=#{ENV['SIMULATOR_DEVICE_NAME']}")
        UI.message("   HOME=#{ENV['HOME']}")
        UI.message("   FASTLANE_SNAPSHOT=#{ENV['FASTLANE_SNAPSHOT']}")
        UI.message("   FASTLANE_LANGUAGE=#{ENV['FASTLANE_LANGUAGE']}")
        
        # CRITICAL: Verify cache directory exists and is writable
        cache_dir_to_check = File.join(simulator_host_home, "Library/Caches/tools.fastlane")
        screenshots_dir_to_check = File.join(cache_dir_to_check, "screenshots")
        UI.message("üîç DIAGNOSTICS: Cache directory verification:")
        UI.message("   Cache dir: #{cache_dir_to_check}")
        UI.message("   Cache dir exists: #{Dir.exist?(cache_dir_to_check)}")
        UI.message("   Screenshots dir: #{screenshots_dir_to_check}")
        UI.message("   Screenshots dir exists: #{Dir.exist?(screenshots_dir_to_check)}")
        
        # Ensure cache directory exists and is writable
        begin
          FileUtils.mkdir_p(screenshots_dir_to_check) unless Dir.exist?(screenshots_dir_to_check)
          test_file = File.join(screenshots_dir_to_check, ".test_write")
          File.write(test_file, "test")
          File.delete(test_file)
          UI.message("   ‚úÖ Cache directory is writable")
        rescue => e
          UI.error("   ‚ùå Cache directory is NOT writable: #{e.message}")
        end
        
        # CRITICAL FIX: Manually create Fastlane cache files that SnapshotHelper expects
        # Fastlane snapshot normally creates these files, but with test_without_building it may not
        # SnapshotHelper reads: language.txt, locale.txt, snapshot-launch_arguments.txt
        UI.message("üîß Creating Fastlane cache files for SnapshotHelper...")
        begin
          # Create language.txt (e.g., "en-US" -> "en")
          language_code = locale.split("-").first
          language_file = File.join(cache_dir_to_check, "language.txt")
          File.write(language_file, language_code)
          UI.message("   ‚úÖ Created language.txt: #{language_code}")
          
          # Create locale.txt (e.g., "en-US")
          locale_file = File.join(cache_dir_to_check, "locale.txt")
          File.write(locale_file, locale)
          UI.message("   ‚úÖ Created locale.txt: #{locale}")
          
          # Create snapshot-launch_arguments.txt (can be empty, but file should exist)
          launch_args_file = File.join(cache_dir_to_check, "snapshot-launch_arguments.txt")
          File.write(launch_args_file, "") unless File.exist?(launch_args_file)
          UI.message("   ‚úÖ Created snapshot-launch_arguments.txt")
          
          # CRITICAL: Also create a file with SIMULATOR_DEVICE_NAME for SnapshotHelper to read
          # This is a workaround since environment variables may not be passed correctly
          device_name_file = File.join(cache_dir_to_check, "device_name.txt")
          File.write(device_name_file, device_name_sanitized)
          UI.message("   ‚úÖ Created device_name.txt: #{device_name_sanitized}")
          
          # CRITICAL FIX: Write SIMULATOR_HOST_HOME to a file so SnapshotHelper can read it
          # Environment variables may not be passed correctly with test_without_building
          simulator_host_home_file = File.join(cache_dir_to_check, "simulator_host_home.txt")
          File.write(simulator_host_home_file, simulator_host_home)
          UI.message("   ‚úÖ Created simulator_host_home.txt: #{simulator_host_home}")
          
          # CRITICAL FIX: Create cache files in ALL simulators matching device name BEFORE snapshot runs
          # Fastlane snapshot may boot a different simulator than the one we find, so we create files in all matches
          # SnapshotHelper runs in the simulator and uses NSHomeDirectory() which returns the simulator's home
          # The simulator's data directory exists even when not booted, so we can create files there
          # STABLE APPROACH: Create files in all matching simulators to ensure the one that gets used has the files
          begin
            simulator_info = `xcrun simctl list devices --json 2>&1`
            if $?.success?
              require 'json'
              sim_data = JSON.parse(simulator_info)
              
              # Find ALL simulators matching our device name (Fastlane snapshot may use any of them)
              matching_sims = []
              
              sim_data['devices'].each do |runtime, devices|
                devices.each do |sim|
                  if sim['name'] == device && sim['dataPath']
                    matching_sims << sim
                  end
                end
              end
              
              if matching_sims.any?
                UI.message("   üîç Found #{matching_sims.count} simulator(s) matching '#{device}'")
                matching_sims.each do |target_sim|
                  sim_cache_dir = File.join(target_sim['dataPath'], "Library/Caches/tools.fastlane")
                  begin
                    FileUtils.mkdir_p(sim_cache_dir) unless Dir.exist?(sim_cache_dir)
                    
                    # Create all cache files in simulator's cache directory
                    sim_language_file = File.join(sim_cache_dir, "language.txt")
                    sim_locale_file = File.join(sim_cache_dir, "locale.txt")
                    sim_launch_args_file = File.join(sim_cache_dir, "snapshot-launch_arguments.txt")
                    sim_device_name_file = File.join(sim_cache_dir, "device_name.txt")
                    sim_host_home_file = File.join(sim_cache_dir, "simulator_host_home.txt")
                    
                    File.write(sim_language_file, language_code)
                    File.write(sim_locale_file, locale)
                    File.write(sim_launch_args_file, "") unless File.exist?(sim_launch_args_file)
                    File.write(sim_device_name_file, device_name_sanitized)
                    File.write(sim_host_home_file, simulator_host_home)
                    
                    UI.message("   ‚úÖ Created cache files in simulator: #{target_sim['name']} (#{target_sim['udid']})")
                    UI.message("      Path: #{sim_cache_dir}")
                  rescue => e
                    UI.message("   ‚ö†Ô∏è  Could not create cache files in simulator #{target_sim['udid']}: #{e.message}")
                  end
                end
              else
                UI.message("   ‚ö†Ô∏è  Could not find simulator '#{device}' - cache files will be created when simulator is booted")
                # Note: SnapshotHelper will try to create cache directory if it doesn't exist, but may fail
                # This is acceptable - the file-based approach is a workaround, not required
              end
            end
          rescue => e
            UI.message("   ‚ö†Ô∏è  Could not find simulator to create cache files: #{e.message}")
          end
          
        rescue => e
          UI.error("   ‚ùå Failed to create cache files: #{e.message}")
        end
        
        # CRITICAL FIX: Set environment variables in Ruby ENV so they're available to test process
        # Fastlane snapshot automatically passes Ruby ENV variables to xcodebuild, which forwards them to the test process
        # This is the correct way to pass environment variables (not via xcargs, which is for build settings only)
        ENV['FASTLANE_SNAPSHOT'] = 'YES'
        ENV['FASTLANE_LANGUAGE'] = locale
        ENV['SIMULATOR_HOST_HOME'] = simulator_host_home
        ENV['SIMULATOR_DEVICE_NAME'] = device_name_sanitized
        ENV['NSUnbufferedIO'] = 'YES'
        
        # Use xcargs only for build settings (code signing), not environment variables
        # Environment variables are passed automatically via Ruby ENV above
        existing_xcargs = "CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO"
        
        # CRITICAL FIX: Remove only_testing when using test_without_building
        # When using test_without_building, xcodebuild may not correctly match test identifiers
        # from the pre-built test bundle. Instead, let it discover all tests and filter via skip_testing.
        # The test methods will still run because they're the only ones in the test bundle.
        #
        # CRITICAL FIX #2: Explicitly specify only_testing for ListAllUITests target to ensure tests are discovered
        # When using test_without_building, we need to tell xcodebuild which TARGET to run tests from
        # Format: "TargetName" (not "TargetName/TestClass/testMethod")
        snapshot(
          derived_data_path: derived,
          devices: [device],
          languages: [locale],
          # Note: ios_version parameter removed - Fastlane will auto-select iOS 18.1 for both devices
          # iPhone 16 Pro Max only has iOS 18.1, iPad has both 18.1 and 18.2 beta (18.1 preferred)
          clear_previous_screenshots: is_first,  # Only clear on first run
          # SIMPLIFIED: Use method-level only_testing to run ONLY the screenshot tests
          # Format: "TargetName/ClassName/testMethodName"
          # This runs only the 2 simplified screenshot test methods and skips all other tests
          # Using new simplified ListAllUITests_Screenshots class with no complex detection logic
          only_testing: [
            "ListAllUITests/ListAllUITests_Screenshots/testScreenshots01_WelcomeScreen",
            "ListAllUITests/ListAllUITests_Screenshots/testScreenshots02_MainFlow"
          ],
          skip_testing: ["ListAllTests"],  # Skip unit tests
          xcodebuild_formatter: "",  # Empty string disables formatter, allowing Fastlane to parse logs
          buildlog_path: "~/Library/Logs/snapshot",  # Explicit log path for better debugging
          xcargs: existing_xcargs,  # Only build settings, not environment variables
          # CRITICAL FIX: Use result_bundle: false to enable Fastlane log parsing for automatic screenshot extraction
          # With xcodebuild_formatter: "" and NSUnbufferedIO=YES, log parsing works correctly
          # Fastlane parses NSLog("snapshot: ...") entries from logs to automatically extract screenshots
          # Manual extraction code below provides fallback if automatic extraction fails
          result_bundle: false,
          # Other settings (override_status_bar, reinstall_app, etc.) come from Snapfile defaults
        )

        # CRITICAL VALIDATION: Check if tests actually executed
        # If 0 tests ran, fail immediately instead of waiting 20 minutes for each device/locale
        UI.message("üîç VALIDATION: Checking if tests executed...")
        test_output_files = Dir.glob(File.join(screenshots_dir, "**", "*.html"))
        test_logs = Dir.glob(File.expand_path("~/Library/Logs/snapshot/**/*.log"))

        # Check for signs that tests ran in the logs
        tests_executed = false
        if test_logs.any?
          test_logs.first(3).each do |log_file|
            begin
              log_content = File.read(log_file)
              # Look for test execution patterns
              if log_content.include?("testScreenshots") ||
                 log_content.include?("Test Suite") ||
                 log_content =~ /\d+ tests?.*passed/i
                tests_executed = true
                UI.success("   ‚úÖ Found evidence of test execution in logs")
                break
              end
            rescue => e
              UI.message("   ‚ö†Ô∏è  Could not read log file: #{e.message}")
            end
          end
        end

        # If we have screenshots in the output, tests must have run
        if Dir.glob(File.join(screenshots_dir, locale, "*.png")).any?
          tests_executed = true
          UI.success("   ‚úÖ Screenshots found - tests definitely executed")
        end

        unless tests_executed
          UI.important("   ‚ö†Ô∏è  WARNING: No evidence of test execution found!")
          UI.important("   This might indicate tests ran with 0 test methods")
          UI.important("   Continuing anyway - manual extraction will attempt to find screenshots")
        end

        # CRITICAL DIAGNOSTICS: Verify environment variables after snapshot (they should still be set)
        UI.message("üîç DIAGNOSTICS: Environment variables after snapshot:")
        UI.message("   SIMULATOR_HOST_HOME=#{ENV['SIMULATOR_HOST_HOME']}")
        UI.message("   SIMULATOR_DEVICE_NAME=#{ENV['SIMULATOR_DEVICE_NAME']}")
        
        # FALLBACK: Create cache files in booted simulator if they weren't created before
        # This handles the case where simulator wasn't found before snapshot booted it
        begin
          simulator_info = `xcrun simctl list devices --json 2>&1`
          if $?.success?
            require 'json'
            sim_data = JSON.parse(simulator_info)
            
            # Find booted simulator matching our device
            booted_sim = nil
            sim_data['devices'].each do |runtime, devices|
              devices.each do |sim|
                if sim['name'] == device && sim['state'] == 'Booted' && sim['dataPath']
                  booted_sim = sim
                  break
                end
              end
              break if booted_sim
            end
            
            if booted_sim && booted_sim['dataPath']
              sim_cache_dir = File.join(booted_sim['dataPath'], "Library/Caches/tools.fastlane")
              
              # Check if cache files already exist
              language_file = File.join(sim_cache_dir, "language.txt")
              if !File.exist?(language_file)
                UI.message("   üîß FALLBACK: Creating cache files in booted simulator...")
                begin
                  FileUtils.mkdir_p(sim_cache_dir) unless Dir.exist?(sim_cache_dir)
                  
                  language_code = locale.split("-").first
                  File.write(File.join(sim_cache_dir, "language.txt"), language_code)
                  File.write(File.join(sim_cache_dir, "locale.txt"), locale)
                  File.write(File.join(sim_cache_dir, "snapshot-launch_arguments.txt"), "") unless File.exist?(File.join(sim_cache_dir, "snapshot-launch_arguments.txt"))
                  File.write(File.join(sim_cache_dir, "device_name.txt"), device_name_sanitized)
                  File.write(File.join(sim_cache_dir, "simulator_host_home.txt"), simulator_host_home)
                  
                  UI.message("   ‚úÖ Created cache files in booted simulator: #{sim_cache_dir}")
                rescue => e
                  UI.message("   ‚ö†Ô∏è  Could not create cache files in booted simulator: #{e.message}")
                end
              else
                UI.message("   ‚úÖ Cache files already exist in simulator: #{sim_cache_dir}")
              end
            end
          end
        rescue => e
          UI.message("   ‚ö†Ô∏è  Could not verify/create cache files in booted simulator: #{e.message}")
        end
        
        # CRITICAL FIX: Fastlane's log parsing often fails in CI environments where NSLog isn't captured
        # Manually extract screenshots from cache directory after tests complete
        # This bypasses Fastlane's log parsing entirely and works reliably
        UI.message("üîç Attempting manual screenshot extraction from cache directories...")
        locale_dir = File.join(screenshots_dir, locale)
        FileUtils.mkdir_p(locale_dir) unless File.directory?(locale_dir)
        extracted_count = 0
        
        # CRITICAL: Fastlane Snapshot saves screenshots to cache directory, but may not extract them
        # if log parsing fails. We need to manually find and copy them.
        # Screenshots are saved as: <simulator-name>-<screenshot-name>.png
        # e.g., "iPhone16ProMax-01-WelcomeScreen.png"
        
        # Method 1: Extract from result bundle (FALLBACK - only if Fastlane automatic extraction fails)
        # With result_bundle: false, Fastlane should automatically extract screenshots via log parsing
        # This manual extraction is a fallback in case automatic extraction doesn't work
        # Check multiple possible result bundle locations (may exist even with result_bundle: false)
        possible_result_bundles = [
          result_bundle_path,  # Our custom path
          File.join(screenshots_dir, locale, "ListAll.xcresult"),  # Fastlane default
          File.join(screenshots_dir, "ListAll.xcresult"),  # Alternative default
        ]
        
        # Also check in derived data for result bundles
        if derived && Dir.exist?(derived)
          possible_result_bundles += Dir.glob(File.join(derived, "**", "*.xcresult")).select { |f| File.directory?(f) }
        end
        
        result_bundle_to_check = possible_result_bundles.find { |path| File.exist?(path) }
        
        if result_bundle_to_check
          UI.message("   ‚úÖ Found result bundle: #{result_bundle_to_check}")
          
          # Method 1a: Use xcresulttool to extract attachments (most reliable)
          # CRITICAL: This extracts XCTest attachments which we're now using as backup
          begin
            attachments_dir = File.join(locale_dir, "attachments")
            FileUtils.mkdir_p(attachments_dir) unless File.directory?(attachments_dir)
            
            # Try multiple xcresulttool command variations
            # NOTE: The plugin doesn't have a direct attachments action, so we use the generic xcresulttool action
            attachments_output = nil
            success = false
            
            # CRITICAL FIX: Use correct modern API command
            # The correct command is "export attachments" not just "attachments"
            # This is part of the modern API and is more reliable
            attachments_output = `xcrun xcresulttool export attachments --path "#{result_bundle_to_check}" --output-path "#{attachments_dir}" 2>&1`
            if $?.success?
              success = true
              UI.message("   ‚úÖ Modern export attachments API succeeded")
              # Check if manifest.json was created (indicates successful extraction)
              manifest_path = File.join(attachments_dir, "manifest.json")
              if File.exist?(manifest_path)
                UI.message("   ‚úÖ Attachment manifest created - checking contents...")
                begin
                  require 'json'
                  manifest_content = File.read(manifest_path)
                  UI.message("   üìÑ Manifest file size: #{manifest_content.length} bytes")
                  manifest_data = JSON.parse(manifest_content)
                  
                  # Check different possible structures
                  attachments = nil
                  if manifest_data.is_a?(Array)
                    attachments = manifest_data
                    UI.message("   üìã Manifest is an array with #{attachments.count} item(s)")
                  elsif manifest_data.is_a?(Hash)
                    if manifest_data['attachments'] && manifest_data['attachments'].is_a?(Array)
                      attachments = manifest_data['attachments']
                    elsif manifest_data['tests'] && manifest_data['tests'].is_a?(Array)
                      # Manifest might be organized by tests
                      attachments = []
                      manifest_data['tests'].each do |test|
                        if test['attachments'] && test['attachments'].is_a?(Array)
                          attachments.concat(test['attachments'])
                        end
                      end
                    end
                    UI.message("   üìã Manifest is a hash, found #{attachments ? attachments.count : 0} attachment(s)")
                  end
                  
                  if attachments && attachments.any?
                    UI.message("   üìã Total attachments found: #{attachments.count}")
                    attachments.first(10).each do |att|
                      if att.is_a?(Hash)
                        UI.message("     - #{att['filename'] || att['name'] || 'unnamed'} (#{att['type'] || att['contentType'] || 'unknown type'})")
                      else
                        UI.message("     - #{att.inspect}")
                      end
                    end
                    if attachments.count > 10
                      UI.message("     ... (#{attachments.count - 10} more)")
                    end
                  else
                    UI.message("   ‚ö†Ô∏è  Manifest exists but no attachments found")
                    if manifest_data.is_a?(Hash)
                      UI.message("   üìÑ Manifest structure: #{manifest_data.keys.join(', ')}")
                    end
                  end
                rescue JSON::ParserError => e
                  UI.message("   ‚ö†Ô∏è  JSON parse error: #{e.message}")
                  UI.message("   üìÑ First 200 chars of manifest: #{File.read(manifest_path)[0..200]}")
                rescue => e
                  UI.message("   ‚ö†Ô∏è  Could not parse manifest.json: #{e.message}")
                  UI.message("   üìÑ Error class: #{e.class}")
                  UI.message("   üìÑ Backtrace: #{e.backtrace.first(3).join("\n")}")
                end
              end
            else
              UI.message("   ‚ö†Ô∏è  export attachments failed: #{attachments_output.chomp}")
            end
            
            if !success
              # Try 3: Direct file system search for PNG files in result bundle
              UI.message("   ‚ö†Ô∏è  export attachments failed, searching result bundle file system for PNGs...")
              
              # CRITICAL: Search result bundle directory structure directly for PNG files
              # XCTest attachments are stored in the bundle, we can find them by searching
              if Dir.exist?(result_bundle_to_check)
                # Search for PNG files recursively in result bundle
                png_files_in_bundle = Dir.glob(File.join(result_bundle_to_check, "**", "*.{png,PNG}"))
                if png_files_in_bundle.any?
                  UI.message("   ‚úÖ Found #{png_files_in_bundle.count} PNG files in result bundle!")
                  png_files_in_bundle.each do |png_path|
                    basename = File.basename(png_path)
                    # Extract screenshot name from filename (remove device prefix if present)
                    # FIXED: Device names like "iPad Pro 13-inch (M4)" contain hyphens, so we can't just split on first hyphen
                    # Instead, look for the screenshot number pattern (e.g., "-01_" or "-02_") which marks the end of device name
                    screenshot_name = basename
                    if match = basename.match(/^(.+?)(-\d{2}[-_].+\.png)$/i)
                      device_part = match[1]
                      screenshot_part = match[2]
                      # Only strip device prefix if it looks like a device name (contains iPhone or iPad)
                      if device_part.include?("iPhone") || device_part.include?("iPad")
                        screenshot_name = screenshot_part.sub(/^-/, '') # Remove leading hyphen
                      end
                    end
                    dst = File.join(locale_dir, screenshot_name)
                    unless File.exist?(dst)
                      FileUtils.cp(png_path, dst)
                      extracted_count += 1
                      UI.message("   ‚úÖ Extracted screenshot from bundle: #{screenshot_name}")
                    end
                  end
                else
                  UI.message("   ‚ö†Ô∏è  No PNG files found in result bundle file system")
                end
              end
            end
            
            # Check if attachments were extracted
            if Dir.exist?(attachments_dir)
              # Recursively search for PNG files
              png_files = Dir.glob(File.join(attachments_dir, "**", "*.{png,PNG}"))
              
              if png_files.any?
                UI.message("   ‚úÖ Found #{png_files.count} PNG files in result bundle attachments")
                
                png_files.each do |src|
                  # Extract meaningful filename from path or use basename
                  basename = File.basename(src)
                  
                  # Try to extract screenshot name from path if it contains test/screenshot info
                  # Screenshot names from SnapshotHelper are like: "iPhone16ProMax-01-WelcomeScreen.png"
                  # or they might be in subdirectories with test names
                  dst = File.join(locale_dir, basename)
                  
                  # If file already exists, try to extract a better name from the path
                  if File.exist?(dst)
                    path_parts = src.split(File::SEPARATOR)
                    # Look for parts that might contain screenshot names (e.g., "01-WelcomeScreen")
                    screenshot_name = path_parts.find { |p| p.match?(/^\d{2}-|screenshot|snapshot/i) } || basename
                    dst = File.join(locale_dir, screenshot_name)
                  end
                  
                  FileUtils.cp(src, dst) unless File.exist?(dst)
                  extracted_count += 1
                  UI.message("   ‚úÖ Extracted: #{File.basename(dst)}")
                end
                
                # Clean up
                FileUtils.rm_rf(attachments_dir)
              else
                UI.message("   ‚ö†Ô∏è  No PNG files found in attachments directory")
                # List what files were found for debugging
                all_files = Dir.glob(File.join(attachments_dir, "**", "*")).select { |f| File.file?(f) }
                if all_files.any?
                  UI.message("   Found #{all_files.count} files total, first 10: #{all_files.first(10).map { |f| File.basename(f) }.join(", ")}")
                end
                # Don't clean up yet - we'll check cache directories next
              end
            else
              UI.message("   ‚ö†Ô∏è  Attachments directory not created - attachments command may have failed")
              if attachments_output && !attachments_output.empty?
                UI.message("   Error output: #{attachments_output.chomp}")
              end
            end
          rescue => e
            UI.message("   ‚ö†Ô∏è  Error using xcresulttool: #{e.message}")
            UI.message("   Backtrace: #{e.backtrace.first(3).join("\n")}")
          end
          
          # Method 1b: Direct file system access (fallback)
          # Check multiple possible attachment locations in result bundle
          possible_attachment_dirs = [
            File.join(result_bundle_to_check, "Attachments"),
            File.join(result_bundle_to_check, "Data", "Attachments"),
            File.join(result_bundle_to_check, "TestSummaries.plist") # Sometimes attachments are referenced here
          ]
          
          possible_attachment_dirs.each do |attachments_dir|
            if Dir.exist?(attachments_dir)
              UI.message("   Checking attachments directory: #{attachments_dir}")
              # Find all PNG attachments (case-insensitive)
              png_files = Dir.glob(File.join(attachments_dir, "**", "*.{png,PNG}"))
              if png_files.any?
                UI.message("   Found #{png_files.count} PNG files in #{attachments_dir}")
                png_files.each do |src|
                  basename = File.basename(src)
                  dst = File.join(locale_dir, basename)
                  FileUtils.cp(src, dst) unless File.exist?(dst)
                  extracted_count += 1
                  UI.message("   ‚úÖ Extracted: #{basename}")
                end
              end
            end
          end
          
          # Also check if result bundle has a Data directory structure
          data_dir = File.join(result_bundle_to_check, "Data")
          if Dir.exist?(data_dir)
            UI.message("   Exploring result bundle Data directory structure...")
            # List top-level directories
            Dir.entries(data_dir).each do |entry|
              next if entry.start_with?(".")
              entry_path = File.join(data_dir, entry)
              if File.directory?(entry_path)
                UI.message("     Found directory: #{entry}")
                # Check for PNG files recursively
                png_files = Dir.glob(File.join(entry_path, "**", "*.{png,PNG}"))
                if png_files.any?
                  UI.message("       Found #{png_files.count} PNG files in #{entry}")
                  png_files.each do |src|
                    basename = File.basename(src)
                    dst = File.join(locale_dir, basename)
                    FileUtils.cp(src, dst) unless File.exist?(dst)
                    extracted_count += 1
                    UI.message("       ‚úÖ Extracted: #{basename}")
                  end
                end
              end
            end
          end
          
          UI.message("   Extracted #{extracted_count} screenshots from result bundle (Method 1b)") if extracted_count > 0
        else
          UI.message("   ‚ö†Ô∏è  Result bundle not found at: #{result_bundle_to_check} (Fastlane should have extracted screenshots automatically)")
        end
        
        # Method 2: Extract from simulator cache directory (SnapshotHelper saves here)
        # CRITICAL: Check multiple possible locations for cache directory
        # In CI, the simulator may run in a different context than the runner
        # Based on research: SnapshotHelper saves to Library/Caches/tools.fastlane/screenshots
        # relative to SIMULATOR_HOST_HOME, HOME, or simulator's data directory
        possible_cache_dirs = []
        
        # CRITICAL: Use the same SIMULATOR_HOST_HOME that we set above (PRIMARY LOCATION)
        # This ensures we're checking the exact location where SnapshotHelper will save screenshots
        simulator_host_home_for_check = simulator_host_home || ENV['SIMULATOR_HOST_HOME'] || ENV['HOME'] || Dir.home
        if simulator_host_home_for_check
          primary_cache_dir = File.join(simulator_host_home_for_check, "Library/Caches/tools.fastlane/screenshots")
          possible_cache_dirs << primary_cache_dir
          UI.message("   üîç Primary cache directory to check: #{primary_cache_dir}")
          # CRITICAL FIX: Also check the base cache directory (screenshots might be saved directly there)
          base_cache_dir = File.join(simulator_host_home_for_check, "Library/Caches/tools.fastlane")
          possible_cache_dirs << base_cache_dir
          UI.message("   üîç Base cache directory to check: #{base_cache_dir}")
        end
        
        # Also try ENV['SIMULATOR_HOST_HOME'] directly (in case it was set differently)
        if ENV['SIMULATOR_HOST_HOME'] && ENV['SIMULATOR_HOST_HOME'] != simulator_host_home_for_check
          possible_cache_dirs << File.join(ENV['SIMULATOR_HOST_HOME'], "Library/Caches/tools.fastlane/screenshots")
        end
        
        # Try HOME environment variable - FALLBACK FOR CI
        if ENV['HOME']
          possible_cache_dirs << File.join(ENV['HOME'], "Library/Caches/tools.fastlane/screenshots")
        end
        
        # Try runner's home directory (CI context - GitHub Actions)
        if ENV['RUNNER_HOME']
          possible_cache_dirs << File.join(ENV['RUNNER_HOME'], "Library/Caches/tools.fastlane/screenshots")
        end
        
        # Try current user's home - LOCAL DEVELOPMENT
        possible_cache_dirs << File.join(Dir.home, "Library/Caches/tools.fastlane/screenshots")
        
        # Try simulator's actual data directory (extract from simulator info)
        # Research shows: Simulator data is in ~/Library/Developer/CoreSimulator/Devices/<UUID>/data
        # CRITICAL FIX: Check ALL simulators, not just the one matching device name
        # In CI, the simulator might be booted with a different name or UUID
        begin
          simulator_info = `xcrun simctl list devices --json 2>&1`
          if $?.success?
            require 'json'
            sim_data = JSON.parse(simulator_info)
            # Find the device we're using and get its data directory
            device_name = device.gsub(" ", "").gsub("-", "")
            sim_data['devices'].each do |runtime, devices|
              devices.each do |sim|
                # Check both exact match and partial match
                if sim['name'] == device || sim['name'].include?(device_name) || sim['name'].gsub(/[^a-zA-Z0-9]/, "") == device_name
                  if sim['dataPath']
                    # Simulator's data directory - screenshots might be in Library/Caches
                    possible_cache_dirs << File.join(sim['dataPath'], "Library/Caches/tools.fastlane/screenshots")
                    # Also check simulator's home directory (if different from dataPath)
                    sim_home = File.join(sim['dataPath'], "Library")
                    possible_cache_dirs << File.join(sim_home, "Caches/tools.fastlane/screenshots")
                    # CRITICAL FIX: Also check base cache directory (screenshots might be saved there)
                    possible_cache_dirs << File.join(sim['dataPath'], "Library/Caches/tools.fastlane")
                    UI.message("   üîç Added simulator cache dir: #{File.join(sim['dataPath'], 'Library/Caches/tools.fastlane/screenshots')}")
                  end
                end
              end
            end
            # CRITICAL FIX: Also check ALL booted simulators (in case device name doesn't match exactly)
            booted_sims = `xcrun simctl list devices | grep "(Booted)" | head -5`.lines.map(&:chomp)
            if booted_sims.any?
              UI.message("   üîç Found #{booted_sims.count} booted simulator(s), checking their cache directories...")
              sim_data['devices'].each do |runtime, devices|
                devices.each do |sim|
                  if sim['state'] == 'Booted' && sim['dataPath']
                    possible_cache_dirs << File.join(sim['dataPath'], "Library/Caches/tools.fastlane/screenshots")
                    possible_cache_dirs << File.join(sim['dataPath'], "Library/Caches/tools.fastlane")
                    UI.message("   üîç Added booted simulator cache dir: #{File.join(sim['dataPath'], 'Library/Caches/tools.fastlane/screenshots')}")
                  end
                end
              end
            end
          end
        rescue => e
          UI.message("   ‚ö†Ô∏è  Could not extract simulator data path: #{e.message}")
        end
        
        # Research-based additional locations:
        # 1. Derived Data Attachments folder (xcodebuild may save screenshots here)
        if derived && Dir.exist?(derived)
          # Check for attachments in test logs
          possible_cache_dirs << File.join(derived, "Logs/Test/Attachments")
          # Check for screenshots in test output
          possible_cache_dirs << File.join(derived, "Logs/Test/screenshots")
        end
        
        # 2. Default Xcode Derived Data location
        default_derived_data = File.expand_path("~/Library/Developer/Xcode/DerivedData")
        if Dir.exist?(default_derived_data)
          # Search in all project folders (pattern: ProjectName-RandomString)
          Dir.glob(File.join(default_derived_data, "*/Logs/Test/Attachments")).each do |path|
            possible_cache_dirs << path
          end
        end
        
        # 3. Simulator media directory (screenshots might be saved here)
        simulator_media_base = File.expand_path("~/Library/Developer/CoreSimulator/Devices")
        if Dir.exist?(simulator_media_base)
          # Check all simulator devices for media/screenshots
          Dir.glob(File.join(simulator_media_base, "*/data/Media/DCIM")).each do |path|
            possible_cache_dirs << path
          end
        end
        
        # CRITICAL: Try to extract test output from xcresult bundle even when result_bundle: false
        # xcodebuild still creates an xcresult bundle even when result_bundle: false
        # This can contain NSLog() output that isn't in the main log file
        UI.message("   üîç DIAGNOSTICS: Checking xcresult bundle for test activity logs...")
        
        # Helper function to recursively extract test activities
        extract_test_activities = lambda do |test_node, depth = 0|
          activities_found = []
          
          # Check if this node has activities
          if test_node['activities'] && test_node['activities'].is_a?(Array)
            test_node['activities'].each do |activity|
              if activity['messages'] && activity['messages'].is_a?(Array)
                activity['messages'].each do |message|
                  if message['message'] && message['message']['values']
                    message_text = message['message']['values'].map { |v| v['text'] || v['value'] || '' }.join('')
                    activities_found << message_text
                  end
                end
              end
              # Also check subactivities recursively
              if activity['subactivities'] && activity['subactivities'].is_a?(Array)
                activity['subactivities'].each do |subactivity|
                  if subactivity['messages'] && subactivity['messages'].is_a?(Array)
                    subactivity['messages'].each do |message|
                      if message['message'] && message['message']['values']
                        message_text = message['message']['values'].map { |v| v['text'] || v['value'] || '' }.join('')
                        activities_found << message_text
                      end
                    end
                  end
                end
              end
            end
          end
          
          # Recursively check nested testNodes
          if test_node['testNodes'] && test_node['testNodes'].is_a?(Array)
            test_node['testNodes'].each do |nested_node|
              activities_found.concat(extract_test_activities.call(nested_node, depth + 1))
            end
          end
          
          activities_found
        end
        
        begin
          # Find the most recent xcresult bundle in derived data
          # CRITICAL: Ensure derived path is absolute
          derived_absolute = derived ? File.expand_path(derived) : nil
          UI.message("   üîç Derived data path: #{derived_absolute}")
          if derived_absolute && Dir.exist?(derived_absolute)
            test_logs_dir = File.join(derived_absolute, "Logs/Test")
            UI.message("   üîç Checking test logs directory: #{test_logs_dir}")
            if Dir.exist?(test_logs_dir)
              xcresult_bundles = Dir.glob(File.join(test_logs_dir, "*.xcresult")).sort_by { |f| File.mtime(f) }
              UI.message("   üîç Found #{xcresult_bundles.count} xcresult bundle(s)")
              if xcresult_bundles.any?
                latest_bundle = xcresult_bundles.last
                UI.message("   üîç Using most recent xcresult bundle: #{latest_bundle}")
                UI.message("   üîç Attempting to extract test activity logs from xcresult bundle...")
                
                # Try to extract test activity logs using xcresulttool
                begin
                  # Get test results summary
                  summary_output = `xcrun xcresulttool get test-results summary --path "#{latest_bundle}" --format json 2>&1`
                  if $?.success? && summary_output && !summary_output.empty?
                    require 'json'
                    summary_data = JSON.parse(summary_output)
                    UI.message("   ‚úÖ Successfully extracted test summary from xcresult bundle")
                    
                    # Log test summary details
                    if summary_data['testsRef'] || summary_data['testRefs']
                        UI.message("   üìä Test summary structure: #{summary_data.keys.join(', ')}")
                    end
                    if summary_data['testsCount']
                        UI.message("   üìä Total tests: #{summary_data['testsCount']}")
                    end
                    if summary_data['testsPassedCount']
                        UI.message("   üìä Tests passed: #{summary_data['testsPassedCount']}")
                    end
                    if summary_data['testsFailedCount']
                        UI.message("   üìä Tests failed: #{summary_data['testsFailedCount']}")
                    end
                    
                    # Try to get individual test details
                    tests_output = `xcrun xcresulttool get test-results tests --path "#{latest_bundle}" --format json 2>&1`
                    if $?.success? && tests_output && !tests_output.empty?
                      tests_data = JSON.parse(tests_output)
                      UI.message("   ‚úÖ Found test details in xcresult bundle")
                      
                      # Look for NSLog/print output in test activities
                      # CRITICAL: The JSON structure uses 'testNodes' not 'tests', and may be nested
                      test_nodes = tests_data['testNodes'] || tests_data['tests'] || []
                      if test_nodes.is_a?(Array) && test_nodes.any?
                        UI.message("   üìã Processing #{test_nodes.count} test node(s)...")
                        all_activities = []
                        
                        # Helper to recursively log test node structure
                        log_test_node_structure = lambda do |node, indent = "  "|
                          node_name = node['identifier'] || node['name'] || node['testCaseName'] || "Unknown"
                          node_type = node['testStatus'] || node['type'] || "unknown"
                          UI.message("#{indent}üìã #{node_name} (#{node_type})")
                          
                          # Log nested testNodes
                          if node['testNodes'] && node['testNodes'].is_a?(Array) && node['testNodes'].any?
                            UI.message("#{indent}  ‚îî‚îÄ Found #{node['testNodes'].count} nested test node(s)")
                            node['testNodes'].each do |nested|
                              log_test_node_structure.call(nested, indent + "  ")
                            end
                          end
                          
                          # Log activities count
                          if node['activities'] && node['activities'].is_a?(Array)
                            UI.message("#{indent}  ‚îî‚îÄ Found #{node['activities'].count} activit(ies)")
                          end
                        end
                        
                        test_nodes.each do |test_node|
                          log_test_node_structure.call(test_node)
                          test_name = test_node['identifier'] || test_node['name'] || test_node['testCaseName'] || "Unknown"
                          activities = extract_test_activities.call(test_node)
                          all_activities.concat(activities)
                          if activities.any?
                            UI.message("     ‚úÖ Found #{activities.count} log message(s) in this test")
                          end
                        end
                        
                        # Look for diagnostic messages
                        diagnostic_messages = all_activities.select { |msg| 
                          msg.include?('üîß') || msg.include?('üöÄ') || msg.include?('üì∏') || 
                          msg.include?('setUpWithError') || msg.include?('launchAppForScreenshot') || 
                          msg.include?('setupSnapshot') || msg.include?('snapshot:')
                        }
                        
                        if diagnostic_messages.any?
                          UI.message("   ‚úÖ Found #{diagnostic_messages.count} diagnostic message(s):")
                          diagnostic_messages.first(10).each do |msg|
                            UI.message("     üìù #{msg[0..200]}")
                          end
                        else
                          UI.message("   ‚ö†Ô∏è  No diagnostic messages found in test activities")
                          if all_activities.any?
                            UI.message("   üìù Sample messages found (first 5):")
                            all_activities.first(5).each { |msg| UI.message("     #{msg[0..150]}") }
                          end
                        end
                      else
                        UI.message("   ‚ö†Ô∏è  No test nodes found in test details")
                        UI.message("   üìã Available keys: #{tests_data.keys.join(', ')}")
                      end
                    else
                      UI.message("   ‚ö†Ô∏è  Could not get test details (exit code: #{$?.exitstatus})")
                      UI.message("   ‚ö†Ô∏è  Output: #{tests_output[0..500] if tests_output}")
                    end
                  else
                    UI.message("   ‚ö†Ô∏è  Could not get test summary (exit code: #{$?.exitstatus})")
                    UI.message("   ‚ö†Ô∏è  Output: #{summary_output[0..500] if summary_output}")
                  end
                rescue => e
                  UI.message("   ‚ö†Ô∏è  Could not extract test logs from xcresult bundle: #{e.message}")
                  UI.message("   ‚ö†Ô∏è  Backtrace: #{e.backtrace.first(3).join(', ')}")
                end
              else
                UI.message("   ‚ö†Ô∏è  No xcresult bundles found in test logs directory")
              end
            else
              UI.message("   ‚ö†Ô∏è  Test logs directory does not exist: #{test_logs_dir}")
            end
          else
            UI.message("   ‚ö†Ô∏è  Derived data directory does not exist: #{derived_absolute}")
            # Try to find xcresult bundles in common locations as fallback
            UI.message("   üîç Trying fallback locations for xcresult bundles...")
            fallback_paths = [
              File.expand_path("./fastlane/derivedDataSnapshot/Logs/Test"),
              File.expand_path("~/Library/Developer/Xcode/DerivedData"),
              File.join(Dir.pwd, "fastlane/derivedDataSnapshot/Logs/Test")
            ]
            fallback_paths.each do |fallback_path|
              if Dir.exist?(fallback_path)
                UI.message("   üîç Checking fallback path: #{fallback_path}")
                xcresult_bundles = Dir.glob(File.join(fallback_path, "**", "*.xcresult")).sort_by { |f| File.mtime(f) }
                if xcresult_bundles.any?
                  UI.message("   ‚úÖ Found #{xcresult_bundles.count} xcresult bundle(s) in fallback location")
                  latest_bundle = xcresult_bundles.last
                  UI.message("   üîç Using fallback xcresult bundle: #{latest_bundle}")
                  # Try to extract from this bundle (same extraction code as above)
                  begin
                    summary_output = `xcrun xcresulttool get test-results summary --path "#{latest_bundle}" --format json 2>&1`
                    if $?.success? && summary_output && !summary_output.empty?
                      require 'json'
                      summary_data = JSON.parse(summary_output)
                      UI.message("   ‚úÖ Successfully extracted test summary from fallback xcresult bundle")
                      # Continue with extraction...
                    end
                  rescue => e
                    UI.message("   ‚ö†Ô∏è  Could not extract from fallback bundle: #{e.message}")
                  end
                  break
                end
              end
            end
          end
        rescue => e
          UI.message("   ‚ö†Ô∏è  Could not check xcresult bundle for test logs: #{e.message}")
          UI.message("   ‚ö†Ô∏è  Backtrace: #{e.backtrace.first(3).join(', ')}")
        end
        
        # Method 2a: Check for SnapshotHelper debug log file and marker files
        # SnapshotHelper writes a debug log file and marker files to verify snapshot() calls
        # CRITICAL: Check ALL possible cache directories, including simulator-specific ones
        possible_cache_dirs_for_log = []
        if ENV['SIMULATOR_HOST_HOME']
          possible_cache_dirs_for_log << File.join(ENV['SIMULATOR_HOST_HOME'], "Library/Caches/tools.fastlane")
        end
        if ENV['HOME']
          possible_cache_dirs_for_log << File.join(ENV['HOME'], "Library/Caches/tools.fastlane")
        end
        possible_cache_dirs_for_log << File.join(Dir.home, "Library/Caches/tools.fastlane")
        
        # Also check /tmp for marker files (fallback location)
        possible_cache_dirs_for_log << "/tmp"
        
        # Also check simulator-specific cache directories (extract base from possible_cache_dirs)
        possible_cache_dirs.each do |cache_dir|
          # Extract base cache directory (parent of "screenshots")
          if cache_dir.include?("screenshots")
            base_cache = File.dirname(cache_dir)
            possible_cache_dirs_for_log << base_cache if base_cache
          end
        end
        
        # CRITICAL: Also check simulator's actual data directory for debug log
        # SnapshotHelper may write to /tmp or simulator's document directory as fallback
        possible_cache_dirs_for_log << "/tmp"
        
       # CRITICAL: Check for setupSnapshot verification marker and failure markers
       # These are written to cache directory (primary) and /tmp (fallback) by the test code
       # CRITICAL FIX: Check cache directory first, as /tmp may be process-specific in CI
       cache_dir_to_check = File.join(simulator_host_home, "Library/Caches/tools.fastlane")
       setup_verification_marker_cache = File.join(cache_dir_to_check, "setupSnapshot_verification.txt")
       setup_failed_marker_cache = File.join(cache_dir_to_check, "snapshot_setup_failed.txt")
       setup_verification_marker_tmp = "/tmp/setupSnapshot_verification.txt"
       setup_failed_marker_tmp = "/tmp/snapshot_setup_failed.txt"
       
       # CRITICAL: Check for execution flow markers to see exactly where tests stop
       # Also check simulator-specific cache directories since tests run in simulator
       simulator_cache_dirs = []
       # Check all simulator devices (we don't know the exact simulator ID, so check all)
       simulator_devices_dir = File.join(ENV['HOME'] || Dir.home, "Library/Developer/CoreSimulator/Devices")
       if Dir.exist?(simulator_devices_dir)
         Dir.glob(File.join(simulator_devices_dir, "*/data/Library/Caches/tools.fastlane")).each do |sim_cache|
           simulator_cache_dirs << sim_cache
         end
       end
       
       # CRITICAL: Also check the booted simulator's cache directory specifically
       # This is the most likely location where marker files will be created
       begin
         simulator_info = `xcrun simctl list devices --json 2>&1`
         if $?.success?
           require 'json'
           sim_data = JSON.parse(simulator_info)
           sim_data['devices'].each do |runtime, devices|
             devices.each do |sim|
               if sim['name'] == device && sim['state'] == 'Booted' && sim['dataPath']
                 booted_sim_cache = File.join(sim['dataPath'], "Library/Caches/tools.fastlane")
                 simulator_cache_dirs.unshift(booted_sim_cache) unless simulator_cache_dirs.include?(booted_sim_cache)
                 UI.message("   üîç Added booted simulator cache dir (priority): #{booted_sim_cache}")
                 break
               end
             end
           end
         end
       rescue => e
         UI.message("   ‚ö†Ô∏è  Could not find booted simulator for cache check: #{e.message}")
       end
       
       # Check cache directory first (more reliable in CI)
       # Also check simulator-specific cache directories
       setup_failed_marker = setup_failed_marker_cache
       setup_verification_marker = setup_verification_marker_cache
       
       if !File.exist?(setup_failed_marker_cache) && !File.exist?(setup_verification_marker_cache)
         # Check simulator cache directories
         simulator_cache_dirs.each do |sim_cache|
           sim_failed = File.join(sim_cache, "snapshot_setup_failed.txt")
           sim_verification = File.join(sim_cache, "setupSnapshot_verification.txt")
           if File.exist?(sim_failed)
             setup_failed_marker = sim_failed
             UI.message("   ‚úÖ Found setup failed marker in simulator cache: #{sim_cache}")
           end
           if File.exist?(sim_verification)
             setup_verification_marker = sim_verification
             UI.message("   ‚úÖ Found setup verification marker in simulator cache: #{sim_cache}")
           end
         end
       end
       
       # Fallback to /tmp if not found in cache directories
       setup_failed_marker = setup_failed_marker_tmp if !File.exist?(setup_failed_marker) && File.exist?(setup_failed_marker_tmp)
       setup_verification_marker = setup_verification_marker_tmp if !File.exist?(setup_verification_marker) && File.exist?(setup_verification_marker_tmp)
       
       pre_setup_marker = File.join(cache_dir_to_check, "pre_setupSnapshot_marker.txt")
       post_setup_marker = File.join(cache_dir_to_check, "post_setupSnapshot_marker.txt")
       pre_snapshot_markers = Dir.glob(File.join(cache_dir_to_check, "pre_snapshot_*.txt"))
       post_snapshot_markers = Dir.glob(File.join(cache_dir_to_check, "post_snapshot_*.txt"))
       
       # Also check simulator cache directories
       simulator_cache_dirs.each do |sim_cache|
         pre_setup_marker_sim = File.join(sim_cache, "pre_setupSnapshot_marker.txt")
         post_setup_marker_sim = File.join(sim_cache, "post_setupSnapshot_marker.txt")
         pre_snapshot_markers_sim = Dir.glob(File.join(sim_cache, "pre_snapshot_*.txt"))
         post_snapshot_markers_sim = Dir.glob(File.join(sim_cache, "post_snapshot_*.txt"))
         
         if File.exist?(pre_setup_marker_sim)
           pre_setup_marker = pre_setup_marker_sim
           UI.message("   ‚úÖ Found pre_setupSnapshot_marker.txt in simulator cache: #{sim_cache}")
         end
         if File.exist?(post_setup_marker_sim)
           post_setup_marker = post_setup_marker_sim
           UI.message("   ‚úÖ Found post_setupSnapshot_marker.txt in simulator cache: #{sim_cache}")
         end
         pre_snapshot_markers.concat(pre_snapshot_markers_sim) if pre_snapshot_markers_sim.any?
         post_snapshot_markers.concat(post_snapshot_markers_sim) if post_snapshot_markers_sim.any?
       end
        
        UI.message("   üîç Execution flow markers:")
        if File.exist?(pre_setup_marker)
          UI.message("     ‚úÖ pre_setupSnapshot_marker.txt found - test code IS executing")
          UI.message("       Content: #{File.read(pre_setup_marker).chomp}")
        else
          UI.message("     ‚ùå pre_setupSnapshot_marker.txt NOT found - test code may not be executing")
        end
        
        if File.exist?(post_setup_marker)
          UI.message("     ‚úÖ post_setupSnapshot_marker.txt found - setupSnapshot() completed")
          UI.message("       Content: #{File.read(post_setup_marker).chomp}")
        else
          UI.message("     ‚ùå post_setupSnapshot_marker.txt NOT found - setupSnapshot() may not have completed")
        end
        
        if pre_snapshot_markers.any?
          UI.message("     ‚úÖ Found #{pre_snapshot_markers.count} pre_snapshot marker(s) - snapshot() calls are being reached")
          pre_snapshot_markers.each do |marker|
            UI.message("       #{File.basename(marker)}: #{File.read(marker).chomp}")
          end
        else
          UI.message("     ‚ùå No pre_snapshot markers found - snapshot() calls may not be reached")
        end
        
        if post_snapshot_markers.any?
          UI.message("     ‚úÖ Found #{post_snapshot_markers.count} post_snapshot marker(s) - snapshot() calls completed")
          post_snapshot_markers.each do |marker|
            UI.message("       #{File.basename(marker)}: #{File.read(marker).chomp}")
          end
        else
          UI.message("     ‚ùå No post_snapshot markers found - snapshot() calls may not be completing")
        end
        
        if File.exist?(setup_failed_marker)
          UI.error("   ‚ùå CRITICAL: Found setupSnapshot() failure marker!")
          UI.error("   Location: #{setup_failed_marker}")
          UI.error("   This means snapshot() was called but setupSnapshot() failed or wasn't called")
          failure_content = File.read(setup_failed_marker)
          UI.error("   Failure details: #{failure_content.chomp}")
        elsif File.exist?(setup_verification_marker)
          UI.message("   ‚úÖ Found setupSnapshot() verification marker")
          UI.message("   Location: #{setup_verification_marker}")
          verification_content = File.read(setup_verification_marker)
          UI.message("   Verification details:")
          verification_content.lines.each { |line| UI.message("     #{line.chomp}") }
        else
          UI.message("   ‚ö†Ô∏è  setupSnapshot() verification marker not found")
          UI.message("   Checked cache: #{setup_verification_marker_cache}")
          UI.message("   Checked /tmp: #{setup_verification_marker_tmp}")
        end
        begin
          simulator_info = `xcrun simctl list devices --json 2>&1`
          if $?.success?
            require 'json'
            sim_data = JSON.parse(simulator_info)
            device_name = device.gsub(" ", "").gsub("-", "")
            sim_data['devices'].each do |runtime, devices|
              devices.each do |sim|
                if sim['name'] == device || sim['name'].include?(device_name)
                  if sim['dataPath']
                    # Check simulator's data directory for cache
                    possible_cache_dirs_for_log << File.join(sim['dataPath'], "Library/Caches/tools.fastlane")
                    # Check simulator's document directory (fallback location)
                    possible_cache_dirs_for_log << File.join(sim['dataPath'], "Library/Application Support")
                  end
                end
              end
            end
          end
        rescue => e
          UI.message("   ‚ö†Ô∏è  Could not check simulator data paths for debug log: #{e.message}")
        end
        
        debug_log_found = false
        debug_log_path_found = nil
        marker_files_found = []
        
        possible_cache_dirs_for_log.uniq.each do |cache_base|
          # Check for debug log
          debug_log_path = File.join(cache_base, "snapshot_debug.log")
          if File.exist?(debug_log_path)
            debug_log_found = true
            debug_log_path_found = debug_log_path
            UI.message("   ‚úÖ Found SnapshotHelper debug log: #{debug_log_path}")
            debug_content = File.read(debug_log_path)
            snapshot_calls = debug_content.lines.select { |l| l.include?("snapshot:") }
            if snapshot_calls.any?
              UI.message("   ‚úÖ Debug log shows #{snapshot_calls.count} snapshot() calls were made")
              UI.message("   Last snapshot calls:")
              snapshot_calls.last(10).each { |line| UI.message("     #{line.chomp}") }
            else
              UI.message("   ‚ö†Ô∏è  Debug log exists but no snapshot() calls found")
            end
            UI.message("   Debug log content (last 20 lines):")
            debug_content.lines.last(20).each { |line| UI.message("     #{line.chomp}") }
          end
          
          # CRITICAL: Check for marker files (more reliable than log parsing)
          # Marker files are created immediately when snapshot() is called
          marker_pattern = File.join(cache_base, "snapshot_marker_*.txt")
          marker_files = Dir.glob(marker_pattern)
          if marker_files.any?
            marker_files_found += marker_files
            UI.message("   ‚úÖ Found #{marker_files.count} snapshot marker file(s) in #{cache_base}")
            marker_files.each do |marker_file|
              marker_content = File.read(marker_file)
              UI.message("     üìå #{File.basename(marker_file)}: #{marker_content.chomp}")
            end
          end
        end
        
        unless debug_log_found && marker_files_found.any?
          if !debug_log_found && marker_files_found.empty?
            UI.message("   ‚ö†Ô∏è  SnapshotHelper debug log and marker files not found - snapshot() may not be called")
          elsif marker_files_found.any?
            UI.message("   ‚úÖ Marker files found - snapshot() IS being called (even if log not found)")
          end
        end
        
        # Method 2b: Extract test activity logs from result bundle to check for NSLog output
        # CRITICAL DIAGNOSTICS: This helps verify if snapshot() is actually being called
        if result_bundle_to_check && File.exist?(result_bundle_to_check)
          begin
            UI.message("   üîç DIAGNOSTICS: Extracting test activity logs from result bundle...")
            UI.message("   Result bundle path: #{result_bundle_to_check}")
            
            # STRATEGY: Try modern API first (simpler, direct path to test data)
            # If that fails, fall back to legacy API navigation
            modern_api_success = false
            
            # Try modern API: xcresulttool get test-results
            UI.message("   üîç Trying modern API: get test-results...")
            modern_output = `xcrun xcresulttool get test-results summary --path "#{result_bundle_to_check}" --format json 2>&1`
            if $?.success? && modern_output && !modern_output.empty?
              begin
                require 'json'
                modern_data = JSON.parse(modern_output)
                UI.message("   ‚úÖ Modern API succeeded!")
                UI.message("   üìã Modern API keys: #{modern_data.keys.join(', ')}")
                
                # Modern API summary structure has: testFailures, passedTests, failedTests, totalTestCount, etc.
                # This is a summary, not individual test nodes. We need to use a different subcommand for individual tests.
                if modern_data['totalTestCount'] || modern_data['testFailures'] || modern_data['passedTests']
                  modern_api_success = true
                  UI.message("   ‚úÖ Found test summary data in modern API format")
                  
                  total_tests = modern_data['totalTestCount'] || 0
                  passed = modern_data['passedTests'] || 0
                  failed = modern_data['failedTests'] || 0
                  skipped = modern_data['skippedTests'] || 0
                  
                  UI.message("   üìä Test Summary:")
                  UI.message("      Total tests: #{total_tests}")
                  UI.message("      Passed: #{passed}")
                  UI.message("      Failed: #{failed}")
                  UI.message("      Skipped: #{skipped}")
                  
                  # Check for test failures - these might have more details
                  if modern_data['testFailures'] && modern_data['testFailures'].is_a?(Array)
                    UI.message("   üìã Found #{modern_data['testFailures'].count} test failure(s)")
                    modern_data['testFailures'].each_with_index do |failure, idx|
                      UI.message("      Failure #{idx + 1}: #{failure['testCaseName'] || failure['testName'] || 'Unknown'}")
                    end
                  end
                  
                  # Try to get individual test details using a different subcommand
                  UI.message("   üîç Attempting to get individual test details...")
                  tests_output = `xcrun xcresulttool get test-results tests --path "#{result_bundle_to_check}" --format json 2>&1`
                  if $?.success? && tests_output && !tests_output.empty?
                    begin
                      tests_data = JSON.parse(tests_output)
                      UI.message("   ‚úÖ Got individual test details!")
                      UI.message("   üìã Test details keys: #{tests_data.keys.join(', ')}")
                      
                      # Look for test nodes or test list
                      if tests_data['testNodes'] || tests_data['tests']
                        test_nodes = tests_data['testNodes'] || tests_data['tests'] || []
                        if test_nodes.is_a?(Array)
                          UI.message("   üìã Found #{test_nodes.count} individual test(s)")
                          test_nodes.each_with_index do |test_node, idx|
                            test_name = test_node['name'] || test_node['identifier'] || test_node['testCaseName'] || 'Unknown'
                            test_status = test_node['testStatus'] || test_node['status'] || 'Unknown'
                            UI.message("      Test #{idx + 1}: #{test_name} - #{test_status}")
                            
                            # Log all test node keys for debugging
                            UI.message("         Test node keys: #{test_node.keys.join(', ')}")
                            
                            # Check for activities (which contain logs and attachments)
                            if test_node['activities'] && test_node['activities'].is_a?(Array)
                              UI.message("         Has #{test_node['activities'].count} activity(ies)")
                              test_node['activities'].each_with_index do |activity, act_idx|
                                if activity.is_a?(Hash)
                                  UI.message("         Activity #{act_idx + 1} keys: #{activity.keys.join(', ')}")
                                  
                                  # Check for attachments (screenshots)
                                  if activity['attachments'] && activity['attachments'].is_a?(Array)
                                    UI.message("         Found #{activity['attachments'].count} attachment(s) in activity #{act_idx + 1}")
                                    activity['attachments'].each do |attachment|
                                      if attachment.is_a?(Hash)
                                        filename = attachment['filename'] || attachment['name'] || 'Unknown'
                                        UI.message("           Attachment: #{filename}")
                                        if attachment['payloadRef']
                                          UI.message("             Payload ref: #{attachment['payloadRef']}")
                                        end
                                      end
                                    end
                                  end
                                  
                                  # Check for messages (logs)
                                  if activity['messages'] && activity['messages'].is_a?(Array)
                                    UI.message("         Found #{activity['messages'].count} message(s) in activity #{act_idx + 1}")
                                    activity['messages'].each_with_index do |message, msg_idx|
                                      if message.is_a?(Hash)
                                        msg_text = message['message'] || message['text'] || message.to_s
                                        UI.message("           Message #{msg_idx + 1}: #{msg_text[0..100]}")
                                      end
                                    end
                                  end
                                  
                                  # Check for sub-activities (nested)
                                  if activity['subActivities'] && activity['subActivities'].is_a?(Array)
                                    UI.message("         Found #{activity['subActivities'].count} sub-activit(ies) in activity #{act_idx + 1}")
                                    activity['subActivities'].each_with_index do |sub_activity, sub_idx|
                                      if sub_activity.is_a?(Hash) && sub_activity['attachments'] && sub_activity['attachments'].is_a?(Array)
                                        UI.message("           Sub-activity #{sub_idx + 1} has #{sub_activity['attachments'].count} attachment(s)")
                                      end
                                    end
                                  end
                                end
                              end
                            else
                              UI.message("         No activities found in test node")
                              # Try alternative paths - maybe activities are nested differently
                              # Check 'result' field (not 'testResult')
                              if test_node['result']
                                UI.message("         Result field exists: #{test_node['result'].class}")
                                if test_node['result'].is_a?(Hash)
                                  UI.message("         Found result object (Hash)")
                                  UI.message("         Result object keys: #{test_node['result'].keys.join(', ')}")
                                elsif test_node['result'].is_a?(String)
                                  UI.message("         Result is a string/reference: #{test_node['result'][0..100]}")
                                else
                                  UI.message("         Result type: #{test_node['result'].class}, value: #{test_node['result'].inspect[0..200]}")
                                end
                              else
                                UI.message("         Result field does not exist in test node")
                              end
                              
                              if test_node['result'] && test_node['result'].is_a?(Hash)
                                if test_node['result']['activities'] && test_node['result']['activities'].is_a?(Array)
                                  UI.message("         Found activities in result: #{test_node['result']['activities'].count}")
                                  # Extract activities from result
                                  test_node['result']['activities'].each_with_index do |activity, act_idx|
                                    if activity.is_a?(Hash)
                                      UI.message("         Result Activity #{act_idx + 1} keys: #{activity.keys.join(', ')}")
                                      if activity['attachments'] && activity['attachments'].is_a?(Array)
                                        UI.message("         Found #{activity['attachments'].count} attachment(s) in result activity #{act_idx + 1}")
                                        activity['attachments'].each do |attachment|
                                          if attachment.is_a?(Hash)
                                            filename = attachment['filename'] || attachment['name'] || 'Unknown'
                                            UI.message("           Attachment: #{filename}")
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                                # Also check for sub-activities or nested structures
                                if test_node['result']['subActivities'] && test_node['result']['subActivities'].is_a?(Array)
                                  UI.message("         Found subActivities in result: #{test_node['result']['subActivities'].count}")
                                end
                              end
                              # Also check 'testResult' for compatibility
                              if test_node['testResult'] && test_node['testResult'].is_a?(Hash)
                                UI.message("         Found testResult object")
                                if test_node['testResult']['activities'] && test_node['testResult']['activities'].is_a?(Array)
                                  UI.message("         Found activities in testResult: #{test_node['testResult']['activities'].count}")
                                end
                              end
                            end
                          end
                        end
                      end
                    rescue JSON::ParserError => e
                      UI.message("   ‚ö†Ô∏è  Failed to parse test details JSON: #{e.message}")
                    end
                  else
                    UI.message("   ‚ö†Ô∏è  Could not get individual test details: #{tests_output[0..200]}")
                  end
                end
              rescue JSON::ParserError => e
                UI.message("   ‚ö†Ô∏è  Modern API returned invalid JSON: #{e.message}")
              end
            else
              UI.message("   ‚ö†Ô∏è  Modern API failed or returned empty: #{modern_output[0..200]}")
            end
            
            # Fall back to legacy API if modern API didn't work
            root_output = nil
            unless modern_api_success
              UI.message("   üîç Falling back to legacy API navigation...")
              
              # CRITICAL: Use xcresulttool to get test activity logs which contain NSLog/print output
              # First, get the root object to find test actions
              # NOTE: Using deprecated `get object --legacy` API because:
              # 1. Modern API (`get test-results`) requires different code structure
              # 2. Deprecated API still works and gives us full JSON structure we need
              # 3. Apple requires --legacy flag for deprecated APIs
              root_output = `xcrun xcresulttool get object --legacy --format json --path "#{result_bundle_to_check}" 2>&1`
              if !$?.success?
                # Fallback: Try without --legacy (will likely fail, but worth trying)
                UI.message("   ‚ö†Ô∏è  Legacy API failed (exit code: #{$?.exitstatus}), trying without --legacy flag...")
                root_output = `xcrun xcresulttool get object --format json --path "#{result_bundle_to_check}" 2>&1`
                if !$?.success?
                  UI.message("   ‚ö†Ô∏è  Non-legacy API also failed (exit code: #{$?.exitstatus})")
                  UI.message("   Error output: #{root_output[0..500]}")
                end
              end
            end
            
            if root_output && !root_output.empty? && ($?.nil? || $?.success?)
              UI.message("   ‚úÖ Successfully retrieved root object from result bundle")
              UI.message("   üìÑ Root output length: #{root_output.length} characters")
              require 'json'
              begin
                root_data = JSON.parse(root_output)
                UI.message("   ‚úÖ Successfully parsed root object JSON")
                
                # CRITICAL DIAGNOSTICS: Show actual structure of root object
                UI.message("   üîç Root object keys: #{root_data.keys.join(', ')}")
                UI.message("   üîç Root object type: #{root_data.class}")
                
                # Try different possible structures
                # Structure 1: root -> actions -> actionResult -> testsRef
                # Structure 2: root -> _type -> ActionsInvocationRecord (might need different navigation)
                # Structure 3: Modern API structure (different keys)
                
                # Check if it's an ActionsInvocationRecord type
                if root_data['_type'] && root_data['_type']['_name'] == 'ActionsInvocationRecord'
                  UI.message("   üìã Root object is ActionsInvocationRecord")
                  # ActionsInvocationRecord has 'actions' which can be a Hash with _values or an Array
                  if root_data['actions']
                    if root_data['actions'].is_a?(Hash) && root_data['actions']['_values']
                      UI.message("   ‚úÖ Found actions Hash with _values array")
                      actions_array = root_data['actions']['_values']
                    elsif root_data['actions'].is_a?(Array)
                      UI.message("   ‚úÖ Found actions array directly")
                      actions_array = root_data['actions']
                    else
                      UI.message("   ‚ö†Ô∏è  ActionsInvocationRecord has actions but structure is unexpected")
                      UI.message("   üîç Actions type: #{root_data['actions'].class}")
                      if root_data['actions'].is_a?(Hash)
                        UI.message("   üîç Actions keys: #{root_data['actions'].keys.join(', ')}")
                      end
                      actions_array = nil
                    end
                  else
                    UI.message("   ‚ö†Ô∏è  ActionsInvocationRecord has no actions")
                    UI.message("   üîç Available keys in root: #{root_data.keys.join(', ')}")
                    actions_array = nil
                  end
                else
                  actions_array = nil
                end
                
                # Navigate the JSON to find test actions and their activity logs
                # The structure is: root -> actions -> _values (array) -> actionResult -> testsRef -> tests -> test -> activities
                # OR: root -> actions (array) -> actionResult -> testsRef -> tests -> test -> activities
                if actions_array && actions_array.is_a?(Array)
                  UI.message("   üìã Found #{actions_array.count} action(s) in result bundle")
                  actions_array.each_with_index do |action, action_idx|
                    UI.message("   üîç Processing action #{action_idx + 1}...")
                    if action['actionResult'] && action['actionResult']['testsRef']
                      tests_ref_id = action['actionResult']['testsRef']['id']
                      
                      # Extract actual ID string - can be a Hash with _value or a direct string
                      tests_id = if tests_ref_id.is_a?(Hash) && tests_ref_id['_value']
                        tests_ref_id['_value']
                      elsif tests_ref_id.is_a?(String)
                        tests_ref_id
                      else
                        UI.message("   ‚ö†Ô∏è  Unexpected testsRef ID structure: #{tests_ref_id.class}")
                        tests_ref_id.to_s
                      end
                      
                      UI.message("   ‚úÖ Found testsRef with ID: #{tests_id}")
                      
                      # Get the tests object - using deprecated API with --legacy flag
                      # See comment above for why we use legacy API
                      tests_output = `xcrun xcresulttool get object --legacy --format json --path "#{result_bundle_to_check}" --id "#{tests_id}" 2>&1`
                      if !$?.success?
                        tests_output = `xcrun xcresulttool get object --format json --path "#{result_bundle_to_check}" --id "#{tests_id}" 2>&1`
                      end
                      if tests_output && !tests_output.empty? && ($?.nil? || $?.success?)
                        tests_data = JSON.parse(tests_output)
                        UI.message("   ‚úÖ Successfully parsed tests object")
                        
                        # CRITICAL DIAGNOSTICS: Show actual structure of tests object
                        UI.message("   üîç Tests object keys: #{tests_data.keys.join(', ')}")
                        UI.message("   üîç Tests object type: #{tests_data.class}")
                        
                        # Check different possible structures
                        # Structure 1: tests -> summaries -> testRefs
                        # Structure 2: tests -> _values (array) -> testRefs
                        # Structure 3: tests -> tests (array) -> test objects
                        
                        test_refs_array = nil
                        
                        # Try Structure 1: summaries Hash with _values (like actions)
                        if tests_data['summaries'] && tests_data['summaries'].is_a?(Hash) && tests_data['summaries']['_values']
                          UI.message("   ‚úÖ Found summaries Hash with _values array")
                          summaries_array = tests_data['summaries']['_values']
                          UI.message("   üìã Found #{summaries_array.count} summary(ies) in summaries array")
                          # Extract all testRefs from all summaries
                          test_refs_array = []
                          summaries_array.each_with_index do |summary, summary_idx|
                            UI.message("   üîç Processing summary #{summary_idx + 1}...")
                            
                            # CRITICAL DIAGNOSTICS: Show what's in each summary
                            if summary.is_a?(Hash)
                              UI.message("     üìã Summary keys: #{summary.keys.join(', ')}")
                              # Show sample structure
                              summary.keys.first(10).each do |key|
                                value = summary[key]
                                value_type = value.class
                                value_preview = if value.is_a?(String)
                                  value[0..50]
                                elsif value.is_a?(Array)
                                  "Array[#{value.count}]"
                                elsif value.is_a?(Hash)
                                  "Hash{#{value.keys.first(3).join(', ')}}"
                                else
                                  value.inspect[0..50]
                                end
                                UI.message("       - #{key}: #{value_type} = #{value_preview}")
                              end
                            end
                            
                            # Handle navigation through testableSummaries -> _values -> testableSummary -> testRefs
                            # Structure: summary -> testableSummaries (Hash) -> _values (Array) -> testableSummary -> testRefs
                            # ALTERNATIVE: Check if summary itself has testRefs (not just testableSummaries)
                            summary_test_refs = if summary.is_a?(Hash)
                              # Check for testRefs directly in summary first (simpler path)
                              if summary['testRefs']
                                UI.message("     ‚úÖ Found testRefs directly in summary (not in testableSummaries)!")
                                if summary['testRefs'].is_a?(Hash) && summary['testRefs']['_values']
                                  UI.message("     ‚úÖ testRefs is Hash with _values")
                                  summary['testRefs']['_values']
                                elsif summary['testRefs'].is_a?(Array)
                                  UI.message("     ‚úÖ testRefs is Array")
                                  summary['testRefs']
                                else
                                  nil
                                end
                              # Try Structure 1: testableSummaries -> _values -> testableSummary -> testRefs
                              elsif summary['testableSummaries'] && summary['testableSummaries'].is_a?(Hash) && summary['testableSummaries']['_values']
                                UI.message("     ‚úÖ Found testableSummaries Hash with _values")
                                testable_summaries_array = summary['testableSummaries']['_values']
                                UI.message("     üìã Found #{testable_summaries_array.count} testable summary(ies)")
                                # Extract testRefs from all testableSummaries
                                all_test_refs = []
                                testable_summaries_array.each_with_index do |testable_summary, ts_idx|
                                  UI.message("       üîç Processing testable summary #{ts_idx + 1}...")
                                  if testable_summary.is_a?(Hash)
                                    # CRITICAL DIAGNOSTICS: Show what's in the testable summary
                                    UI.message("         üìã Testable summary keys: #{testable_summary.keys.join(', ')}")
                                    testable_summary.keys.first(10).each do |key|
                                      value = testable_summary[key]
                                      value_type = value.class
                                      value_preview = if value.is_a?(String)
                                        value[0..50]
                                      elsif value.is_a?(Array)
                                        "Array[#{value.count}]"
                                      elsif value.is_a?(Hash)
                                        "Hash{#{value.keys.first(3).join(', ')}}"
                                      else
                                        value.inspect[0..50]
                                      end
                                      UI.message("           - #{key}: #{value_type} = #{value_preview}")
                                    end
                                    
                                    # Check for testRefs in testableSummary (various structures)
                                    if testable_summary['testRefs'] && testable_summary['testRefs'].is_a?(Hash) && testable_summary['testRefs']['_values']
                                      UI.message("         ‚úÖ Found testRefs Hash with _values in testable summary")
                                      all_test_refs.concat(testable_summary['testRefs']['_values'])
                                    elsif testable_summary['testRefs'] && testable_summary['testRefs'].is_a?(Array)
                                      UI.message("         ‚úÖ Found testRefs Array in testable summary")
                                      all_test_refs.concat(testable_summary['testRefs'])
                                    # Check for tests (alternative structure)
                                    elsif testable_summary['tests'] && testable_summary['tests'].is_a?(Hash) && testable_summary['tests']['_values']
                                      UI.message("         ‚úÖ Found tests Hash with _values in testable summary")
                                      all_test_refs.concat(testable_summary['tests']['_values'])
                                    elsif testable_summary['tests'] && testable_summary['tests'].is_a?(Array)
                                      UI.message("         ‚úÖ Found tests Array in testable summary")
                                      all_test_refs.concat(testable_summary['tests'])
                                    # Check for _values directly
                                    elsif testable_summary['_values'] && testable_summary['_values'].is_a?(Array)
                                      UI.message("         ‚úÖ Found _values array in testable summary")
                                      all_test_refs.concat(testable_summary['_values'])
                                    # ALTERNATIVE: Check if identifierURL can be used to get test data
                                    elsif testable_summary['identifierURL'] && testable_summary['identifierURL'].is_a?(Hash) && testable_summary['identifierURL']['_value']
                                      identifier_url = testable_summary['identifierURL']['_value']
                                      UI.message("         üîç Found identifierURL: #{identifier_url}")
                                      UI.message("         üí° identifierURL might point to test data, but requires different navigation")
                                    else
                                      UI.message("         ‚ö†Ô∏è  Testable summary has no testRefs, tests, or _values")
                                      UI.message("         üí° Testable summary appears to be metadata only - test refs may be at summary level")
                                    end
                                  end
                                end
                                all_test_refs.any? ? all_test_refs : nil
                              # Try Structure 2: testRefs directly in summary
                              elsif summary['testRefs'] && summary['testRefs'].is_a?(Hash) && summary['testRefs']['_values']
                                UI.message("     ‚úÖ Found testRefs Hash with _values")
                                summary['testRefs']['_values']
                              elsif summary['testRefs'] && summary['testRefs'].is_a?(Array)
                                UI.message("     ‚úÖ Found testRefs Array")
                                summary['testRefs']
                              elsif summary['_values'] && summary['_values'].is_a?(Array)
                                UI.message("     ‚úÖ Found _values array in summary")
                                summary['_values']
                              else
                                UI.message("     ‚ö†Ô∏è  Summary has no testableSummaries, testRefs, or _values")
                                nil
                              end
                            else
                              UI.message("     ‚ö†Ô∏è  Summary is not a Hash: #{summary.class}")
                              nil
                            end
                            if summary_test_refs && summary_test_refs.is_a?(Array)
                              UI.message("     üìã Found #{summary_test_refs.count} test reference(s) in summary")
                              test_refs_array.concat(summary_test_refs)
                            else
                              UI.message("     ‚ö†Ô∏è  No test references extracted from summary")
                            end
                          end
                          UI.message("   üìä Total test references extracted: #{test_refs_array.count}")
                        # Try Structure 1b: summaries array (direct)
                        elsif tests_data['summaries'] && tests_data['summaries'].is_a?(Array)
                          UI.message("   ‚úÖ Found summaries array")
                          # Extract all testRefs from all summaries (through testableSummaries if needed)
                          test_refs_array = []
                          tests_data['summaries'].each_with_index do |summary, summary_idx|
                            UI.message("   üîç Processing summary #{summary_idx + 1} from array...")
                            if summary.is_a?(Hash)
                              # Check for testableSummaries first
                              if summary['testableSummaries'] && summary['testableSummaries'].is_a?(Hash) && summary['testableSummaries']['_values']
                                testable_summaries_array = summary['testableSummaries']['_values']
                                testable_summaries_array.each do |testable_summary|
                                  if testable_summary.is_a?(Hash)
                                    if testable_summary['testRefs'] && testable_summary['testRefs'].is_a?(Hash) && testable_summary['testRefs']['_values']
                                      test_refs_array.concat(testable_summary['testRefs']['_values'])
                                    elsif testable_summary['testRefs'] && testable_summary['testRefs'].is_a?(Array)
                                      test_refs_array.concat(testable_summary['testRefs'])
                                    end
                                  end
                                end
                              # Fallback to direct testRefs
                              elsif summary['testRefs'] && summary['testRefs'].is_a?(Hash) && summary['testRefs']['_values']
                                test_refs_array.concat(summary['testRefs']['_values'])
                              elsif summary['testRefs'] && summary['testRefs'].is_a?(Array)
                                test_refs_array.concat(summary['testRefs'])
                              end
                            end
                          end
                          UI.message("   üìä Total test references extracted: #{test_refs_array.count}")
                        # Try Structure 2: _values array (like actions)
                        elsif tests_data['_values'] && tests_data['_values'].is_a?(Array)
                          UI.message("   ‚úÖ Found _values array")
                          test_refs_array = tests_data['_values']
                        # Try Structure 3: direct tests array
                        elsif tests_data['tests'] && tests_data['tests'].is_a?(Array)
                          UI.message("   ‚úÖ Found tests array")
                          test_refs_array = tests_data['tests']
                        # Try Structure 4: testRefs directly
                        elsif tests_data['testRefs'] && tests_data['testRefs'].is_a?(Array)
                          UI.message("   ‚úÖ Found testRefs array directly")
                          test_refs_array = tests_data['testRefs']
                        else
                          UI.message("   ‚ö†Ô∏è  Tests object has unexpected structure")
                          UI.message("   üîç Available keys: #{tests_data.keys.join(', ')}")
                          # Show sample structure
                          tests_data.keys.first(5).each do |key|
                            value = tests_data[key]
                            value_type = value.class
                            value_preview = if value.is_a?(String)
                              value[0..50]
                            elsif value.is_a?(Array)
                              "Array[#{value.count}]"
                            elsif value.is_a?(Hash)
                              "Hash{#{value.keys.first(3).join(', ')}}"
                            else
                              value.inspect[0..50]
                            end
                            UI.message("     - #{key}: #{value_type} = #{value_preview}")
                          end
                        end
                        
                        # Navigate to find test activities
                        if test_refs_array && test_refs_array.is_a?(Array) && test_refs_array.any?
                          UI.message("   üìã Found #{test_refs_array.count} test reference(s)")
                          test_refs_array.each_with_index do |test_ref, test_idx|
                            # Handle both testRef objects (with 'id' key) and direct test objects
                            test_ref_id = if test_ref.is_a?(Hash)
                              test_ref['id'] || test_ref['_value'] || test_ref['identifier']
                            else
                              test_ref
                            end
                            
                            if test_ref_id.nil?
                              UI.message("   ‚ö†Ô∏è  Test reference #{test_idx + 1} has no ID, skipping")
                              next
                            end
                                
                                # Extract actual ID string - can be a Hash with _value or a direct string
                                test_id = if test_ref_id.is_a?(Hash) && test_ref_id['_value']
                                  test_ref_id['_value']
                                elsif test_ref_id.is_a?(String)
                                  test_ref_id
                                else
                                  UI.message("   ‚ö†Ô∏è  Unexpected testRef ID structure: #{test_ref_id.class}")
                                  test_ref_id.to_s
                                end
                                
                                UI.message("   üîç Processing test #{test_idx + 1} (ID: #{test_id})...")
                                
                                # Get the test object - using deprecated API with --legacy flag
                                # See comment above for why we use legacy API
                                test_output = `xcrun xcresulttool get object --legacy --format json --path "#{result_bundle_to_check}" --id "#{test_id}" 2>&1`
                                if !$?.success?
                                  test_output = `xcrun xcresulttool get object --format json --path "#{result_bundle_to_check}" --id "#{test_id}" 2>&1`
                                end
                                if test_output && !test_output.empty? && ($?.nil? || $?.success?)
                                  test_data = JSON.parse(test_output)
                                  UI.message("   ‚úÖ Successfully parsed test object")
                                  
                                  # Get test name if available
                                  test_name = test_data['identifier'] || test_data['name'] || "Unknown"
                                  UI.message("   üìù Test name: #{test_name}")
                                  
                                  # CRITICAL: Check if test failed
                                  if test_data['testStatus'] && test_data['testStatus'] != 'Success'
                                    UI.error("   ‚ùå Test status: #{test_data['testStatus']}")
                                    if test_data['failureSummaries'] && test_data['failureSummaries'].is_a?(Array)
                                      test_data['failureSummaries'].each do |failure|
                                        if failure['message']
                                          UI.error("   ‚ùå Test failure: #{failure['message']['values'].map { |v| v['text'] || v['value'] || '' }.join('')}")
                                        end
                                      end
                                    end
                                  else
                                    UI.message("   ‚úÖ Test status: Success")
                                  end
                                  
                                  # Check for activities with attachments or subactivities
                                  if test_data['activities'] && test_data['activities'].is_a?(Array)
                                    UI.message("   üîç Found #{test_data['activities'].count} activities for test")
                                    total_messages = 0
                                    total_attachments = 0
                                    test_data['activities'].each_with_index do |activity, activity_idx|
                                      # CRITICAL: Extract and display activity logs to see what's happening
                                      if activity['title']
                                        UI.message("   üìã Activity #{activity_idx + 1}: #{activity['title']}")
                                      end
                                      
                                      # Check for log messages in the activity (NSLog/print output)
                                      # CRITICAL DIAGNOSTICS: Extract ALL log messages to verify test execution
                                      if activity['messages'] && activity['messages'].is_a?(Array)
                                        message_count = activity['messages'].count
                                        total_messages += message_count
                                        UI.message("   üìù Found #{message_count} log message(s) in activity")
                                        snapshot_related_messages = []
                                        debug_messages = []
                                        all_messages = []
                                        
                                        activity['messages'].each do |message|
                                          if message['message'] && message['message']['values']
                                            message_text = message['message']['values'].map { |v| v['text'] || v['value'] || '' }.join('')
                                            all_messages << message_text
                                            
                                            # Categorize messages
                                            if message_text.include?('snapshot:') || message_text.include?('Snapshot.snapshot')
                                              snapshot_related_messages << message_text
                                            elsif message_text.include?('DEBUG') || message_text.include?('setupSnapshot')
                                              debug_messages << message_text
                                            end
                                          end
                                        end
                                        
                                        # Report findings
                                        if snapshot_related_messages.any?
                                          UI.message("   ‚úÖ Found #{snapshot_related_messages.count} snapshot-related messages:")
                                          snapshot_related_messages.each { |msg| UI.message("     üì∏ #{msg[0..150]}") }
                                        end
                                        
                                        if debug_messages.any?
                                          UI.message("   üîç Found #{debug_messages.count} debug messages:")
                                          debug_messages.first(5).each { |msg| UI.message("     üîß #{msg[0..150]}") }
                                        end
                                        
                                        # Show sample of all messages if no snapshot messages found
                                        if snapshot_related_messages.empty? && all_messages.any?
                                          UI.message("   ‚ö†Ô∏è  No snapshot-related messages found. Sample of messages:")
                                          all_messages.first(10).each { |msg| UI.message("     üìã #{msg[0..100]}") }
                                        end
                                      end
                                      
                                      # Check for attachments (screenshots)
                                      if activity['attachments'] && activity['attachments'].is_a?(Array)
                                        attachment_count = activity['attachments'].count
                                        total_attachments += attachment_count
                                        UI.message("   üìé Found #{attachment_count} attachment(s) in activity")
                                        activity['attachments'].each do |attachment|
                                          if attachment['filename'] && attachment['filename'].match?(/\.png$/i)
                                            UI.message("   ‚úÖ Found screenshot attachment: #{attachment['filename']}")
                                            # Extract the attachment
                                            if attachment['payloadRef'] && attachment['payloadRef']['id']
                                              attachment_id = attachment['payloadRef']['id']
                                              attachment_path = File.join(locale_dir, attachment['filename'])
                                              # Export attachment - use direct command since plugin export_items format may be wrong
                                              extract_output = `xcrun xcresulttool export --type file --path "#{result_bundle_to_check}" --id "#{attachment_id}" --output-path "#{attachment_path}" 2>&1`
                                              if File.exist?(attachment_path)
                                                extracted_count += 1
                                                UI.message("   ‚úÖ Extracted screenshot: #{attachment['filename']}")
                                              end
                                            end
                                          end
                                        end
                                      end
                                      
                                      # Check subactivities recursively
                                      if activity['subactivities'] && activity['subactivities'].is_a?(Array)
                                        activity['subactivities'].each do |subactivity|
                                          if subactivity['attachments'] && subactivity['attachments'].is_a?(Array)
                                            subactivity['attachments'].each do |attachment|
                                              if attachment['filename'] && attachment['filename'].match?(/\.png$/i)
                                                UI.message("   ‚úÖ Found screenshot in subactivity: #{attachment['filename']}")
                                                if attachment['payloadRef'] && attachment['payloadRef']['id']
                                                  attachment_id = attachment['payloadRef']['id']
                                                  attachment_path = File.join(locale_dir, attachment['filename'])
                                                  # Export attachment - use direct command since plugin export_items format may be wrong
                                                  extract_output = `xcrun xcresulttool export --type file --path "#{result_bundle_to_check}" --id "#{attachment_id}" --output-path "#{attachment_path}" 2>&1`
                                                  if File.exist?(attachment_path)
                                                    extracted_count += 1
                                                    UI.message("   ‚úÖ Extracted screenshot: #{attachment['filename']}")
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                    
                                    # Summary for this test
                                    UI.message("   üìä Test summary: #{total_messages} messages, #{total_attachments} attachments")
                                  else
                                    UI.message("   ‚ö†Ô∏è  No activities found for test")
                                  end
                                else
                                  UI.message("   ‚ö†Ô∏è  Failed to get test object (ID: #{test_id})")
                                  UI.message("   Error output: #{test_output[0..200]}")
                                end
                            end
                        else
                          UI.message("   ‚ö†Ô∏è  Tests object has no test references")
                        end
                      else
                        UI.message("   ‚ö†Ô∏è  Failed to get tests object (ID: #{tests_id})")
                        UI.message("   Error output: #{tests_output[0..200]}")
                      end
                    else
                      UI.message("   ‚ö†Ô∏è  Action has no actionResult.testsRef")
                    end
                  end
                else
                  UI.message("   ‚ö†Ô∏è  Root object has no actions")
                  UI.message("   üîç Attempting alternative navigation methods...")
                  
                  # Try modern API approach: use get test-results directly
                  UI.message("   üîç Trying modern API: get test-results summary...")
                  modern_output = `xcrun xcresulttool get test-results summary --path "#{result_bundle_to_check}" --format json 2>&1`
                  if $?.success? && modern_output && !modern_output.empty?
                    UI.message("   ‚úÖ Modern API succeeded!")
                    begin
                      modern_data = JSON.parse(modern_output)
                      UI.message("   üìã Modern API keys: #{modern_data.keys.join(', ')}")
                      
                      # Modern API structure: { "testResults": { "tests": [...] } }
                      if modern_data['testResults'] && modern_data['testResults']['tests']
                        tests = modern_data['testResults']['tests']
                        UI.message("   üìã Found #{tests.count} test(s) via modern API")
                        tests.each do |test|
                          test_name = test['identifier'] || test['name'] || 'Unknown'
                          test_status = test['testStatus'] || 'Unknown'
                          UI.message("   üìù Test: #{test_name} - Status: #{test_status}")
                        end
                      end
                    rescue => e
                      UI.message("   ‚ö†Ô∏è  Failed to parse modern API output: #{e.message}")
                    end
                  else
                    UI.message("   ‚ö†Ô∏è  Modern API failed: #{modern_output[0..200]}")
                  end
                  
                  # Show sample of root object structure for debugging
                  UI.message("   üîç Root object sample (first level):")
                  root_data.keys.first(10).each do |key|
                    value = root_data[key]
                    value_type = value.class
                    value_preview = if value.is_a?(String)
                      value[0..50]
                    elsif value.is_a?(Array)
                      "Array[#{value.count}]"
                    elsif value.is_a?(Hash)
                      "Hash{#{value.keys.first(3).join(', ')}}"
                    else
                      value.inspect[0..50]
                    end
                    UI.message("     - #{key}: #{value_type} = #{value_preview}")
                  end
                end
              rescue JSON::ParserError => e
                UI.message("   ‚ö†Ô∏è  Failed to parse result bundle JSON: #{e.message}")
                UI.message("   Root output length: #{root_output.length} characters")
                UI.message("   Root output (first 500 chars): #{root_output[0..500]}")
                if root_output.length > 500
                  UI.message("   Root output (last 500 chars): #{root_output[-500..-1]}")
                end
              rescue => e
                UI.message("   ‚ö†Ô∏è  Error navigating result bundle structure: #{e.message}")
                UI.message("   Error class: #{e.class}")
                UI.message("   Backtrace: #{e.backtrace.first(5).join("\n")}")
              end
            else
              UI.message("   ‚ö†Ô∏è  Root object retrieval failed or returned empty")
              if $?
                UI.message("   Exit code: #{$?.exitstatus}")
              end
              UI.message("   Output length: #{root_output ? root_output.length : 0} characters")
              if root_output && !root_output.empty?
                UI.message("   Output (first 500 chars): #{root_output[0..500]}")
              end
              # Try to get basic info about the result bundle
              UI.message("   üîç Attempting to list result bundle contents...")
              if Dir.exist?(result_bundle_to_check)
                top_level = Dir.entries(result_bundle_to_check).reject { |e| e.start_with?(".") }
                UI.message("   Top-level contents: #{top_level.join(", ")}")
              end
              
              # CRITICAL DIAGNOSTICS: Try alternative method to extract test information
              # Use xcresulttool to get test summaries directly - use legacy API
              begin
                UI.message("   üîç Trying alternative method: xcresulttool get object --legacy --format json --id root...")
                alt_output = `xcrun xcresulttool get object --legacy --format json --path "#{result_bundle_to_check}" --id root 2>&1`
                if !$?.success?
                  alt_output = `xcrun xcresulttool get --format json --id root --path "#{result_bundle_to_check}" 2>&1`
                end
                if alt_output && !alt_output.empty? && ($?.nil? || $?.success?)
                  require 'json'
                  alt_data = JSON.parse(alt_output)
                  UI.message("   ‚úÖ Successfully parsed result bundle with alternative method")
                  # Try to find test information
                  if alt_data['actions']
                    UI.message("   Found #{alt_data['actions'].count} action(s)")
                  end
                else
                  UI.message("   ‚ö†Ô∏è  Alternative method also failed: #{alt_output[0..200]}")
                end
              rescue => e
                UI.message("   ‚ö†Ô∏è  Error with alternative method: #{e.message}")
              end
            end
          rescue => e
            UI.message("   ‚ö†Ô∏è  Error extracting test logs: #{e.message}")
            UI.message("   Backtrace: #{e.backtrace.first(3).join("\n")}")
          end
        end
        
        # Check all possible cache directories
        found_cache = false
        # CRITICAL FIX: Check cache directories in order of priority
        # First check the primary location, then fallbacks
        possible_cache_dirs.uniq.each do |cache_dir|
          UI.message("   Checking cache directory: #{cache_dir}")
          if Dir.exist?(cache_dir)
            found_cache = true
            UI.message("   ‚úÖ Cache directory exists: #{cache_dir}")
            
            # List all files in cache directory for debugging
            all_files = Dir.entries(cache_dir).reject { |f| f.start_with?(".") }
            if all_files.any?
              UI.message("   Files in cache directory (#{all_files.count}): #{all_files.first(10).join(", ")}")
              # CRITICAL FIX: If this is the base cache directory (not screenshots subdirectory), also check for screenshots subdirectory
              if !cache_dir.end_with?("screenshots") && Dir.exist?(File.join(cache_dir, "screenshots"))
                screenshots_subdir = File.join(cache_dir, "screenshots")
                UI.message("   üîç Also checking screenshots subdirectory: #{screenshots_subdir}")
                subdir_files = Dir.entries(screenshots_subdir).reject { |f| f.start_with?(".") }
                if subdir_files.any?
                  UI.message("   Files in screenshots subdirectory (#{subdir_files.count}): #{subdir_files.first(10).join(", ")}")
                end
              end
            end
            
            # Check for debug log in this directory too
            debug_log_in_dir = File.join(File.dirname(cache_dir), "snapshot_debug.log")
            if File.exist?(debug_log_in_dir)
              UI.message("   ‚úÖ Found debug log in cache parent: #{debug_log_in_dir}")
              debug_content = File.read(debug_log_in_dir)
              snapshot_calls = debug_content.scan(/snapshot:/).count
              UI.message("   üìä Debug log shows #{snapshot_calls} snapshot() calls")
            end
            
            # Look for PNG files (case-insensitive, with various naming patterns)
            # CRITICAL: Use the same device name sanitization format as SnapshotHelper
            # This matches what we set in ENV['SIMULATOR_DEVICE_NAME'] above
            device_sanitized = device_name_sanitized || device.gsub(/[^a-zA-Z0-9]/, "")
            cache_screenshots = []
            # CRITICAL FIX: Check for ALL PNG files first (most reliable)
            cache_screenshots = Dir.glob(File.join(cache_dir, "*.{png,PNG}"))
            # Also check for files that might have device name in them (exact match)
            cache_screenshots += Dir.glob(File.join(cache_dir, "#{device_sanitized}-*.{png,PNG}"))
            # Fallback: check for any device name pattern
            cache_screenshots += Dir.glob(File.join(cache_dir, "*iPhone*.{png,PNG}"))
            cache_screenshots += Dir.glob(File.join(cache_dir, "*iPad*.{png,PNG}"))
            # CRITICAL FIX: Also check for screenshot names directly (in case device prefix was removed)
            cache_screenshots += Dir.glob(File.join(cache_dir, "01-*.{png,PNG}"))
            cache_screenshots += Dir.glob(File.join(cache_dir, "02-*.{png,PNG}"))
            cache_screenshots += Dir.glob(File.join(cache_dir, "03-*.{png,PNG}"))
            cache_screenshots += Dir.glob(File.join(cache_dir, "04-*.{png,PNG}"))
            cache_screenshots += Dir.glob(File.join(cache_dir, "05-*.{png,PNG}"))
            cache_screenshots.uniq!
            
            if cache_screenshots.any?
              UI.message("   ‚úÖ Found #{cache_screenshots.count} screenshots in cache directory")
              cache_screenshots.each do |src|
                basename = File.basename(src)
                # Remove device prefix if present (e.g., "iPhone16ProMax-01-WelcomeScreen.png" -> "01-WelcomeScreen.png")
                # Fastlane expects just the screenshot name
                if basename.include?("-")
                  # Try to extract just the screenshot name part
                  parts = basename.split("-", 2)
                  if parts.length == 2 && (parts[0].include?("iPhone") || parts[0].include?("iPad"))
                    basename = parts[1] # Use just the screenshot name part
                  end
                end
                dst = File.join(locale_dir, basename)
                unless File.exist?(dst)
                  FileUtils.cp(src, dst)
                  extracted_count += 1
                  UI.message("   ‚úÖ Copied: #{basename}")
                else
                  UI.message("   ‚è≠Ô∏è  Skipped (already exists): #{basename}")
                end
              end
              UI.message("   ‚úÖ Copied #{cache_screenshots.count} screenshots from cache directory")
              # CRITICAL FIX: Don't break immediately - check if we got all expected screenshots
              # Only break if we found enough screenshots (at least 5 per test method)
              if extracted_count >= 5
                UI.message("   ‚úÖ Found sufficient screenshots, stopping cache directory search")
                break
              else
                UI.message("   ‚ö†Ô∏è  Only found #{extracted_count} screenshots, continuing search...")
              end
            else
              UI.message("   ‚ö†Ô∏è  Cache directory exists but no screenshots found")
              # CRITICAL FIX: If this is the base cache directory, also check screenshots subdirectory
              if !cache_dir.end_with?("screenshots")
                screenshots_subdir = File.join(cache_dir, "screenshots")
                if Dir.exist?(screenshots_subdir)
                  UI.message("   üîç Checking screenshots subdirectory: #{screenshots_subdir}")
                  subdir_screenshots = Dir.glob(File.join(screenshots_subdir, "*.{png,PNG}"))
                  if subdir_screenshots.any?
                    UI.message("   ‚úÖ Found #{subdir_screenshots.count} screenshots in subdirectory!")
                    subdir_screenshots.each do |src|
                      basename = File.basename(src)
                      if basename.include?("-")
                        parts = basename.split("-", 2)
                        if parts.length == 2 && (parts[0].include?("iPhone") || parts[0].include?("iPad"))
                          basename = parts[1]
                        end
                      end
                      dst = File.join(locale_dir, basename)
                      unless File.exist?(dst)
                        FileUtils.cp(src, dst)
                        extracted_count += 1
                        UI.message("   ‚úÖ Copied from subdirectory: #{basename}")
                      end
                    end
                    if extracted_count >= 5
                      break
                    end
                  end
                end
              end
              # List what IS in the directory
              if all_files.any?
                UI.message("   Directory contents: #{all_files.join(", ")}")
              end
            end
          else
            UI.message("   ‚ö†Ô∏è  Cache directory does not exist: #{cache_dir}")
          end
        end
        
        unless found_cache
          UI.message("   ‚ö†Ô∏è  No cache directories found in any expected location")
        end
        
        # Method 4: Recursive search as last resort (if screenshots still not found)
        if extracted_count == 0
          UI.message("   üîç Performing recursive search for screenshots...")

          # Define reasonable search roots (don't search entire filesystem)
          search_roots = []

          # ONLY search home directory in CI environment
          # For local development, skip home directory to avoid finding old test screenshots
          # in user directories like ~/Documents, ~/Downloads, etc.
          if ENV['CI']
            if ENV['HOME']
              search_roots << ENV['HOME']
            end
            search_roots << Dir.home
          else
            UI.message("   ‚è≠Ô∏è  Skipping home directory search for local run (CI only)")
          end
          
          # Search in derived data
          if derived && Dir.exist?(derived)
            search_roots << derived
          end
          
          # Search in simulator directories
          simulator_base = File.expand_path("~/Library/Developer/CoreSimulator/Devices")
          if Dir.exist?(simulator_base)
            search_roots << simulator_base
          end
          
          # Search in workspace directory
          workspace_root = File.expand_path(".")
          search_roots << workspace_root
          
          # Research-based additional search locations:
          # 1. Default Xcode Derived Data (if different from custom derived path)
          default_derived_data = File.expand_path("~/Library/Developer/Xcode/DerivedData")
          if Dir.exist?(default_derived_data) && default_derived_data != derived
            search_roots << default_derived_data
          end
          
          # 2. Xcode logs directory
          xcode_logs = File.expand_path("~/Library/Logs")
          if Dir.exist?(xcode_logs)
            search_roots << xcode_logs
          end
          
          # 3. Temporary directories (screenshots might be in temp locations)
          if ENV['TMPDIR']
            search_roots << ENV['TMPDIR']
          end
          if ENV['TMP']
            search_roots << ENV['TMP']
          end
          
          # 4. Fastlane screenshots output directory (might have been created elsewhere)
          fastlane_screenshots_base = File.expand_path("./fastlane/screenshots")
          if Dir.exist?(fastlane_screenshots_base)
            search_roots << fastlane_screenshots_base
          end
          
          search_roots.uniq!
          
          found_screenshots = []
          search_roots.each do |root|
            next unless Dir.exist?(root)
            UI.message("   Searching in: #{root}")
            
            begin
              # Recursively search for PNG files (limit depth to avoid performance issues)
              # Look for files that might be screenshots (contain device names or screenshot names)
              screenshot_patterns = [
                "*iPhone*.png",
                "*iPad*.png",
                "*01-WelcomeScreen*.png",
                "*02-ListsHome*.png",
                "*03-ListDetail*.png",
                "*04-ItemDetail*.png",
                "*05-ItemEdit*.png"
              ]
              
              # Search with depth limit (max 5 levels deep to avoid performance issues)
              max_depth = 5
              current_depth = 0
              
              # Use find command for better performance than Ruby's recursive glob
              screenshot_patterns.each do |pattern|
                # Use find command to search recursively
                find_cmd = "find '#{root}' -maxdepth #{max_depth} -type f -iname '#{pattern}' 2>/dev/null | head -50"
                found_files = `#{find_cmd}`.lines.map(&:chomp).reject(&:empty?)
                
                found_files.each do |file_path|
                  # Skip if already found or in system directories
                  next if file_path.include?("/System/") || file_path.include?("/Library/Caches/com.apple")
                  next if found_screenshots.include?(file_path)
                  
                  # Check if file looks like a screenshot (reasonable size, PNG format)
                  if File.exist?(file_path) && File.size(file_path) > 1000 # At least 1KB
                    found_screenshots << file_path
                    UI.message("     ‚úÖ Found potential screenshot: #{file_path}")
                  end
                end
              end
              
              # Also search for any PNG files in tools.fastlane directories
              fastlane_cache_pattern = "**/tools.fastlane/**/*.png"
              Dir.glob(File.join(root, fastlane_cache_pattern)).each do |file_path|
                next if found_screenshots.include?(file_path)
                if File.exist?(file_path) && File.size(file_path) > 1000
                  found_screenshots << file_path
                  UI.message("     ‚úÖ Found screenshot in fastlane cache: #{file_path}")
                end
              end
              
            rescue => e
              UI.message("     ‚ö†Ô∏è  Error searching in #{root}: #{e.message}")
            end
          end
          
          # Copy found screenshots
          if found_screenshots.any?
            UI.message("   ‚úÖ Found #{found_screenshots.count} potential screenshots via recursive search")
            found_screenshots.each do |src|
              begin
                basename = File.basename(src)
                # Try to extract screenshot name (remove device prefix if present)
                if basename.include?("-")
                  parts = basename.split("-", 2)
                  if parts.length == 2 && (parts[0].include?("iPhone") || parts[0].include?("iPad"))
                    basename = parts[1]
                  end
                end
                dst = File.join(locale_dir, basename)
                unless File.exist?(dst)
                  FileUtils.cp(src, dst)
                  extracted_count += 1
                  UI.message("   ‚úÖ Copied: #{basename} from #{File.dirname(src)}")
                end
              rescue => e
                UI.message("   ‚ö†Ô∏è  Error copying #{src}: #{e.message}")
              end
            end
          else
            UI.message("   ‚ö†Ô∏è  No screenshots found via recursive search")
          end
        end
        
        # Method 5: Recursive search for debug logs
        UI.message("   üîç Performing recursive search for debug logs...")
        log_search_roots = []
        if ENV['HOME']
          log_search_roots << ENV['HOME']
        end
        log_search_roots << Dir.home
        if derived && Dir.exist?(derived)
          log_search_roots << derived
        end
        
        found_logs = []
        log_search_roots.uniq.each do |root|
          next unless Dir.exist?(root)
          begin
            # Search for snapshot_debug.log files
            log_pattern = "**/snapshot_debug.log"
            Dir.glob(File.join(root, log_pattern)).each do |log_path|
              next if found_logs.include?(log_path)
              if File.exist?(log_path)
                found_logs << log_path
                UI.message("   ‚úÖ Found debug log: #{log_path}")
                begin
                  log_content = File.read(log_path)
                  snapshot_calls = log_content.scan(/snapshot:/).count
                  if snapshot_calls > 0
                    UI.message("     üìä Contains #{snapshot_calls} snapshot() calls")
                    # Show last few entries
                    snapshot_lines = log_content.lines.select { |l| l.include?("snapshot:") }.last(5)
                    snapshot_lines.each { |line| UI.message("       #{line.chomp}") }
                  end
                rescue => e
                  UI.message("     ‚ö†Ô∏è  Error reading log: #{e.message}")
                end
              end
            end
            
            # Also search for xcodebuild log files
            # Research shows logs are in: DerivedData/Logs/Test, ~/Library/Logs/snapshot, etc.
            xcode_log_patterns = [
              "**/snapshot/**/*.log",
              "**/Logs/snapshot/*.log",
              "**/Logs/Test/*.log",
              "**/DerivedData/**/Logs/Test/*.log",
              "**/DerivedData/**/Logs/**/*.txt",  # StandardOutputAndStandardError.txt
              "**/xcresult/**/*.log",
              "**/TestSummaries.plist"  # Test summaries may contain log references
            ]
            xcode_log_patterns.each do |pattern|
              Dir.glob(File.join(root, pattern)).each do |log_path|
                next if found_logs.include?(log_path) || File.size(log_path) > 10_000_000 # Skip huge logs (>10MB)
                if File.exist?(log_path) && File.mtime(log_path) > Time.now - 3600 # Modified in last hour
                  found_logs << log_path
                  UI.message("   ‚úÖ Found xcodebuild log: #{log_path} (#{File.size(log_path)} bytes)")
                end
              end
            end
          rescue => e
            UI.message("   ‚ö†Ô∏è  Error searching for logs in #{root}: #{e.message}")
          end
        end
        
        # Method 3: Check for debug log file (verifies snapshot() is being called)
        possible_cache_dirs.uniq.each do |cache_dir|
          debug_log_path = File.join(File.dirname(cache_dir), "snapshot_debug.log")
          if File.exist?(debug_log_path)
            UI.message("   ‚úÖ Found debug log at: #{debug_log_path}")
            debug_content = File.read(debug_log_path)
            snapshot_calls = debug_content.lines.select { |l| l.include?("snapshot:") }
            if snapshot_calls.any?
              UI.message("   ‚úÖ Debug log shows #{snapshot_calls.count} snapshot() calls:")
              snapshot_calls.last(5).each { |line| UI.message("     #{line.chomp}") }
            else
              UI.message("   ‚ö†Ô∏è  Debug log exists but no snapshot calls found")
            end
            break
          end
        end
        
        # Method 3: Check if Fastlane already extracted screenshots automatically
        # With result_bundle: false, Fastlane parses logs and extracts screenshots automatically to the locale directory
        fastlane_extracted_dir = File.join(screenshots_dir, locale)
        if Dir.exist?(fastlane_extracted_dir)
          fastlane_screenshots = Dir.glob(File.join(fastlane_extracted_dir, "*.png"))
          if fastlane_screenshots.any?
            UI.message("   ‚úÖ Fastlane automatically extracted #{fastlane_screenshots.count} screenshots to: #{fastlane_extracted_dir}")
            extracted_count += fastlane_screenshots.count
          else
            UI.message("   ‚ö†Ô∏è  Fastlane output directory exists but no screenshots found")
          end
        end
        
        if extracted_count > 0
          UI.success("   ‚úÖ Total extracted: #{extracted_count} screenshots")
        else
          UI.message("   ‚ö†Ô∏è  No screenshots found in result bundle or cache directory")
        end
        
        # CRITICAL DIAGNOSTICS: Extract environment debug file from simulator
        # The test writes environment variables to a file we can check
        UI.message("üîç DIAGNOSTICS: Checking for environment debug file from test process...")
        begin
          # Find simulator data directory
          simulator_info = `xcrun simctl list devices --json 2>&1`
          if $?.success?
            require 'json'
            sim_data = JSON.parse(simulator_info)
            device_name_for_match = device.gsub(/[^a-zA-Z0-9]/, "")
            sim_data['devices'].each do |runtime, devices|
              devices.each do |sim|
                if sim['name'] == device || sim['name'].gsub(/[^a-zA-Z0-9]/, "") == device_name_for_match
                  if sim['dataPath']
                    env_debug_path = File.join(sim['dataPath'], "Library", "Application Support", "test_env_debug.txt")
                    if File.exist?(env_debug_path)
                      UI.message("   ‚úÖ Found environment debug file!")
                      env_debug_content = File.read(env_debug_path)
                      UI.message("   Environment variables seen by test process:")
                      env_debug_content.lines.each { |line| UI.message("     #{line.chomp}") }
                    else
                      UI.message("   ‚ö†Ô∏è  Environment debug file not found at: #{env_debug_path}")
                    end
                    break
                  end
                end
              end
            end
          end
        rescue => e
          UI.message("   ‚ö†Ô∏è  Could not check environment debug file: #{e.message}")
        end
        
        # CRITICAL DIAGNOSTICS: Summary of findings
        UI.header("üìä DIAGNOSTIC SUMMARY for #{device} (#{locale})")
        UI.message("   Screenshots extracted: #{extracted_count}")
        UI.message("   Debug log found: #{debug_log_found ? 'Yes' : 'No'}")
        UI.message("   Result bundle exists: #{result_bundle_to_check && File.exist?(result_bundle_to_check) ? 'Yes' : 'No'}")
        UI.message("   Cache directory checked: #{simulator_host_home_for_check}/Library/Caches/tools.fastlane/screenshots")
        UI.message("   Expected screenshots: ~#{expected_per_combination}")
        
        if extracted_count == 0
          UI.error("   ‚ùå NO SCREENSHOTS FOUND - Possible causes:")
          UI.error("      1. snapshot() not being called in tests")
          UI.error("      2. Environment variables not passed to test process")
          UI.error("      3. Cache directory not accessible from test process")
          UI.error("      4. Tests failing before reaching snapshot() calls")
          UI.error("      5. Screenshots saved to unexpected location")
        end
        
        # Incremental verification: check screenshots immediately after this device/language
        UI.message("üîç Verifying screenshots for #{device} (#{locale})...")
        locale_dir = File.join(screenshots_dir, locale)
        FileUtils.mkdir_p(locale_dir) unless File.directory?(locale_dir)
        
        # Check for screenshots (device name in filename might be sanitized)
        # CRITICAL: Use the same device name sanitization format as SnapshotHelper
        device_sanitized_for_check = device_name_sanitized || device.gsub(/[^a-zA-Z0-9]/, "")
        all_locale_shots = Dir.glob(File.join(locale_dir, "*.png"))
        device_shots = all_locale_shots.select { |f| 
          basename = File.basename(f)
          basename.include?(device_sanitized_for_check) || 
          basename.include?(device.gsub(/[^a-zA-Z0-9]/, "")) ||
          basename.include?("iPhone16ProMax") || 
          basename.include?("iPadPro13inchM4") ||
          basename.match?(/^\d{2}-/) # Screenshot names like "01-WelcomeScreen.png"
        }
        
        if all_locale_shots.empty?
          UI.error("‚ùå No screenshots found for #{device} (#{locale})")
          UI.error("   Expected location: #{locale_dir}")
          UI.error("   Expected count: ~#{expected_per_combination} screenshots")
          
          # Check log file for debugging - try multiple possible locations
          possible_log_paths = [
            File.expand_path("~/Library/Logs/snapshot/ListAll-ListAll.log"),
            File.join(derived, "Logs/Test", "*.log"),
            File.join(derived, "Logs", "*.log"),
            File.expand_path("~/Library/Developer/Xcode/DerivedData/*/Logs/Test/*.log")
          ]
          
          log_path = nil
          log_content = nil
          possible_log_paths.each do |path_pattern|
            if path_pattern.include?("*")
              # Handle glob patterns
              matches = Dir.glob(path_pattern).sort_by { |f| File.mtime(f) }.reverse
              if matches.any?
                log_path = matches.first
                break
              end
            elsif File.exist?(path_pattern)
              log_path = path_pattern
              break
            end
          end
          
          # Also check the xcresult bundle for test output and attachments
          xcresult_path = File.join(derived, "Logs/Test", "Test-ListAll-*.xcresult")
          xcresult_files = Dir.glob(xcresult_path).sort_by { |f| File.mtime(f) }.reverse
          if xcresult_files.any?
            latest_xcresult = xcresult_files.first
            UI.message("   üîç Checking xcresult bundle: #{latest_xcresult}")
            # Try to extract test output from result bundle
            begin
              # Use xcresulttool to get test summaries - using deprecated API with --legacy flag
              # NOTE: Modern API (`get test-results`) exists but requires different code structure
              # TODO: Migrate to modern API in future refactoring
              test_summary = `xcrun xcresulttool get object --legacy --format json --path "#{latest_xcresult}" 2>&1`
              if !$?.success?
                test_summary = `xcrun xcresulttool get object --format json --path "#{latest_xcresult}" 2>&1`
              end
              
              if test_summary && !test_summary.empty? && ($?.nil? || $?.success?)
                require 'json'
                summary_data = JSON.parse(test_summary)
                UI.message("   ‚úÖ xcresult bundle is valid")
                
                # Try to extract attachments (screenshots might be here)
                attachments_dir = File.join(locale_dir, "xcresult_attachments")
                FileUtils.mkdir_p(attachments_dir) unless File.directory?(attachments_dir)
                
                # CRITICAL FIX: Use correct modern API command
                # The correct command is "export attachments" not just "attachments"
                attachments_output = `xcrun xcresulttool export attachments --path "#{latest_xcresult}" --output-path "#{attachments_dir}" 2>&1`
                if !$?.success?
                  UI.message("   ‚ö†Ô∏è  export attachments failed: #{attachments_output.chomp}")
                else
                  UI.message("   ‚úÖ export attachments succeeded")
                  # Check if manifest.json was created
                  manifest_path = File.join(attachments_dir, "manifest.json")
                  if File.exist?(manifest_path)
                    UI.message("   ‚úÖ Attachment manifest created")
                  end
                end
                
                if Dir.exist?(attachments_dir)
                  png_files = Dir.glob(File.join(attachments_dir, "**", "*.{png,PNG}"))
                  if png_files.any?
                    UI.message("   ‚úÖ Found #{png_files.count} PNG files in xcresult attachments")
                    png_files.each do |src|
                      basename = File.basename(src)
                      dst = File.join(locale_dir, basename)
                      unless File.exist?(dst)
                        FileUtils.cp(src, dst)
                        extracted_count += 1
                        UI.message("   ‚úÖ Extracted from xcresult: #{basename}")
                      end
                    end
                  end
                  FileUtils.rm_rf(attachments_dir)
                end
              else
                UI.message("   ‚ö†Ô∏è  xcresult bundle validation failed: #{test_summary.chomp}")
              end
            rescue => e
              UI.message("   ‚ö†Ô∏è  Error reading xcresult: #{e.message}")
            end
          end
          
          if log_path && File.exist?(log_path)
            UI.error("   Checking log file: #{log_path}")
            log_content = File.read(log_path)
            
            # Check if tests actually ran
            if log_content.include?("testScreenshots01_WelcomeScreen") || log_content.include?("testScreenshots02_MainFlow")
              UI.message("   ‚úÖ Test methods found in log - tests are executing")
            else
              UI.error("   ‚ùå Test methods NOT found in log - tests may not be running")
            end
            
            # Check for both "snapshot:" and debug messages
            if log_content.include?("snapshot:") || log_content.include?("DEBUG: Snapshot.snapshot")
              UI.message("   ‚úÖ Found 'snapshot:' entries in log - snapshot() is being called")
              # Show last snapshot entries
              snapshot_lines = log_content.lines.select { |l| l.include?("snapshot:") || l.include?("DEBUG: Snapshot.snapshot") }.last(10)
              UI.message("   Last snapshot entries:")
              snapshot_lines.each { |line| UI.message("     #{line.chomp}") }
              UI.error("   ‚ö†Ô∏è  Screenshots were generated but not extracted by Fastlane")
              UI.error("   ‚ö†Ô∏è  This may indicate a Fastlane snapshot bug or log parsing issue")
            else
              UI.error("   ‚ùå No 'snapshot:' entries found in log")
              UI.error("   ‚ö†Ô∏è  This suggests snapshot() calls in UI tests are NOT executing")
              UI.error("   ‚ö†Ô∏è  Possible causes:")
              UI.error("      - setupSnapshot() not called before app.launch()")
              UI.error("      - snapshot() calls are failing silently")
              UI.error("      - Tests are crashing before reaching snapshot() calls")
              UI.error("      - NSLog output not being captured in log file")
              
              # Check for debug messages that might indicate where the test is failing
              if log_content.include?("DEBUG:")
                debug_lines = log_content.lines.select { |l| l.include?("DEBUG:") }.last(20)
                UI.message("   Recent DEBUG messages:")
                debug_lines.each { |line| UI.message("     #{line.chomp}") }
              else
                UI.message("   ‚ö†Ô∏è  No DEBUG messages found in log either")
              end
              
              # Check for any print statements from test code
              if log_content.include?("üîç DEBUG:")
                test_debug_lines = log_content.lines.select { |l| l.include?("üîç DEBUG:") }.last(20)
                UI.message("   Test code DEBUG messages found:")
                test_debug_lines.each { |line| UI.message("     #{line.chomp}") }
              end
              
              # Check for setupSnapshot messages
              if log_content.include?("setupSnapshot") || log_content.include?("Cache directory")
                setup_lines = log_content.lines.select { |l| l.include?("setupSnapshot") || l.include?("Cache directory") || l.include?("Screenshots directory") }.last(10)
                UI.message("   setupSnapshot() related messages:")
                setup_lines.each { |line| UI.message("     #{line.chomp}") }
              else
                UI.message("   ‚ö†Ô∏è  No setupSnapshot() messages found - this may indicate setupSnapshot() is not being called")
              end
              
              # Check for errors or warnings from SnapshotHelper
              if log_content.include?("‚ö†Ô∏è") || log_content.include?("‚ùå") || log_content.include?("ERROR:")
                error_lines = log_content.lines.select { |l| l.include?("‚ö†Ô∏è") || l.include?("‚ùå") || l.include?("ERROR:") || l.include?("screenshotsDirectory is nil") || l.include?("XCUIApplication is not set") }.last(15)
                UI.message("   SnapshotHelper errors/warnings found:")
                error_lines.each { |line| UI.message("     #{line.chomp}") }
              end
              
              # Show a sample of the log to understand what IS being captured
              UI.message("   Sample of log content (last 30 lines):")
              log_content.lines.last(30).each_with_index do |line, idx|
                # Skip very long lines that are just noise
                next if line.length > 500
                UI.message("     [#{log_content.lines.count - 30 + idx}] #{line.chomp}")
              end
            end
          else
            UI.error("   ‚ö†Ô∏è  Log file not found at #{log_path}")
          end
          
          # FAIL FAST: Stop immediately after first failure to save time
          UI.user_error!("üö® Screenshot generation failed for #{device} (#{locale}) - FAILING FAST to save time")
        else
          found_count = device_shots.empty? ? all_locale_shots.count : device_shots.count
          if found_count >= expected_per_combination
            UI.success("‚úÖ Generated #{found_count} screenshots for #{device} (#{locale})")
          else
            UI.message("‚ö†Ô∏è  Found #{found_count} screenshots for #{device} (#{locale}) (expected ~#{expected_per_combination})")
            UI.message("   Continuing... (may be partial set)")
          end
        end
      end
    end
    
    # Final verification: ensure all expected screenshots exist
    UI.header("Final verification: Checking all screenshots")
    raw_shots = Dir.glob(File.join(screenshots_dir, "**/*.png"))
    expected_total = devices.count * locales.count * expected_per_combination
    if raw_shots.empty?
      UI.user_error!("üö® iOS screenshot generation failed: No screenshots found in #{screenshots_dir}")
    elsif raw_shots.count < expected_total * 0.8  # Allow 20% tolerance
      UI.message("‚ö†Ô∏è  Found #{raw_shots.count} screenshots (expected ~#{expected_total})")
      UI.message("   Continuing with available screenshots...")
    else
      UI.success("‚úÖ Found #{raw_shots.count} total raw iOS screenshots (expected ~#{expected_total})")
    end

    # 2. Normalize new device sizes to Frameit-supported canvases
    UI.header("Normalizing screenshot sizes for Frameit compatibility")
    compat_root = File.expand_path("screenshots_compat", __dir__)
    sh "rm -rf #{compat_root}"
    locales = %w[en-US fi]
    require 'fileutils'
    require 'shellwords'
    FileUtils.mkdir_p(compat_root)
    UI.message("Compat root: #{compat_root}")
    locales.each do |loc|
      src = File.expand_path(File.join("screenshots", loc), __dir__)
      dst = File.join(compat_root, loc)
      FileUtils.mkdir_p(dst)
      Dir.glob(File.join(src, "*.png")).each do |png|
        # Skip obvious non-screenshot assets like icons
        basename = File.basename(png)
        # Only process our numbered screenshots (supports both -NN- and -NN_ formats)
        next unless basename =~ /-(01|02|03|04|05)[-_]/

        # Detect size
        size = sh("identify -format '%w %h' #{Shellwords.escape(png)}").strip.split.map(&:to_i) rescue []
        target_w = target_h = nil
        if size == [1320, 2868]
          target_w, target_h = [1290, 2796]       # iPhone 6.7" classic
        elsif size == [2064, 2752]
          target_w, target_h = [2048, 2732]       # iPad Pro 12.9"
        else
          # Pass-through if already supported sizes
          target_w, target_h = size
        end

        out = File.join(dst, basename)
        if target_w && target_h && size != [0,0]
          if [target_w, target_h] == size
            FileUtils.cp(png, out)
          else
            UI.message("Resizing #{basename} #{size.inspect} -> [#{target_w}, #{target_h}]")
            sh "magick convert #{Shellwords.escape(png)} -resize #{target_w}x#{target_h}! #{Shellwords.escape(out)}"
          end
        end
      end
    end

    UI.header("Framing screenshots with Frameit")
    # 3. Frame them into a separate 'framed' directory to keep raw images
    # Frameit uses ENV['SNAPSHOT_SCREENSHOTS_PATH'] by default; override by temporarily moving/pointing path
    ENV['SNAPSHOT_SCREENSHOTS_PATH'] = compat_root
    ENV['FRAMEIT_CONFIG_PATH'] = File.expand_path('Framefile.json', __dir__)
    frameit(
      path: compat_root,
      white: true
    )

    # Move framed output to dedicated directory preserving locale structure
    framed_root = File.expand_path(File.join('screenshots','framed'), __dir__)
    FileUtils.rm_rf(framed_root)
    FileUtils.mkdir_p(framed_root)
    Dir.glob(File.join(compat_root,'*.png')) # ignore top-level stray pngs
    Dir.glob(File.join(compat_root,'*')).select { |d| File.directory?(d) }.each do |locdir|
      loc = File.basename(locdir)
      target_loc = File.join(framed_root, loc)
      FileUtils.mkdir_p(target_loc)
      Dir.glob(File.join(locdir,'*.png')).each do |png|
        FileUtils.cp(png, target_loc)
      end
    end
    
    # 4. Fail-fast check: ensure framed screenshots exist
    framed_shots = Dir.glob(File.join(framed_root, "**/*.png"))
    if framed_shots.empty?
      UI.user_error!("üö® Framing failed: No framed screenshots found in #{framed_root}")
    end
    UI.success("‚úÖ Found #{framed_shots.count} framed screenshots")

    UI.success("üñº  Framed screenshots generated at #{framed_root}")
  end

  desc "Verify framed screenshots exist for all locales"
  lane :verify_framed do
    # TEMPORARY SPEEDUP (task 5.5): Only Finnish to debug pipeline faster
    # TODO: Revert in task 5.6
    # locales = %w[en-US fi]
    locales = %w[fi]
    prefixes = %w[01-WelcomeScreen 02-ListsHome 03-ListDetail 04-ItemDetail 05-Settings]
    missing = []
    locales.each do |loc|
      base = File.expand_path(File.join('screenshots','framed', loc), __dir__)
      unless Dir.exist?(base)
        missing << "Directory missing: #{base}"
        next
      end
      prefixes.each do |p|
        # Require framed variant specifically
        glob = Dir.glob(File.join(base, "*-", "#{p}_framed.png")) + Dir.glob(File.join(base, "*#{p}*_framed.png"))
        if glob.empty?
          missing << "#{loc}: #{p}*_framed.png"
        end
      end
    end
    if missing.any?
      UI.user_error!("Framed screenshot verification failed. Missing: \n- #{missing.join("\n- ")}")
    else
      UI.success("‚úÖ All framed screenshots present for #{locales.join(', ')}")
    end
  end

  desc "Generate watchOS screenshots (fully automated via UITests + simctl)"
  desc "Captures screenshots from Apple Watch Series 10 (46mm) for EN and FI locales"
  lane :watch_screenshots do
    UI.header("üçé‚åöÔ∏è Generating watchOS Screenshots")
    
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']
    
    # Shared derived data path for prebuild and snapshot
    derived = "./fastlane/derivedDataWatch"
    
    # CRITICAL: Pair Watch simulator with iPhone simulator
    # Without pairing, Watch tests may run on iPhone instead of Watch,
    # and screenshots will show "iPhone Disconnected" icon (violates App Store guidelines)
    # Fastlane snapshot will handle pairing automatically if devices are available,
    # but we ensure they exist and are ready
    UI.header("Preparing Watch and iPhone simulators for pairing")
    watch_device = "Apple Watch Series 10 (46mm)"  # Available in CI (Xcode 16.1)
    iphone_device = "iPhone 16 Pro Max"  # Use same device as iOS screenshots for consistency
    
    # Ensure simulators exist and are available
    # Fastlane snapshot will automatically pair them when running Watch tests
    # The key is ensuring both devices are available in the simulator list
    UI.message("Verifying simulators are available: #{iphone_device} and #{watch_device}")
    
    # Check if simulators exist
    iphone_exists = sh("xcrun simctl list devices available | grep -c '#{iphone_device}' | grep -v 'unavailable'", log: false).strip.to_i > 0 rescue false
    watch_exists = sh("xcrun simctl list devices available | grep -c '#{watch_device}' | grep -v 'unavailable'", log: false).strip.to_i > 0 rescue false
    
    if iphone_exists && watch_exists
      UI.success("‚úÖ Required simulators are available")
      UI.message("üí° Fastlane snapshot will automatically pair Watch with iPhone when running tests")
    else
      UI.important("‚ö†Ô∏è  Some simulators may not be available. Snapshot will attempt to create/pair automatically.")
    end
    
    # 0. ONE-TIME BUILD-FOR-TESTING
    # Build once, then snapshot reuses these compiled products for all languages
    # This prevents rebuilding 2x (2 languages), saving 5-8 minutes
    UI.header("Building Watch app and UI tests once for all snapshot runs")
    scan(
      scheme: "ListAllWatch Watch App",
      project: "./ListAll/ListAll.xcodeproj",
      testplan: "ListAllWatch Watch App",
      devices: [watch_device],  # Any device; we only need to populate DerivedData
      clean: true,
      build_for_testing: true,
      # Note: build_for_testing and test_without_building are mutually exclusive
      # build_for_testing means: build only, don't run tests
      # We need to build UI tests for snapshot, so don't use skip_testing here
      derived_data_path: derived,
      xcargs: "ONLY_ACTIVE_ARCH=YES CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO"
    )
    
    # 1. Raw screenshots using pre-built products
    # Note: test_without_building reuses the build from scan above
    # CRITICAL: Disable xcodebuild_formatter so Fastlane can parse NSLog("snapshot: ...") entries
    # CRITICAL: Ensure iPhone simulator stays running for Watch pairing
    UI.header("Running watch snapshot using pre-built tests")
    snapshot(
      project: "./ListAll/ListAll.xcodeproj",
      scheme: "ListAllWatch Watch App",
      testplan: "ListAllWatch Watch App",
      devices: [watch_device],
      languages: ["en-US", "fi"],
      output_directory: "./fastlane/screenshots/watch",
      clear_previous_screenshots: true,
      override_status_bar: true,
      reinstall_app: true,
      test_without_building: true,  # Reuse pre-built products
      derived_data_path: derived,
      concurrent_simulators: false,
      skip_helper_version_check: true,
      result_bundle: false,  # Disable to allow Fastlane auto-extraction
      xcodebuild_formatter: "",  # Empty string disables formatter, allowing Fastlane to parse logs
      stop_after_first_error: false,  # Don't stop on first error to allow all languages to run
      only_testing: ["ListAllWatch Watch AppUITests/ListAllWatch_Watch_AppUITests/testWatchScreenshots"]  # Run only Watch screenshot tests
    )
    
    # 2. Fail-fast check: ensure raw screenshots exist before processing
    watch_raw_dir = File.expand_path("screenshots/watch", __dir__)
    raw_shots = Dir.glob(File.join(watch_raw_dir, "**/*.png"))
    if raw_shots.empty?
      UI.user_error!("üö® Watch screenshot generation failed: No screenshots found in #{watch_raw_dir}")
    end
    UI.success("‚úÖ Found #{raw_shots.count} raw watch screenshots")
    
    UI.success("üçé‚åöÔ∏è Watch screenshots generation complete!")
    UI.message("üìÅ Raw screenshots saved to: fastlane/screenshots/watch")
    
    # Normalize watch screenshots to App Store Connect required dimensions
    UI.header("üìê Normalizing watchOS screenshots to App Store Connect dimensions")
    watch_normalized_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    
    begin
      WatchScreenshotHelper.normalize_screenshots(
        watch_raw_dir,
        watch_normalized_dir,
        target_size: :series7plus  # 396x484 - Apple Watch Series 7+ (45mm)
      )
    rescue => e
      UI.user_error!("Failed to normalize watch screenshots: #{e.message}")
    end
    
    # 3. Fail-fast check: ensure normalized screenshots exist
    normalized_shots = Dir.glob(File.join(watch_normalized_dir, "**/*.png"))
    if normalized_shots.empty?
      UI.user_error!("üö® Watch screenshot normalization failed: No normalized screenshots found in #{watch_normalized_dir}")
    end
    UI.success("‚úÖ Found #{normalized_shots.count} normalized watch screenshots")
    
    # Copy normalized watch screenshots to framed directory (no framing for watchOS - standard practice)
    UI.header("üìÇ Copying normalized watchOS screenshots to unified directory")
    unified_framed_root = File.expand_path("screenshots/framed", __dir__)
    locales = %w[en-US fi]

    locales.each do |loc|
      normalized_dir = File.join(watch_normalized_dir, loc)
      next unless Dir.exist?(normalized_dir)
      framed_locale_dir = File.join(unified_framed_root, loc)
      FileUtils.mkdir_p(framed_locale_dir)

      # Copy normalized watch screenshots as-is (naked, no frame) - this is standard for watchOS
      Dir.glob(File.join(normalized_dir, "*.png")).each do |normalized|
        base = File.basename(normalized)
        target = File.join(framed_locale_dir, base)
        FileUtils.cp(normalized, target)
      end
    end

    UI.success("‚úÖ Normalized watch screenshots copied to #{unified_framed_root} (396x484, unframed)")
  end

  desc "Validate watch screenshot sizes and naming (uses App Store Connect requirements)"
  lane :verify_watch_screenshots do
    UI.header("üîç Validating watchOS Screenshots")
    watch_normalized_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    
    begin
      WatchScreenshotHelper.validate_screenshots(
        watch_normalized_dir,
        expected_count: 5,
        allowed_sizes: [:series7plus]  # Only accept 396x484 (45mm)
      )
      UI.success("‚úÖ All watch screenshots validated successfully!")
    rescue WatchScreenshotHelper::ValidationError => e
      UI.user_error!("Watch screenshot validation failed: #{e.message}")
    end
  end

  desc "Validate all delivery-ready screenshots (framed iPhone/iPad + naked Watch)"
  lane :validate_delivery_screenshots do
    UI.header("üì∏ Validating delivery-ready screenshots for App Store submission")

    # TEMPORARY SPEEDUP (task 5.5): Only Finnish to debug pipeline faster
    # TODO: Revert in task 5.6
    # locales = %w[en-US fi]
    locales = %w[fi]
    errors = []
    warnings = []
    
    # Expected framed dimensions (Frameit output with device frames)
    iphone_framed_size = { width: 1421, height: 2909, tolerance: 50 }
    ipad_framed_size = { width: 2286, height: 3168, tolerance: 50 }
    watch_size = { width: 396, height: 484, tolerance: 0 }  # Exact match required
    
    # Check framed iPhone/iPad screenshots
    framed_dir = File.expand_path("screenshots/framed", __dir__)
    locales.each do |locale|
      locale_dir = File.join(framed_dir, locale)
      unless Dir.exist?(locale_dir)
        errors << "‚ùå Missing framed screenshots directory: #{locale_dir}"
        next
      end
      
      # TEMPORARY SPEEDUP (task 5.5): Skip iPhone validation
      # TODO: Revert in task 5.6
      # # Check iPhone framed screenshots
      # iphone_framed = Dir.glob(File.join(locale_dir, "iPhone*_framed.png"))
      # if iphone_framed.count != 5
      #   warnings << "‚ö†Ô∏è  #{locale}: Expected 5 iPhone framed screenshots, found #{iphone_framed.count}"
      # end
      #
      # iphone_framed.each do |shot|
      #   dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
      #   w, h = dims.split('x').map(&:to_i)
      #   if (w - iphone_framed_size[:width]).abs > iphone_framed_size[:tolerance] ||
      #      (h - iphone_framed_size[:height]).abs > iphone_framed_size[:tolerance]
      #     errors << "‚ùå #{locale}/#{File.basename(shot)}: #{dims} (expected ~#{iphone_framed_size[:width]}x#{iphone_framed_size[:height]})"
      #   else
      #     puts "‚úÖ #{locale}/#{File.basename(shot)}: #{dims}"
      #   end
      # end

      # Check iPad framed screenshots
      ipad_framed = Dir.glob(File.join(locale_dir, "iPad*_framed.png"))
      if ipad_framed.count != 5
        warnings << "‚ö†Ô∏è  #{locale}: Expected 5 iPad framed screenshots, found #{ipad_framed.count}"
      end
      
      ipad_framed.each do |shot|
        dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
        w, h = dims.split('x').map(&:to_i)
        if (w - ipad_framed_size[:width]).abs > ipad_framed_size[:tolerance] ||
           (h - ipad_framed_size[:height]).abs > ipad_framed_size[:tolerance]
          errors << "‚ùå #{locale}/#{File.basename(shot)}: #{dims} (expected ~#{ipad_framed_size[:width]}x#{ipad_framed_size[:height]})"
        else
          puts "‚úÖ #{locale}/#{File.basename(shot)}: #{dims}"
        end
      end
    end
    
    # TEMPORARY SPEEDUP (task 5.5): Skip Watch validation
    # TODO: Revert in task 5.6
    # # Check watch naked screenshots
    # watch_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    # if Dir.exist?(watch_dir)
    #   locales.each do |locale|
    #     locale_dir = File.join(watch_dir, locale)
    #     unless Dir.exist?(locale_dir)
    #       errors << "‚ùå Missing watch screenshots directory: #{locale_dir}"
    #       next
    #     end
    #
    #     watch_shots = Dir.glob(File.join(locale_dir, "*.png"))
    #     if watch_shots.count != 5
    #       warnings << "‚ö†Ô∏è  #{locale}: Expected 5 watch screenshots, found #{watch_shots.count}"
    #     end
    #
    #     watch_shots.each do |shot|
    #       dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
    #       w, h = dims.split('x').map(&:to_i)
    #       if w != watch_size[:width] || h != watch_size[:height]
    #         errors << "‚ùå #{locale}/#{File.basename(shot)}: #{dims} (expected exactly #{watch_size[:width]}x#{watch_size[:height]})"
    #       else
    #         puts "‚úÖ #{locale}/#{File.basename(shot)}: #{dims}"
    #       end
    #     end
    #   end
    # else
    #   warnings << "‚ö†Ô∏è  Watch screenshots directory not found: #{watch_dir}"
    # end
    
    # Print summary
    puts "\n" + "=" * 70
    puts "Delivery Screenshot Validation Summary"
    puts "=" * 70
    
    if warnings.any?
      puts "\nWarnings:"
      warnings.each { |w| puts w }
    end
    
    if errors.any?
      puts "\nErrors:"
      errors.each { |e| puts e }
      puts "\n‚ùå Validation FAILED: #{errors.count} error(s)"
      UI.user_error!("Delivery screenshots validation failed")
    else
      puts "\n‚úÖ All delivery screenshots are valid and ready for App Store submission!"
      puts "\nReady for upload:"
      puts "  ‚Ä¢ iPhone: 10 framed screenshots (~1421x2909)"
      puts "  ‚Ä¢ iPad: 10 framed screenshots (~2286x3168)"
      puts "  ‚Ä¢ Watch: 10 naked screenshots (396x484)"
      puts "  ‚Ä¢ Total: 30 screenshots across EN + FI locales"
    end
  end
end
