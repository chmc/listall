# Fastlane configuration
# Docs: https://docs.fastlane.tools
require 'base64'
require 'fileutils'
require 'shellwords'
require_relative 'lib/version_helper'
require_relative 'lib/watch_screenshot_helper'
require_relative 'lib/screenshot_helper'

default_platform(:ios)

def require_asc_env!
  missing = ["ASC_KEY_ID", "ASC_ISSUER_ID", "ASC_KEY_BASE64"].reject { |k| ENV[k].to_s.strip.size > 0 }
  UI.user_error!("Missing App Store Connect API key env vars: #{missing.join(', ')}") unless missing.empty?
end

# Prepare screenshots for deliver by copying only framed versions to a clean directory
def prepare_screenshots_for_delivery(framed_path)
  delivery_path = File.expand_path("screenshots/delivery", __dir__)
  FileUtils.rm_rf(delivery_path)
  FileUtils.mkdir_p(delivery_path)
  
  locales = %w[en-US fi]
  locales.each do |locale|
    src_dir = File.join(framed_path, locale)
    dst_dir = File.join(delivery_path, locale)
    FileUtils.mkdir_p(dst_dir)
    
    # Copy only framed screenshots (exclude non-framed variants)
    Dir.glob(File.join(src_dir, "*_framed.png")).each do |framed_file|
      FileUtils.cp(framed_file, dst_dir)
    end
  end
  
  delivery_path
end


platform :ios do
  desc "Run unit and UI tests (xcodebuild like CI)"
  lane :test do
    # Mirror CI behavior with xcodebuild and non-failing exit
    sh "cd ../ListAll && xcodebuild clean build -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 17 Pro,OS=latest' -configuration Debug CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
    sh "cd ../ListAll && xcodebuild test -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 17 Pro,OS=latest' -resultBundlePath ../fastlane/test_output/ListAll.xcresult CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
  end

  desc "Run tests via scan (Fastlane)"
  lane :test_scan do
    # Prefer project since workspace is embedded in .xcodeproj
    scan(
      project: "ListAll/ListAll.xcodeproj",
      scheme: "ListAll",
      clean: true,
      result_bundle: true,
      derived_data_path: "./ListAll/build",
      devices: ["iPhone 17 Pro"], # falls back to default if not available
      fail_build: false
    )
  end

  desc "Build and upload to TestFlight"
  desc "Options:"
  desc "  bump_type: 'patch' (default), 'minor', or 'major' - Type of version increment"
  desc "  skip_version_bump: true to skip version increment (use current version)"
  lane :beta do |options|
    # Setup CI environment (creates temporary keychain)
    if ENV['CI']
      setup_ci
      # Set keychain password for Match to use when importing certs
      ENV["KEYCHAIN_PASSWORD"] = ""  # setup_ci creates keychain with empty password
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    # Handle version numbering with semantic versioning
    unless options[:skip_version_bump]
      bump_type = options[:bump_type] || 'patch'
      
      # Read current version from file
      current_version = VersionHelper.read_version
      UI.message("üì¶ Current version: #{current_version}")
      
      # Increment version
      new_version = VersionHelper.increment_version(current_version, bump_type)
      UI.important("üì¶ Bumping version (#{bump_type}): #{current_version} ‚Üí #{new_version}")
      
      # Update version in all targets
      VersionHelper.update_xcodeproj_version(xcodeproj_path, new_version)
      
      # Save new version to file
      VersionHelper.write_version(new_version)
      
      # Validate all targets have the same version
      unless VersionHelper.validate_versions(xcodeproj_path)
        UI.user_error!("Version validation failed. Please check that all targets have matching versions.")
      end
      
      UI.success("‚úÖ Version updated to #{new_version}")
    else
      current_version = VersionHelper.read_version
      UI.message("‚è≠Ô∏è  Skipping version bump, using current version: #{current_version}")
    end
    
    # Increment build number automatically
    # In CI: use GitHub Actions run number, otherwise just increment by 1
    if ENV['GITHUB_RUN_NUMBER']
      increment_build_number(
        build_number: ENV['GITHUB_RUN_NUMBER'],
        xcodeproj: xcodeproj_path
      )
    else
      increment_build_number(
        xcodeproj: xcodeproj_path
      )
    end
    
    # Sync code signing with verbose output
    match(
      type: 'appstore',
      verbose: true,
      keychain_password: ENV["KEYCHAIN_PASSWORD"] || "",
      skip_set_partition_list: true  # Skip partition list in CI to avoid SecItemCopyMatching error
    )
    
    # Disable automatic code signing for Release configuration
    disable_automatic_code_signing(
      path: "ListAll/ListAll.xcodeproj",
      targets: ["ListAll", "ListAllWatch Watch App"],
      code_sign_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Update Xcode project to use the provisioning profiles from Match
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll_appstore_profile-path"],
      target_filter: "ListAll",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll.watchkitapp_appstore_profile-path"],
      target_filter: "ListAllWatch Watch App",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Build archive (gym/build_app handles exporting ipa)
    ipa_path = build_app(
      project: xcodeproj_path,
      scheme: "ListAll",
      export_method: "app-store",
      output_directory: "./ListAll/build",
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        provisioningProfiles: {
          "io.github.chmc.ListAll" => "match AppStore io.github.chmc.ListAll",
          "io.github.chmc.ListAll.watchkitapp" => "match AppStore io.github.chmc.ListAll.watchkitapp"
        }
      }
    )

    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_KEY_BASE64"]
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
        is_key_content_base64: false,
        in_house: false
      )
      pilot(
        ipa: ipa_path,
        api_key: api_key,
        distribute_external: false
      )
    else
      UI.important("ASC_* env vars not set. Skipping TestFlight upload. Archive built at: #{ipa_path}")
    end
  end

  desc "Deliver metadata/screenshots to App Store (no auto-submit)"
  lane :release do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist before attempting delivery
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("üì∏ Using framed screenshots from: #{delivery_path}")

    deliver(
      api_key: api_key,
      screenshots_path: delivery_path,
      skip_screenshots: false,
      overwrite_screenshots: true,
      skip_binary_upload: true,
      submit_for_review: false,
      force: true
    )
  end

  desc "Dry-run: Verify framed screenshots would be detected by deliver (no upload)"
  lane :release_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("üì∏ Verifying screenshots prepared for delivery from: #{delivery_path}")
    
    # List what deliver would find
    locales = %w[en-US fi]
    locales.each do |locale|
      locale_path = File.join(delivery_path, locale)
      if Dir.exist?(locale_path)
        screenshots = Dir.glob(File.join(locale_path, "*.png")).sort
        UI.header("#{locale} (#{screenshots.count} screenshots)")
        screenshots.each do |shot|
          basename = File.basename(shot)
          size = `identify -format '%wx%h' "#{shot}"`.strip rescue "unknown"
          UI.message("  #{basename} (#{size})")
        end
      else
        UI.error("Missing locale directory: #{locale_path}")
      end
    end
    
    UI.success("‚úÖ Framed screenshots are ready for delivery")
    UI.message("üí° Run 'bundle exec fastlane release' to upload to App Store Connect")
  end

  desc "Validate App Store Connect auth via API key (no uploads)"
  lane :asc_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # This will authenticate and fetch app metadata without uploading anything
    deliver(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_binary_upload: true,
      submit_for_review: false,
      run_precheck_before_submit: false,  # Precheck doesn't work with API keys
      force: true
    )
  end

  # Version management lanes
  
  desc "Show current version from all targets"
  lane :show_version do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.header("üì¶ Version Information")
    
    # Read from version file
    file_version = VersionHelper.read_version
    UI.message("Version file (.version): #{file_version}")
    
    # Read from git tag (if available)
    git_version = VersionHelper.version_from_git_tag
    UI.message("Latest git tag: #{git_version || 'none'}") if git_version
    
    # Read from Xcode project
    UI.message("\nXcode Project Versions:")
    targets = ['ListAll', 'ListAllWatch Watch App']
    targets.each do |target|
      begin
        version = get_version_number(
          xcodeproj: xcodeproj_path,
          target: target
        )
        build = get_build_number(xcodeproj: xcodeproj_path)
        UI.message("  #{target}: #{version} (#{build})")
      rescue => e
        UI.error("  #{target}: Error - #{e.message}")
      end
    end
    
    # Validate consistency
    UI.message("\n")
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("‚úÖ All versions are consistent")
    else
      UI.error("‚ùå Version mismatch detected")
    end
  end
  
  desc "Manually set version number"
  desc "Usage: fastlane set_version version:1.2.0"
  lane :set_version do |options|
    unless options[:version]
      UI.user_error!("Please specify version with version:X.Y.Z")
    end
    
    version = options[:version]
    
    # Validate semantic version format
    unless version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Version must be in format X.Y.Z (e.g., 1.2.0)")
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.important("üì¶ Setting version to: #{version}")
    
    # Update version in all targets
    VersionHelper.update_xcodeproj_version(xcodeproj_path, version)
    
    # Save to version file
    VersionHelper.write_version(version)
    
    # Validate
    unless VersionHelper.validate_versions(xcodeproj_path)
      UI.user_error!("Version validation failed")
    end
    
    UI.success("‚úÖ Version set to #{version}")
    UI.message("üí° Don't forget to commit the changes and create a git tag:")
    UI.message("   git add .version ListAll/ListAll.xcodeproj/project.pbxproj")
    UI.message("   git commit -m 'Bump version to #{version}'")
    UI.message("   git tag v#{version}")
    UI.message("   git push origin main --tags")
  end
  
  desc "Validate that all targets have matching versions"
  lane :validate_versions do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("‚úÖ All versions are valid and consistent")
    else
      UI.user_error!("‚ùå Version validation failed")
    end
  end
  
  desc "Generate screenshots for App Store"
  desc "Runs automated UI tests to capture screenshots for all configured devices and locales"
  lane :screenshots do
    # Capture screenshots using the snapshot tool
    snapshot
    
    UI.success("‚úÖ Screenshots generated successfully")
    UI.message("üìÅ Screenshots saved to: fastlane/screenshots")
  end

  desc "Unified App Store screenshot generation pipeline"
  desc "Generates all screenshots (iPhone, iPad, Watch) with validation and fail-fast checks"
  desc "This is the main entry point for CI/CD pipelines"
  lane :prepare_appstore do
    UI.header("üöÄ Starting App Store Screenshot Generation Pipeline")
    
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']
    
    begin
      # 1. Generate iPhone and iPad screenshots (with framing)
      UI.header("Step 1/2: Generating iPhone and iPad screenshots")
      screenshots_framed
      
      # 2. Generate Watch screenshots
      UI.header("Step 2/2: Generating Watch screenshots")
      watch_screenshots
      
      # 3. Final validation: ensure all expected screenshots exist
      UI.header("Final Validation: Verifying all screenshots were generated")
      validate_delivery_screenshots
      
      UI.success("üéâ App Store screenshot generation pipeline completed successfully!")
      UI.message("üìÅ All screenshots ready in: fastlane/screenshots/framed/")
      UI.message("   - iPhone/iPad: Framed screenshots")
      UI.message("   - Watch: Normalized screenshots (unframed)")
      
    rescue => e
      UI.error("‚ùå Pipeline failed: #{e.message}")
      UI.error("Stack trace: #{e.backtrace.join("\n")}")
      raise
    end
  end

  desc "Generate and frame screenshots (snapshot + frameit)"
  lane :screenshots_framed do
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']
    
    # Shared derived data path for prebuild and snapshot
    derived = "./fastlane/derivedDataSnapshot"
    
    # 0. ONE-TIME BUILD-FOR-TESTING
    # Build once, then snapshot reuses these compiled products for all devices/languages
    # This prevents rebuilding 4x (2 devices √ó 2 languages), saving 10-15 minutes
    UI.header("Building app and UI tests once for all snapshot runs")
    scan(
      scheme: "ListAll",
      project: "./ListAll/ListAll.xcodeproj",
      devices: ["iPhone 16 Pro Max"],  # Any device; we only need to populate DerivedData
      clean: true,
      build_for_testing: true,
      # Note: build_for_testing and test_without_building are mutually exclusive
      # build_for_testing means: build only, don't run tests
      # We need to build UI tests for snapshot, so don't use skip_testing here
      derived_data_path: derived,
      xcargs: "ONLY_ACTIVE_ARCH=YES CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO"
    )
    
    # 1. Raw screenshots using pre-built products
    # Run snapshot per device/language combination for incremental verification
    # This provides immediate feedback instead of waiting 30+ minutes
    screenshots_dir = File.expand_path("screenshots", __dir__)
    devices = ["iPhone 16 Pro Max", "iPad Pro 13-inch (M4)"]
    locales = %w[en-US fi]
    
    # Track expected screenshots (5 per test method √ó 2 test methods = 10 per device/locale)
    expected_per_combination = 10
    
    # Set environment variable to reduce simulator boot wait time (default is 120s)
    # This significantly speeds up failure detection - fail fast if simulators are slow
    ENV['SNAPSHOT_SIMULATOR_WAIT_FOR_BOOT_TIMEOUT'] = '30'
    
    # CRITICAL: Set SIMULATOR_HOST_HOME environment variable for SnapshotHelper
    # SnapshotHelper requires this to find the cache directory where screenshots are saved
    # Fastlane snapshot should set this automatically, but with test_without_building it may not work
    simulator_host_home = ENV['HOME'] || Dir.home
    ENV['SIMULATOR_HOST_HOME'] = simulator_host_home
    UI.message("üîß Setting SIMULATOR_HOST_HOME=#{simulator_host_home} for SnapshotHelper")
    
    devices.each_with_index do |device, device_idx|
      locales.each_with_index do |locale, locale_idx|
        is_first = device_idx == 0 && locale_idx == 0
        UI.header("üì∏ Generating screenshots for #{device} (#{locale})")
        
        # Run snapshot for this specific device/language combination
        # Only clear screenshots on first run, then append
        # CRITICAL FIX: Enable result_bundle to get better debugging and screenshot extraction
        # When using test_without_building, log parsing may not capture NSLog output properly
        # result_bundle provides a reliable way to extract screenshots and debug test execution
        result_bundle_path = File.join(screenshots_dir, "test_output", locale, "ListAll.xcresult")
        FileUtils.mkdir_p(File.dirname(result_bundle_path)) unless File.directory?(File.dirname(result_bundle_path))
        
        # CRITICAL: Set NSUnbufferedIO=YES to ensure xcodebuild outputs logs in correct order
        # This is especially important in CI environments where log buffering can cause issues
        # Research shows this is essential for proper log capture with test_without_building
        # Set as environment variable so xcodebuild inherits it (snapshot doesn't support xcodebuild_command parameter)
        ENV['NSUnbufferedIO'] = 'YES'
        
        # CRITICAL: Ensure SIMULATOR_HOST_HOME is set so SnapshotHelper can find the cache directory
        # This is essential for screenshot saving in CI environments
        # When using test_without_building, we need to pass this through xcodebuild's environment
        simulator_host_home = ENV['SIMULATOR_HOST_HOME'] || ENV['HOME'] || Dir.home
        ENV['SIMULATOR_HOST_HOME'] = simulator_host_home
        UI.message("üîß Setting SIMULATOR_HOST_HOME=#{simulator_host_home} for SnapshotHelper")
        
        # CRITICAL FIX: Set SIMULATOR_DEVICE_NAME explicitly so SnapshotHelper can save screenshots with correct filename
        # Fastlane snapshot normally sets this, but with test_without_building it may not work correctly
        # Device name format: Remove spaces and special characters (e.g., "iPhone 16 Pro Max" -> "iPhone16ProMax")
        device_name_sanitized = device.gsub(/[^a-zA-Z0-9]/, "")
        ENV['SIMULATOR_DEVICE_NAME'] = device_name_sanitized
        UI.message("üîß Setting SIMULATOR_DEVICE_NAME=#{device_name_sanitized} for SnapshotHelper")
        
        # CRITICAL: Fastlane snapshot should automatically pass environment variables to the test process
        # We've set ENV['SIMULATOR_HOST_HOME'] and ENV['SIMULATOR_DEVICE_NAME'] above, which should be inherited by xcodebuild and the test process
        # However, if this doesn't work, SnapshotHelper has fallback logic to use HOME or NSHomeDirectory()
        # Note: We can't use xcodebuild_command (not supported by snapshot action), so we rely on Fastlane's automatic passing
        
        # CRITICAL DIAGNOSTICS: Log environment variables before snapshot runs
        UI.message("üîç DIAGNOSTICS: Environment variables before snapshot:")
        UI.message("   SIMULATOR_HOST_HOME=#{ENV['SIMULATOR_HOST_HOME']}")
        UI.message("   SIMULATOR_DEVICE_NAME=#{ENV['SIMULATOR_DEVICE_NAME']}")
        UI.message("   HOME=#{ENV['HOME']}")
        UI.message("   FASTLANE_SNAPSHOT=#{ENV['FASTLANE_SNAPSHOT']}")
        UI.message("   FASTLANE_LANGUAGE=#{ENV['FASTLANE_LANGUAGE']}")
        
        # CRITICAL: Verify cache directory exists and is writable
        cache_dir_to_check = File.join(simulator_host_home, "Library/Caches/tools.fastlane")
        screenshots_dir_to_check = File.join(cache_dir_to_check, "screenshots")
        UI.message("üîç DIAGNOSTICS: Cache directory verification:")
        UI.message("   Cache dir: #{cache_dir_to_check}")
        UI.message("   Cache dir exists: #{Dir.exist?(cache_dir_to_check)}")
        UI.message("   Screenshots dir: #{screenshots_dir_to_check}")
        UI.message("   Screenshots dir exists: #{Dir.exist?(screenshots_dir_to_check)}")
        
        # Ensure cache directory exists and is writable
        begin
          FileUtils.mkdir_p(screenshots_dir_to_check) unless Dir.exist?(screenshots_dir_to_check)
          test_file = File.join(screenshots_dir_to_check, ".test_write")
          File.write(test_file, "test")
          File.delete(test_file)
          UI.message("   ‚úÖ Cache directory is writable")
        rescue => e
          UI.error("   ‚ùå Cache directory is NOT writable: #{e.message}")
        end
        
        # CRITICAL FIX: Manually create Fastlane cache files that SnapshotHelper expects
        # Fastlane snapshot normally creates these files, but with test_without_building it may not
        # SnapshotHelper reads: language.txt, locale.txt, snapshot-launch_arguments.txt
        UI.message("üîß Creating Fastlane cache files for SnapshotHelper...")
        begin
          # Create language.txt (e.g., "en-US" -> "en")
          language_code = locale.split("-").first
          language_file = File.join(cache_dir_to_check, "language.txt")
          File.write(language_file, language_code)
          UI.message("   ‚úÖ Created language.txt: #{language_code}")
          
          # Create locale.txt (e.g., "en-US")
          locale_file = File.join(cache_dir_to_check, "locale.txt")
          File.write(locale_file, locale)
          UI.message("   ‚úÖ Created locale.txt: #{locale}")
          
          # Create snapshot-launch_arguments.txt (can be empty, but file should exist)
          launch_args_file = File.join(cache_dir_to_check, "snapshot-launch_arguments.txt")
          File.write(launch_args_file, "") unless File.exist?(launch_args_file)
          UI.message("   ‚úÖ Created snapshot-launch_arguments.txt")
          
          # CRITICAL: Also create a file with SIMULATOR_DEVICE_NAME for SnapshotHelper to read
          # This is a workaround since environment variables may not be passed correctly
          device_name_file = File.join(cache_dir_to_check, "device_name.txt")
          File.write(device_name_file, device_name_sanitized)
          UI.message("   ‚úÖ Created device_name.txt: #{device_name_sanitized}")
          
        rescue => e
          UI.error("   ‚ùå Failed to create cache files: #{e.message}")
        end
        
        # CRITICAL FIX: Try passing environment variables via xcargs
        # xcargs allows passing build settings and environment variables to xcodebuild
        # Format: ENV_VAR_NAME=value
        xcargs_env = [
          "SIMULATOR_HOST_HOME=#{simulator_host_home}",
          "SIMULATOR_DEVICE_NAME=#{device_name_sanitized}",
          "NSUnbufferedIO=YES"
        ].join(" ")
        
        # Combine with existing xcargs from Snapfile (code signing settings)
        existing_xcargs = "CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO"
        combined_xcargs = "#{existing_xcargs} #{xcargs_env}"
        
        snapshot(
          derived_data_path: derived,
          test_without_building: true,
          devices: [device],
          languages: [locale],
          clear_previous_screenshots: is_first,  # Only clear on first run
          only_testing: ["ListAllUITests/testScreenshots01_WelcomeScreen", "ListAllUITests/testScreenshots02_MainFlow"],
          skip_testing: ["ListAllTests"],
          xcodebuild_formatter: "",  # Empty string disables formatter, allowing Fastlane to parse logs
          buildlog_path: "~/Library/Logs/snapshot",  # Explicit log path for better debugging
          # CRITICAL FIX: Pass environment variables via xcargs
          # Note: xcargs may not work for environment variables, but it's worth trying
          xcargs: combined_xcargs,
          # CRITICAL FIX: Enable result_bundle to extract screenshots from xcresult bundle
          # Log parsing mode (result_bundle: false) fails when using test_without_building because
          # NSLog output from the test process isn't captured in xcodebuild logs
          # Result bundle mode extracts screenshots directly from test attachments, which is more reliable
          result_bundle: true,
          # Other settings (override_status_bar, reinstall_app, etc.) come from Snapfile defaults
        )
        
        # CRITICAL DIAGNOSTICS: Verify environment variables after snapshot (they should still be set)
        UI.message("üîç DIAGNOSTICS: Environment variables after snapshot:")
        UI.message("   SIMULATOR_HOST_HOME=#{ENV['SIMULATOR_HOST_HOME']}")
        UI.message("   SIMULATOR_DEVICE_NAME=#{ENV['SIMULATOR_DEVICE_NAME']}")
        
        # CRITICAL FIX: Fastlane's log parsing often fails in CI environments where NSLog isn't captured
        # Manually extract screenshots from cache directory after tests complete
        # This bypasses Fastlane's log parsing entirely and works reliably
        UI.message("üîç Attempting manual screenshot extraction from cache directories...")
        locale_dir = File.join(screenshots_dir, locale)
        FileUtils.mkdir_p(locale_dir) unless File.directory?(locale_dir)
        extracted_count = 0
        
        # CRITICAL: Fastlane Snapshot saves screenshots to cache directory, but may not extract them
        # if log parsing fails. We need to manually find and copy them.
        # Screenshots are saved as: <simulator-name>-<screenshot-name>.png
        # e.g., "iPhone16ProMax-01-WelcomeScreen.png"
        
        # Method 1: Extract from result bundle (result_bundle is now enabled)
        # CRITICAL FIX: Extract screenshots from xcresult bundle attachments
        # XCTest attachments are the most reliable way to get screenshots when using test_without_building
        # Check multiple possible result bundle locations
        possible_result_bundles = [
          result_bundle_path,  # Our custom path
          File.join(screenshots_dir, locale, "ListAll.xcresult"),  # Fastlane default
          File.join(screenshots_dir, "ListAll.xcresult"),  # Alternative default
        ]
        
        # Also check in derived data for result bundles
        if derived && Dir.exist?(derived)
          possible_result_bundles += Dir.glob(File.join(derived, "**", "*.xcresult")).select { |f| File.directory?(f) }
        end
        
        result_bundle_to_check = possible_result_bundles.find { |path| File.exist?(path) }
        
        if result_bundle_to_check
          UI.message("   ‚úÖ Found result bundle: #{result_bundle_to_check}")
          
          # Method 1a: Use xcresulttool to extract attachments (most reliable)
          # CRITICAL: This extracts XCTest attachments which we're now using as backup
          begin
            attachments_dir = File.join(locale_dir, "attachments")
            FileUtils.mkdir_p(attachments_dir) unless File.directory?(attachments_dir)
            
            # Try multiple xcresulttool command variations
            # NOTE: The plugin doesn't have a direct attachments action, so we use the generic xcresulttool action
            attachments_output = nil
            success = false
            
            # CRITICAL FIX: Use correct modern API command
            # The correct command is "export attachments" not just "attachments"
            # This is part of the modern API and is more reliable
            attachments_output = `xcrun xcresulttool export attachments --path "#{result_bundle_to_check}" --output-path "#{attachments_dir}" 2>&1`
            if $?.success?
              success = true
              UI.message("   ‚úÖ Modern export attachments API succeeded")
              # Check if manifest.json was created (indicates successful extraction)
              manifest_path = File.join(attachments_dir, "manifest.json")
              if File.exist?(manifest_path)
                UI.message("   ‚úÖ Attachment manifest created - checking contents...")
                begin
                  require 'json'
                  manifest_content = File.read(manifest_path)
                  UI.message("   üìÑ Manifest file size: #{manifest_content.length} bytes")
                  manifest_data = JSON.parse(manifest_content)
                  
                  # Check different possible structures
                  attachments = nil
                  if manifest_data.is_a?(Array)
                    attachments = manifest_data
                    UI.message("   üìã Manifest is an array with #{attachments.count} item(s)")
                  elsif manifest_data.is_a?(Hash)
                    if manifest_data['attachments'] && manifest_data['attachments'].is_a?(Array)
                      attachments = manifest_data['attachments']
                    elsif manifest_data['tests'] && manifest_data['tests'].is_a?(Array)
                      # Manifest might be organized by tests
                      attachments = []
                      manifest_data['tests'].each do |test|
                        if test['attachments'] && test['attachments'].is_a?(Array)
                          attachments.concat(test['attachments'])
                        end
                      end
                    end
                    UI.message("   üìã Manifest is a hash, found #{attachments ? attachments.count : 0} attachment(s)")
                  end
                  
                  if attachments && attachments.any?
                    UI.message("   üìã Total attachments found: #{attachments.count}")
                    attachments.first(10).each do |att|
                      if att.is_a?(Hash)
                        UI.message("     - #{att['filename'] || att['name'] || 'unnamed'} (#{att['type'] || att['contentType'] || 'unknown type'})")
                      else
                        UI.message("     - #{att.inspect}")
                      end
                    end
                    if attachments.count > 10
                      UI.message("     ... (#{attachments.count - 10} more)")
                    end
                  else
                    UI.message("   ‚ö†Ô∏è  Manifest exists but no attachments found")
                    if manifest_data.is_a?(Hash)
                      UI.message("   üìÑ Manifest structure: #{manifest_data.keys.join(', ')}")
                    end
                  end
                rescue JSON::ParserError => e
                  UI.message("   ‚ö†Ô∏è  JSON parse error: #{e.message}")
                  UI.message("   üìÑ First 200 chars of manifest: #{File.read(manifest_path)[0..200]}")
                rescue => e
                  UI.message("   ‚ö†Ô∏è  Could not parse manifest.json: #{e.message}")
                  UI.message("   üìÑ Error class: #{e.class}")
                  UI.message("   üìÑ Backtrace: #{e.backtrace.first(3).join("\n")}")
                end
              end
            else
              UI.message("   ‚ö†Ô∏è  export attachments failed: #{attachments_output.chomp}")
            end
            
            if !success
              # Try 3: Direct file system search for PNG files in result bundle
              UI.message("   ‚ö†Ô∏è  export attachments failed, searching result bundle file system for PNGs...")
              
              # CRITICAL: Search result bundle directory structure directly for PNG files
              # XCTest attachments are stored in the bundle, we can find them by searching
              if Dir.exist?(result_bundle_to_check)
                # Search for PNG files recursively in result bundle
                png_files_in_bundle = Dir.glob(File.join(result_bundle_to_check, "**", "*.{png,PNG}"))
                if png_files_in_bundle.any?
                  UI.message("   ‚úÖ Found #{png_files_in_bundle.count} PNG files in result bundle!")
                  png_files_in_bundle.each do |png_path|
                    basename = File.basename(png_path)
                    # Extract screenshot name from filename (remove device prefix if present)
                    screenshot_name = basename
                    if basename.include?("-")
                      parts = basename.split("-", 2)
                      if parts.length == 2 && (parts[0].include?("iPhone") || parts[0].include?("iPad"))
                        screenshot_name = parts[1] # Use just the screenshot name part
                      end
                    end
                    dst = File.join(locale_dir, screenshot_name)
                    unless File.exist?(dst)
                      FileUtils.cp(png_path, dst)
                      extracted_count += 1
                      UI.message("   ‚úÖ Extracted screenshot from bundle: #{screenshot_name}")
                    end
                  end
                else
                  UI.message("   ‚ö†Ô∏è  No PNG files found in result bundle file system")
                end
              end
            end
            
            # Check if attachments were extracted
            if Dir.exist?(attachments_dir)
              # Recursively search for PNG files
              png_files = Dir.glob(File.join(attachments_dir, "**", "*.{png,PNG}"))
              
              if png_files.any?
                UI.message("   ‚úÖ Found #{png_files.count} PNG files in result bundle attachments")
                
                png_files.each do |src|
                  # Extract meaningful filename from path or use basename
                  basename = File.basename(src)
                  
                  # Try to extract screenshot name from path if it contains test/screenshot info
                  # Screenshot names from SnapshotHelper are like: "iPhone16ProMax-01-WelcomeScreen.png"
                  # or they might be in subdirectories with test names
                  dst = File.join(locale_dir, basename)
                  
                  # If file already exists, try to extract a better name from the path
                  if File.exist?(dst)
                    path_parts = src.split(File::SEPARATOR)
                    # Look for parts that might contain screenshot names (e.g., "01-WelcomeScreen")
                    screenshot_name = path_parts.find { |p| p.match?(/^\d{2}-|screenshot|snapshot/i) } || basename
                    dst = File.join(locale_dir, screenshot_name)
                  end
                  
                  FileUtils.cp(src, dst) unless File.exist?(dst)
                  extracted_count += 1
                  UI.message("   ‚úÖ Extracted: #{File.basename(dst)}")
                end
                
                # Clean up
                FileUtils.rm_rf(attachments_dir)
              else
                UI.message("   ‚ö†Ô∏è  No PNG files found in attachments directory")
                # List what files were found for debugging
                all_files = Dir.glob(File.join(attachments_dir, "**", "*")).select { |f| File.file?(f) }
                if all_files.any?
                  UI.message("   Found #{all_files.count} files total, first 10: #{all_files.first(10).map { |f| File.basename(f) }.join(", ")}")
                end
                # Don't clean up yet - we'll check cache directories next
              end
            else
              UI.message("   ‚ö†Ô∏è  Attachments directory not created - attachments command may have failed")
              if attachments_output && !attachments_output.empty?
                UI.message("   Error output: #{attachments_output.chomp}")
              end
            end
          rescue => e
            UI.message("   ‚ö†Ô∏è  Error using xcresulttool: #{e.message}")
            UI.message("   Backtrace: #{e.backtrace.first(3).join("\n")}")
          end
          
          # Method 1b: Direct file system access (fallback)
          # Check multiple possible attachment locations in result bundle
          possible_attachment_dirs = [
            File.join(result_bundle_to_check, "Attachments"),
            File.join(result_bundle_to_check, "Data", "Attachments"),
            File.join(result_bundle_to_check, "TestSummaries.plist") # Sometimes attachments are referenced here
          ]
          
          possible_attachment_dirs.each do |attachments_dir|
            if Dir.exist?(attachments_dir)
              UI.message("   Checking attachments directory: #{attachments_dir}")
              # Find all PNG attachments (case-insensitive)
              png_files = Dir.glob(File.join(attachments_dir, "**", "*.{png,PNG}"))
              if png_files.any?
                UI.message("   Found #{png_files.count} PNG files in #{attachments_dir}")
                png_files.each do |src|
                  basename = File.basename(src)
                  dst = File.join(locale_dir, basename)
                  FileUtils.cp(src, dst) unless File.exist?(dst)
                  extracted_count += 1
                  UI.message("   ‚úÖ Extracted: #{basename}")
                end
              end
            end
          end
          
          # Also check if result bundle has a Data directory structure
          data_dir = File.join(result_bundle_to_check, "Data")
          if Dir.exist?(data_dir)
            UI.message("   Exploring result bundle Data directory structure...")
            # List top-level directories
            Dir.entries(data_dir).each do |entry|
              next if entry.start_with?(".")
              entry_path = File.join(data_dir, entry)
              if File.directory?(entry_path)
                UI.message("     Found directory: #{entry}")
                # Check for PNG files recursively
                png_files = Dir.glob(File.join(entry_path, "**", "*.{png,PNG}"))
                if png_files.any?
                  UI.message("       Found #{png_files.count} PNG files in #{entry}")
                  png_files.each do |src|
                    basename = File.basename(src)
                    dst = File.join(locale_dir, basename)
                    FileUtils.cp(src, dst) unless File.exist?(dst)
                    extracted_count += 1
                    UI.message("       ‚úÖ Extracted: #{basename}")
                  end
                end
              end
            end
          end
          
          UI.message("   Extracted #{extracted_count} screenshots from result bundle (Method 1b)") if extracted_count > 0
        else
          UI.message("   ‚ö†Ô∏è  Result bundle not found at: #{result_bundle_to_check} (Fastlane should have extracted screenshots automatically)")
        end
        
        # Method 2: Extract from simulator cache directory (SnapshotHelper saves here)
        # CRITICAL: Check multiple possible locations for cache directory
        # In CI, the simulator may run in a different context than the runner
        # Based on research: SnapshotHelper saves to Library/Caches/tools.fastlane/screenshots
        # relative to SIMULATOR_HOST_HOME, HOME, or simulator's data directory
        possible_cache_dirs = []
        
        # CRITICAL: Use the same SIMULATOR_HOST_HOME that we set above (PRIMARY LOCATION)
        # This ensures we're checking the exact location where SnapshotHelper will save screenshots
        simulator_host_home_for_check = simulator_host_home || ENV['SIMULATOR_HOST_HOME'] || ENV['HOME'] || Dir.home
        if simulator_host_home_for_check
          primary_cache_dir = File.join(simulator_host_home_for_check, "Library/Caches/tools.fastlane/screenshots")
          possible_cache_dirs << primary_cache_dir
          UI.message("   üîç Primary cache directory to check: #{primary_cache_dir}")
        end
        
        # Also try ENV['SIMULATOR_HOST_HOME'] directly (in case it was set differently)
        if ENV['SIMULATOR_HOST_HOME'] && ENV['SIMULATOR_HOST_HOME'] != simulator_host_home_for_check
          possible_cache_dirs << File.join(ENV['SIMULATOR_HOST_HOME'], "Library/Caches/tools.fastlane/screenshots")
        end
        
        # Try HOME environment variable - FALLBACK FOR CI
        if ENV['HOME']
          possible_cache_dirs << File.join(ENV['HOME'], "Library/Caches/tools.fastlane/screenshots")
        end
        
        # Try runner's home directory (CI context - GitHub Actions)
        if ENV['RUNNER_HOME']
          possible_cache_dirs << File.join(ENV['RUNNER_HOME'], "Library/Caches/tools.fastlane/screenshots")
        end
        
        # Try current user's home - LOCAL DEVELOPMENT
        possible_cache_dirs << File.join(Dir.home, "Library/Caches/tools.fastlane/screenshots")
        
        # Try simulator's actual data directory (extract from simulator info)
        # Research shows: Simulator data is in ~/Library/Developer/CoreSimulator/Devices/<UUID>/data
        begin
          simulator_info = `xcrun simctl list devices --json 2>&1`
          if $?.success?
            require 'json'
            sim_data = JSON.parse(simulator_info)
            # Find the device we're using and get its data directory
            device_name = device.gsub(" ", "").gsub("-", "")
            sim_data['devices'].each do |runtime, devices|
              devices.each do |sim|
                if sim['name'] == device || sim['name'].include?(device_name)
                  if sim['dataPath']
                    # Simulator's data directory - screenshots might be in Library/Caches
                    possible_cache_dirs << File.join(sim['dataPath'], "Library/Caches/tools.fastlane/screenshots")
                    # Also check simulator's home directory (if different from dataPath)
                    sim_home = File.join(sim['dataPath'], "Library")
                    possible_cache_dirs << File.join(sim_home, "Caches/tools.fastlane/screenshots")
                  end
                end
              end
            end
          end
        rescue => e
          UI.message("   ‚ö†Ô∏è  Could not extract simulator data path: #{e.message}")
        end
        
        # Research-based additional locations:
        # 1. Derived Data Attachments folder (xcodebuild may save screenshots here)
        if derived && Dir.exist?(derived)
          # Check for attachments in test logs
          possible_cache_dirs << File.join(derived, "Logs/Test/Attachments")
          # Check for screenshots in test output
          possible_cache_dirs << File.join(derived, "Logs/Test/screenshots")
        end
        
        # 2. Default Xcode Derived Data location
        default_derived_data = File.expand_path("~/Library/Developer/Xcode/DerivedData")
        if Dir.exist?(default_derived_data)
          # Search in all project folders (pattern: ProjectName-RandomString)
          Dir.glob(File.join(default_derived_data, "*/Logs/Test/Attachments")).each do |path|
            possible_cache_dirs << path
          end
        end
        
        # 3. Simulator media directory (screenshots might be saved here)
        simulator_media_base = File.expand_path("~/Library/Developer/CoreSimulator/Devices")
        if Dir.exist?(simulator_media_base)
          # Check all simulator devices for media/screenshots
          Dir.glob(File.join(simulator_media_base, "*/data/Media/DCIM")).each do |path|
            possible_cache_dirs << path
          end
        end
        
        # Method 2a: Check for SnapshotHelper debug log file and marker files
        # SnapshotHelper writes a debug log file and marker files to verify snapshot() calls
        # CRITICAL: Check ALL possible cache directories, including simulator-specific ones
        possible_cache_dirs_for_log = []
        if ENV['SIMULATOR_HOST_HOME']
          possible_cache_dirs_for_log << File.join(ENV['SIMULATOR_HOST_HOME'], "Library/Caches/tools.fastlane")
        end
        if ENV['HOME']
          possible_cache_dirs_for_log << File.join(ENV['HOME'], "Library/Caches/tools.fastlane")
        end
        possible_cache_dirs_for_log << File.join(Dir.home, "Library/Caches/tools.fastlane")
        
        # Also check /tmp for marker files (fallback location)
        possible_cache_dirs_for_log << "/tmp"
        
        # Also check simulator-specific cache directories (extract base from possible_cache_dirs)
        possible_cache_dirs.each do |cache_dir|
          # Extract base cache directory (parent of "screenshots")
          if cache_dir.include?("screenshots")
            base_cache = File.dirname(cache_dir)
            possible_cache_dirs_for_log << base_cache if base_cache
          end
        end
        
        # CRITICAL: Also check simulator's actual data directory for debug log
        # SnapshotHelper may write to /tmp or simulator's document directory as fallback
        possible_cache_dirs_for_log << "/tmp"
        
       # CRITICAL: Check for setupSnapshot verification marker and failure markers
       # These are written to cache directory (primary) and /tmp (fallback) by the test code
       # CRITICAL FIX: Check cache directory first, as /tmp may be process-specific in CI
       cache_dir_to_check = File.join(simulator_host_home, "Library/Caches/tools.fastlane")
       setup_verification_marker_cache = File.join(cache_dir_to_check, "setupSnapshot_verification.txt")
       setup_failed_marker_cache = File.join(cache_dir_to_check, "snapshot_setup_failed.txt")
       setup_verification_marker_tmp = "/tmp/setupSnapshot_verification.txt"
       setup_failed_marker_tmp = "/tmp/snapshot_setup_failed.txt"
       
       # CRITICAL: Check for execution flow markers to see exactly where tests stop
       # Also check simulator-specific cache directories since tests run in simulator
       simulator_cache_dirs = []
       # Check all simulator devices (we don't know the exact simulator ID, so check all)
       simulator_devices_dir = File.join(ENV['HOME'] || Dir.home, "Library/Developer/CoreSimulator/Devices")
       if Dir.exist?(simulator_devices_dir)
         Dir.glob(File.join(simulator_devices_dir, "*/data/Library/Caches/tools.fastlane")).each do |sim_cache|
           simulator_cache_dirs << sim_cache
         end
       end
       
       # Check cache directory first (more reliable in CI)
       # Also check simulator-specific cache directories
       setup_failed_marker = setup_failed_marker_cache
       setup_verification_marker = setup_verification_marker_cache
       
       if !File.exist?(setup_failed_marker_cache) && !File.exist?(setup_verification_marker_cache)
         # Check simulator cache directories
         simulator_cache_dirs.each do |sim_cache|
           sim_failed = File.join(sim_cache, "snapshot_setup_failed.txt")
           sim_verification = File.join(sim_cache, "setupSnapshot_verification.txt")
           if File.exist?(sim_failed)
             setup_failed_marker = sim_failed
             UI.message("   ‚úÖ Found setup failed marker in simulator cache: #{sim_cache}")
           end
           if File.exist?(sim_verification)
             setup_verification_marker = sim_verification
             UI.message("   ‚úÖ Found setup verification marker in simulator cache: #{sim_cache}")
           end
         end
       end
       
       # Fallback to /tmp if not found in cache directories
       setup_failed_marker = setup_failed_marker_tmp if !File.exist?(setup_failed_marker) && File.exist?(setup_failed_marker_tmp)
       setup_verification_marker = setup_verification_marker_tmp if !File.exist?(setup_verification_marker) && File.exist?(setup_verification_marker_tmp)
       
       pre_setup_marker = File.join(cache_dir_to_check, "pre_setupSnapshot_marker.txt")
       post_setup_marker = File.join(cache_dir_to_check, "post_setupSnapshot_marker.txt")
       pre_snapshot_markers = Dir.glob(File.join(cache_dir_to_check, "pre_snapshot_*.txt"))
       post_snapshot_markers = Dir.glob(File.join(cache_dir_to_check, "post_snapshot_*.txt"))
       
       # Also check simulator cache directories
       simulator_cache_dirs.each do |sim_cache|
         pre_setup_marker_sim = File.join(sim_cache, "pre_setupSnapshot_marker.txt")
         post_setup_marker_sim = File.join(sim_cache, "post_setupSnapshot_marker.txt")
         pre_snapshot_markers_sim = Dir.glob(File.join(sim_cache, "pre_snapshot_*.txt"))
         post_snapshot_markers_sim = Dir.glob(File.join(sim_cache, "post_snapshot_*.txt"))
         
         if File.exist?(pre_setup_marker_sim)
           pre_setup_marker = pre_setup_marker_sim
           UI.message("   ‚úÖ Found pre_setupSnapshot_marker.txt in simulator cache: #{sim_cache}")
         end
         if File.exist?(post_setup_marker_sim)
           post_setup_marker = post_setup_marker_sim
           UI.message("   ‚úÖ Found post_setupSnapshot_marker.txt in simulator cache: #{sim_cache}")
         end
         pre_snapshot_markers.concat(pre_snapshot_markers_sim) if pre_snapshot_markers_sim.any?
         post_snapshot_markers.concat(post_snapshot_markers_sim) if post_snapshot_markers_sim.any?
       end
        
        UI.message("   üîç Execution flow markers:")
        if File.exist?(pre_setup_marker)
          UI.message("     ‚úÖ pre_setupSnapshot_marker.txt found - test code IS executing")
          UI.message("       Content: #{File.read(pre_setup_marker).chomp}")
        else
          UI.message("     ‚ùå pre_setupSnapshot_marker.txt NOT found - test code may not be executing")
        end
        
        if File.exist?(post_setup_marker)
          UI.message("     ‚úÖ post_setupSnapshot_marker.txt found - setupSnapshot() completed")
          UI.message("       Content: #{File.read(post_setup_marker).chomp}")
        else
          UI.message("     ‚ùå post_setupSnapshot_marker.txt NOT found - setupSnapshot() may not have completed")
        end
        
        if pre_snapshot_markers.any?
          UI.message("     ‚úÖ Found #{pre_snapshot_markers.count} pre_snapshot marker(s) - snapshot() calls are being reached")
          pre_snapshot_markers.each do |marker|
            UI.message("       #{File.basename(marker)}: #{File.read(marker).chomp}")
          end
        else
          UI.message("     ‚ùå No pre_snapshot markers found - snapshot() calls may not be reached")
        end
        
        if post_snapshot_markers.any?
          UI.message("     ‚úÖ Found #{post_snapshot_markers.count} post_snapshot marker(s) - snapshot() calls completed")
          post_snapshot_markers.each do |marker|
            UI.message("       #{File.basename(marker)}: #{File.read(marker).chomp}")
          end
        else
          UI.message("     ‚ùå No post_snapshot markers found - snapshot() calls may not be completing")
        end
        
        if File.exist?(setup_failed_marker)
          UI.error("   ‚ùå CRITICAL: Found setupSnapshot() failure marker!")
          UI.error("   Location: #{setup_failed_marker}")
          UI.error("   This means snapshot() was called but setupSnapshot() failed or wasn't called")
          failure_content = File.read(setup_failed_marker)
          UI.error("   Failure details: #{failure_content.chomp}")
        elsif File.exist?(setup_verification_marker)
          UI.message("   ‚úÖ Found setupSnapshot() verification marker")
          UI.message("   Location: #{setup_verification_marker}")
          verification_content = File.read(setup_verification_marker)
          UI.message("   Verification details:")
          verification_content.lines.each { |line| UI.message("     #{line.chomp}") }
        else
          UI.message("   ‚ö†Ô∏è  setupSnapshot() verification marker not found")
          UI.message("   Checked cache: #{setup_verification_marker_cache}")
          UI.message("   Checked /tmp: #{setup_verification_marker_tmp}")
        end
        begin
          simulator_info = `xcrun simctl list devices --json 2>&1`
          if $?.success?
            require 'json'
            sim_data = JSON.parse(simulator_info)
            device_name = device.gsub(" ", "").gsub("-", "")
            sim_data['devices'].each do |runtime, devices|
              devices.each do |sim|
                if sim['name'] == device || sim['name'].include?(device_name)
                  if sim['dataPath']
                    # Check simulator's data directory for cache
                    possible_cache_dirs_for_log << File.join(sim['dataPath'], "Library/Caches/tools.fastlane")
                    # Check simulator's document directory (fallback location)
                    possible_cache_dirs_for_log << File.join(sim['dataPath'], "Library/Application Support")
                  end
                end
              end
            end
          end
        rescue => e
          UI.message("   ‚ö†Ô∏è  Could not check simulator data paths for debug log: #{e.message}")
        end
        
        debug_log_found = false
        debug_log_path_found = nil
        marker_files_found = []
        
        possible_cache_dirs_for_log.uniq.each do |cache_base|
          # Check for debug log
          debug_log_path = File.join(cache_base, "snapshot_debug.log")
          if File.exist?(debug_log_path)
            debug_log_found = true
            debug_log_path_found = debug_log_path
            UI.message("   ‚úÖ Found SnapshotHelper debug log: #{debug_log_path}")
            debug_content = File.read(debug_log_path)
            snapshot_calls = debug_content.lines.select { |l| l.include?("snapshot:") }
            if snapshot_calls.any?
              UI.message("   ‚úÖ Debug log shows #{snapshot_calls.count} snapshot() calls were made")
              UI.message("   Last snapshot calls:")
              snapshot_calls.last(10).each { |line| UI.message("     #{line.chomp}") }
            else
              UI.message("   ‚ö†Ô∏è  Debug log exists but no snapshot() calls found")
            end
            UI.message("   Debug log content (last 20 lines):")
            debug_content.lines.last(20).each { |line| UI.message("     #{line.chomp}") }
          end
          
          # CRITICAL: Check for marker files (more reliable than log parsing)
          # Marker files are created immediately when snapshot() is called
          marker_pattern = File.join(cache_base, "snapshot_marker_*.txt")
          marker_files = Dir.glob(marker_pattern)
          if marker_files.any?
            marker_files_found += marker_files
            UI.message("   ‚úÖ Found #{marker_files.count} snapshot marker file(s) in #{cache_base}")
            marker_files.each do |marker_file|
              marker_content = File.read(marker_file)
              UI.message("     üìå #{File.basename(marker_file)}: #{marker_content.chomp}")
            end
          end
        end
        
        unless debug_log_found && marker_files_found.any?
          if !debug_log_found && marker_files_found.empty?
            UI.message("   ‚ö†Ô∏è  SnapshotHelper debug log and marker files not found - snapshot() may not be called")
          elsif marker_files_found.any?
            UI.message("   ‚úÖ Marker files found - snapshot() IS being called (even if log not found)")
          end
        end
        
        # Method 2b: Extract test activity logs from result bundle to check for NSLog output
        # CRITICAL DIAGNOSTICS: This helps verify if snapshot() is actually being called
        if File.exist?(result_bundle_to_check)
          begin
            UI.message("   üîç DIAGNOSTICS: Extracting test activity logs from result bundle...")
            UI.message("   Result bundle path: #{result_bundle_to_check}")
            
            # CRITICAL: Use xcresulttool to get test activity logs which contain NSLog/print output
            # First, get the root object to find test actions
            # NOTE: Using deprecated `get object --legacy` API because:
            # 1. Modern API (`get test-results`) requires different code structure
            # 2. Deprecated API still works and gives us full JSON structure we need
            # 3. Apple requires --legacy flag for deprecated APIs
            # TODO: Migrate to modern API (get test-results) in future refactoring
            root_output = `xcrun xcresulttool get object --legacy --format json --path "#{result_bundle_to_check}" 2>&1`
            if !$?.success?
              # Fallback: Try without --legacy (will likely fail, but worth trying)
              UI.message("   ‚ö†Ô∏è  Legacy API failed (exit code: #{$?.exitstatus}), trying without --legacy flag...")
              root_output = `xcrun xcresulttool get object --format json --path "#{result_bundle_to_check}" 2>&1`
              if !$?.success?
                UI.message("   ‚ö†Ô∏è  Non-legacy API also failed (exit code: #{$?.exitstatus})")
                UI.message("   Error output: #{root_output[0..500]}")
              end
            end
            
            if root_output && !root_output.empty? && ($?.nil? || $?.success?)
              UI.message("   ‚úÖ Successfully retrieved root object from result bundle")
              UI.message("   üìÑ Root output length: #{root_output.length} characters")
              require 'json'
              begin
                root_data = JSON.parse(root_output)
                UI.message("   ‚úÖ Successfully parsed root object JSON")
                
                # CRITICAL DIAGNOSTICS: Show actual structure of root object
                UI.message("   üîç Root object keys: #{root_data.keys.join(', ')}")
                UI.message("   üîç Root object type: #{root_data.class}")
                
                # Try different possible structures
                # Structure 1: root -> actions -> actionResult -> testsRef
                # Structure 2: root -> _type -> ActionsInvocationRecord (might need different navigation)
                # Structure 3: Modern API structure (different keys)
                
                # Check if it's an ActionsInvocationRecord type
                if root_data['_type'] && root_data['_type']['_name'] == 'ActionsInvocationRecord'
                  UI.message("   üìã Root object is ActionsInvocationRecord")
                  # ActionsInvocationRecord has 'actions' array
                  if root_data['actions'] && root_data['actions'].is_a?(Array)
                    UI.message("   ‚úÖ Found actions array in ActionsInvocationRecord")
                  else
                    UI.message("   ‚ö†Ô∏è  ActionsInvocationRecord has no actions array")
                    UI.message("   üîç Available keys in root: #{root_data.keys.join(', ')}")
                  end
                end
                
                # Navigate the JSON to find test actions and their activity logs
                # The structure is: root -> actions -> actionResult -> testsRef -> tests -> test -> activities
                if root_data['actions'] && root_data['actions'].is_a?(Array)
                  UI.message("   üìã Found #{root_data['actions'].count} action(s) in result bundle")
                  root_data['actions'].each_with_index do |action, action_idx|
                    UI.message("   üîç Processing action #{action_idx + 1}...")
                    if action['actionResult'] && action['actionResult']['testsRef']
                      tests_id = action['actionResult']['testsRef']['id']
                      UI.message("   ‚úÖ Found testsRef with ID: #{tests_id}")
                      
                      # Get the tests object - using deprecated API with --legacy flag
                      # See comment above for why we use legacy API
                      tests_output = `xcrun xcresulttool get object --legacy --format json --path "#{result_bundle_to_check}" --id "#{tests_id}" 2>&1`
                      if !$?.success?
                        tests_output = `xcrun xcresulttool get object --format json --path "#{result_bundle_to_check}" --id "#{tests_id}" 2>&1`
                      end
                      if tests_output && !tests_output.empty? && ($?.nil? || $?.success?)
                        tests_data = JSON.parse(tests_output)
                        UI.message("   ‚úÖ Successfully parsed tests object")
                        
                        # Navigate to find test activities
                        if tests_data['summaries'] && tests_data['summaries'].is_a?(Array)
                          UI.message("   üìã Found #{tests_data['summaries'].count} test summary(ies)")
                          tests_data['summaries'].each_with_index do |summary, summary_idx|
                            UI.message("   üîç Processing summary #{summary_idx + 1}...")
                            if summary['testRefs'] && summary['testRefs'].is_a?(Array)
                              UI.message("   üìã Found #{summary['testRefs'].count} test(s) in summary")
                              summary['testRefs'].each_with_index do |test_ref, test_idx|
                                test_id = test_ref['id']
                                UI.message("   üîç Processing test #{test_idx + 1} (ID: #{test_id})...")
                                
                                # Get the test object - using deprecated API with --legacy flag
                                # See comment above for why we use legacy API
                                test_output = `xcrun xcresulttool get object --legacy --format json --path "#{result_bundle_to_check}" --id "#{test_id}" 2>&1`
                                if !$?.success?
                                  test_output = `xcrun xcresulttool get object --format json --path "#{result_bundle_to_check}" --id "#{test_id}" 2>&1`
                                end
                                if test_output && !test_output.empty? && ($?.nil? || $?.success?)
                                  test_data = JSON.parse(test_output)
                                  UI.message("   ‚úÖ Successfully parsed test object")
                                  
                                  # Get test name if available
                                  test_name = test_data['identifier'] || test_data['name'] || "Unknown"
                                  UI.message("   üìù Test name: #{test_name}")
                                  
                                  # CRITICAL: Check if test failed
                                  if test_data['testStatus'] && test_data['testStatus'] != 'Success'
                                    UI.error("   ‚ùå Test status: #{test_data['testStatus']}")
                                    if test_data['failureSummaries'] && test_data['failureSummaries'].is_a?(Array)
                                      test_data['failureSummaries'].each do |failure|
                                        if failure['message']
                                          UI.error("   ‚ùå Test failure: #{failure['message']['values'].map { |v| v['text'] || v['value'] || '' }.join('')}")
                                        end
                                      end
                                    end
                                  else
                                    UI.message("   ‚úÖ Test status: Success")
                                  end
                                  
                                  # Check for activities with attachments or subactivities
                                  if test_data['activities'] && test_data['activities'].is_a?(Array)
                                    UI.message("   üîç Found #{test_data['activities'].count} activities for test")
                                    total_messages = 0
                                    total_attachments = 0
                                    test_data['activities'].each_with_index do |activity, activity_idx|
                                      # CRITICAL: Extract and display activity logs to see what's happening
                                      if activity['title']
                                        UI.message("   üìã Activity #{activity_idx + 1}: #{activity['title']}")
                                      end
                                      
                                      # Check for log messages in the activity (NSLog/print output)
                                      # CRITICAL DIAGNOSTICS: Extract ALL log messages to verify test execution
                                      if activity['messages'] && activity['messages'].is_a?(Array)
                                        message_count = activity['messages'].count
                                        total_messages += message_count
                                        UI.message("   üìù Found #{message_count} log message(s) in activity")
                                        snapshot_related_messages = []
                                        debug_messages = []
                                        all_messages = []
                                        
                                        activity['messages'].each do |message|
                                          if message['message'] && message['message']['values']
                                            message_text = message['message']['values'].map { |v| v['text'] || v['value'] || '' }.join('')
                                            all_messages << message_text
                                            
                                            # Categorize messages
                                            if message_text.include?('snapshot:') || message_text.include?('Snapshot.snapshot')
                                              snapshot_related_messages << message_text
                                            elsif message_text.include?('DEBUG') || message_text.include?('setupSnapshot')
                                              debug_messages << message_text
                                            end
                                          end
                                        end
                                        
                                        # Report findings
                                        if snapshot_related_messages.any?
                                          UI.message("   ‚úÖ Found #{snapshot_related_messages.count} snapshot-related messages:")
                                          snapshot_related_messages.each { |msg| UI.message("     üì∏ #{msg[0..150]}") }
                                        end
                                        
                                        if debug_messages.any?
                                          UI.message("   üîç Found #{debug_messages.count} debug messages:")
                                          debug_messages.first(5).each { |msg| UI.message("     üîß #{msg[0..150]}") }
                                        end
                                        
                                        # Show sample of all messages if no snapshot messages found
                                        if snapshot_related_messages.empty? && all_messages.any?
                                          UI.message("   ‚ö†Ô∏è  No snapshot-related messages found. Sample of messages:")
                                          all_messages.first(10).each { |msg| UI.message("     üìã #{msg[0..100]}") }
                                        end
                                      end
                                      
                                      # Check for attachments (screenshots)
                                      if activity['attachments'] && activity['attachments'].is_a?(Array)
                                        attachment_count = activity['attachments'].count
                                        total_attachments += attachment_count
                                        UI.message("   üìé Found #{attachment_count} attachment(s) in activity")
                                        activity['attachments'].each do |attachment|
                                          if attachment['filename'] && attachment['filename'].match?(/\.png$/i)
                                            UI.message("   ‚úÖ Found screenshot attachment: #{attachment['filename']}")
                                            # Extract the attachment
                                            if attachment['payloadRef'] && attachment['payloadRef']['id']
                                              attachment_id = attachment['payloadRef']['id']
                                              attachment_path = File.join(locale_dir, attachment['filename'])
                                              # Export attachment - use direct command since plugin export_items format may be wrong
                                              extract_output = `xcrun xcresulttool export --type file --path "#{result_bundle_to_check}" --id "#{attachment_id}" --output-path "#{attachment_path}" 2>&1`
                                              if File.exist?(attachment_path)
                                                extracted_count += 1
                                                UI.message("   ‚úÖ Extracted screenshot: #{attachment['filename']}")
                                              end
                                            end
                                          end
                                        end
                                      end
                                      
                                      # Check subactivities recursively
                                      if activity['subactivities'] && activity['subactivities'].is_a?(Array)
                                        activity['subactivities'].each do |subactivity|
                                          if subactivity['attachments'] && subactivity['attachments'].is_a?(Array)
                                            subactivity['attachments'].each do |attachment|
                                              if attachment['filename'] && attachment['filename'].match?(/\.png$/i)
                                                UI.message("   ‚úÖ Found screenshot in subactivity: #{attachment['filename']}")
                                                if attachment['payloadRef'] && attachment['payloadRef']['id']
                                                  attachment_id = attachment['payloadRef']['id']
                                                  attachment_path = File.join(locale_dir, attachment['filename'])
                                                  # Export attachment - use direct command since plugin export_items format may be wrong
                                                  extract_output = `xcrun xcresulttool export --type file --path "#{result_bundle_to_check}" --id "#{attachment_id}" --output-path "#{attachment_path}" 2>&1`
                                                  if File.exist?(attachment_path)
                                                    extracted_count += 1
                                                    UI.message("   ‚úÖ Extracted screenshot: #{attachment['filename']}")
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                    
                                    # Summary for this test
                                    UI.message("   üìä Test summary: #{total_messages} messages, #{total_attachments} attachments")
                                  else
                                    UI.message("   ‚ö†Ô∏è  No activities found for test")
                                  end
                                else
                                  UI.message("   ‚ö†Ô∏è  Failed to get test object (ID: #{test_id})")
                                  UI.message("   Error output: #{test_output[0..200]}")
                                end
                              end
                            else
                              UI.message("   ‚ö†Ô∏è  Summary has no testRefs")
                            end
                          end
                        else
                          UI.message("   ‚ö†Ô∏è  Tests object has no summaries")
                        end
                      else
                        UI.message("   ‚ö†Ô∏è  Failed to get tests object (ID: #{tests_id})")
                        UI.message("   Error output: #{tests_output[0..200]}")
                      end
                    else
                      UI.message("   ‚ö†Ô∏è  Action has no actionResult.testsRef")
                    end
                  end
                else
                  UI.message("   ‚ö†Ô∏è  Root object has no actions")
                  UI.message("   üîç Attempting alternative navigation methods...")
                  
                  # Try modern API approach: use get test-results directly
                  UI.message("   üîç Trying modern API: get test-results...")
                  modern_output = `xcrun xcresulttool get test-results --path "#{result_bundle_to_check}" --format json 2>&1`
                  if $?.success? && modern_output && !modern_output.empty?
                    UI.message("   ‚úÖ Modern API succeeded!")
                    begin
                      modern_data = JSON.parse(modern_output)
                      UI.message("   üìã Modern API keys: #{modern_data.keys.join(', ')}")
                      
                      # Modern API structure: { "testResults": { "tests": [...] } }
                      if modern_data['testResults'] && modern_data['testResults']['tests']
                        tests = modern_data['testResults']['tests']
                        UI.message("   üìã Found #{tests.count} test(s) via modern API")
                        tests.each do |test|
                          test_name = test['identifier'] || test['name'] || 'Unknown'
                          test_status = test['testStatus'] || 'Unknown'
                          UI.message("   üìù Test: #{test_name} - Status: #{test_status}")
                        end
                      end
                    rescue => e
                      UI.message("   ‚ö†Ô∏è  Failed to parse modern API output: #{e.message}")
                    end
                  else
                    UI.message("   ‚ö†Ô∏è  Modern API failed: #{modern_output[0..200]}")
                  end
                  
                  # Show sample of root object structure for debugging
                  UI.message("   üîç Root object sample (first level):")
                  root_data.keys.first(10).each do |key|
                    value = root_data[key]
                    value_type = value.class
                    value_preview = if value.is_a?(String)
                      value[0..50]
                    elsif value.is_a?(Array)
                      "Array[#{value.count}]"
                    elsif value.is_a?(Hash)
                      "Hash{#{value.keys.first(3).join(', ')}}"
                    else
                      value.inspect[0..50]
                    end
                    UI.message("     - #{key}: #{value_type} = #{value_preview}")
                  end
                end
              rescue JSON::ParserError => e
                UI.message("   ‚ö†Ô∏è  Failed to parse result bundle JSON: #{e.message}")
                UI.message("   Root output length: #{root_output.length} characters")
                UI.message("   Root output (first 500 chars): #{root_output[0..500]}")
                if root_output.length > 500
                  UI.message("   Root output (last 500 chars): #{root_output[-500..-1]}")
                end
              rescue => e
                UI.message("   ‚ö†Ô∏è  Error navigating result bundle structure: #{e.message}")
                UI.message("   Error class: #{e.class}")
                UI.message("   Backtrace: #{e.backtrace.first(5).join("\n")}")
              end
            else
              UI.message("   ‚ö†Ô∏è  Root object retrieval failed or returned empty")
              if $?
                UI.message("   Exit code: #{$?.exitstatus}")
              end
              UI.message("   Output length: #{root_output ? root_output.length : 0} characters")
              if root_output && !root_output.empty?
                UI.message("   Output (first 500 chars): #{root_output[0..500]}")
              end
              # Try to get basic info about the result bundle
              UI.message("   üîç Attempting to list result bundle contents...")
              if Dir.exist?(result_bundle_to_check)
                top_level = Dir.entries(result_bundle_to_check).reject { |e| e.start_with?(".") }
                UI.message("   Top-level contents: #{top_level.join(", ")}")
              end
              
              # CRITICAL DIAGNOSTICS: Try alternative method to extract test information
              # Use xcresulttool to get test summaries directly - use legacy API
              begin
                UI.message("   üîç Trying alternative method: xcresulttool get object --legacy --format json --id root...")
                alt_output = `xcrun xcresulttool get object --legacy --format json --path "#{result_bundle_to_check}" --id root 2>&1`
                if !$?.success?
                  alt_output = `xcrun xcresulttool get --format json --id root --path "#{result_bundle_to_check}" 2>&1`
                end
                if alt_output && !alt_output.empty? && ($?.nil? || $?.success?)
                  require 'json'
                  alt_data = JSON.parse(alt_output)
                  UI.message("   ‚úÖ Successfully parsed result bundle with alternative method")
                  # Try to find test information
                  if alt_data['actions']
                    UI.message("   Found #{alt_data['actions'].count} action(s)")
                  end
                else
                  UI.message("   ‚ö†Ô∏è  Alternative method also failed: #{alt_output[0..200]}")
                end
              rescue => e
                UI.message("   ‚ö†Ô∏è  Error with alternative method: #{e.message}")
              end
            end
          rescue => e
            UI.message("   ‚ö†Ô∏è  Error extracting test logs: #{e.message}")
            UI.message("   Backtrace: #{e.backtrace.first(3).join("\n")}")
          end
        end
        
        # Check all possible cache directories
        found_cache = false
        possible_cache_dirs.uniq.each do |cache_dir|
          UI.message("   Checking cache directory: #{cache_dir}")
          if Dir.exist?(cache_dir)
            found_cache = true
            UI.message("   ‚úÖ Cache directory exists: #{cache_dir}")
            
            # List all files in cache directory for debugging
            all_files = Dir.entries(cache_dir).reject { |f| f.start_with?(".") }
            if all_files.any?
              UI.message("   Files in cache directory (#{all_files.count}): #{all_files.first(10).join(", ")}")
            end
            
            # Check for debug log in this directory too
            debug_log_in_dir = File.join(File.dirname(cache_dir), "snapshot_debug.log")
            if File.exist?(debug_log_in_dir)
              UI.message("   ‚úÖ Found debug log in cache parent: #{debug_log_in_dir}")
              debug_content = File.read(debug_log_in_dir)
              snapshot_calls = debug_content.scan(/snapshot:/).count
              UI.message("   üìä Debug log shows #{snapshot_calls} snapshot() calls")
            end
            
            # Look for PNG files (case-insensitive, with various naming patterns)
            # CRITICAL: Use the same device name sanitization format as SnapshotHelper
            # This matches what we set in ENV['SIMULATOR_DEVICE_NAME'] above
            device_sanitized = device_name_sanitized || device.gsub(/[^a-zA-Z0-9]/, "")
            cache_screenshots = Dir.glob(File.join(cache_dir, "*.{png,PNG}"))
            # Also check for files that might have device name in them (exact match)
            cache_screenshots += Dir.glob(File.join(cache_dir, "#{device_sanitized}-*.png"))
            cache_screenshots += Dir.glob(File.join(cache_dir, "#{device_sanitized}-*.PNG"))
            # Fallback: check for any device name pattern
            cache_screenshots += Dir.glob(File.join(cache_dir, "*iPhone*.png"))
            cache_screenshots += Dir.glob(File.join(cache_dir, "*iPad*.png"))
            cache_screenshots.uniq!
            
            if cache_screenshots.any?
              UI.message("   ‚úÖ Found #{cache_screenshots.count} screenshots in cache directory")
              cache_screenshots.each do |src|
                basename = File.basename(src)
                # Remove device prefix if present (e.g., "iPhone16ProMax-01-WelcomeScreen.png" -> "01-WelcomeScreen.png")
                # Fastlane expects just the screenshot name
                if basename.include?("-")
                  # Try to extract just the screenshot name part
                  parts = basename.split("-", 2)
                  if parts.length == 2 && (parts[0].include?("iPhone") || parts[0].include?("iPad"))
                    basename = parts[1] # Use just the screenshot name part
                  end
                end
                dst = File.join(locale_dir, basename)
                unless File.exist?(dst)
                  FileUtils.cp(src, dst)
                  extracted_count += 1
                  UI.message("   ‚úÖ Copied: #{basename}")
                else
                  UI.message("   ‚è≠Ô∏è  Skipped (already exists): #{basename}")
                end
              end
              UI.message("   ‚úÖ Copied #{extracted_count} screenshots from cache")
              break # Found screenshots, no need to check other directories
            else
              UI.message("   ‚ö†Ô∏è  Cache directory exists but no screenshots found")
              # List what IS in the directory
              if all_files.any?
                UI.message("   Directory contents: #{all_files.join(", ")}")
              end
            end
          else
            UI.message("   ‚ö†Ô∏è  Cache directory does not exist: #{cache_dir}")
          end
        end
        
        unless found_cache
          UI.message("   ‚ö†Ô∏è  No cache directories found in any expected location")
        end
        
        # Method 4: Recursive search as last resort (if screenshots still not found)
        if extracted_count == 0
          UI.message("   üîç Performing recursive search for screenshots...")
          
          # Define reasonable search roots (don't search entire filesystem)
          search_roots = []
          
          # Search in home directory
          if ENV['HOME']
            search_roots << ENV['HOME']
          end
          search_roots << Dir.home
          
          # Search in derived data
          if derived && Dir.exist?(derived)
            search_roots << derived
          end
          
          # Search in simulator directories
          simulator_base = File.expand_path("~/Library/Developer/CoreSimulator/Devices")
          if Dir.exist?(simulator_base)
            search_roots << simulator_base
          end
          
          # Search in workspace directory
          workspace_root = File.expand_path(".")
          search_roots << workspace_root
          
          # Research-based additional search locations:
          # 1. Default Xcode Derived Data (if different from custom derived path)
          default_derived_data = File.expand_path("~/Library/Developer/Xcode/DerivedData")
          if Dir.exist?(default_derived_data) && default_derived_data != derived
            search_roots << default_derived_data
          end
          
          # 2. Xcode logs directory
          xcode_logs = File.expand_path("~/Library/Logs")
          if Dir.exist?(xcode_logs)
            search_roots << xcode_logs
          end
          
          # 3. Temporary directories (screenshots might be in temp locations)
          if ENV['TMPDIR']
            search_roots << ENV['TMPDIR']
          end
          if ENV['TMP']
            search_roots << ENV['TMP']
          end
          
          # 4. Fastlane screenshots output directory (might have been created elsewhere)
          fastlane_screenshots_base = File.expand_path("./fastlane/screenshots")
          if Dir.exist?(fastlane_screenshots_base)
            search_roots << fastlane_screenshots_base
          end
          
          search_roots.uniq!
          
          found_screenshots = []
          search_roots.each do |root|
            next unless Dir.exist?(root)
            UI.message("   Searching in: #{root}")
            
            begin
              # Recursively search for PNG files (limit depth to avoid performance issues)
              # Look for files that might be screenshots (contain device names or screenshot names)
              screenshot_patterns = [
                "*iPhone*.png",
                "*iPad*.png",
                "*01-WelcomeScreen*.png",
                "*02-ListsHome*.png",
                "*03-ListDetail*.png",
                "*04-ItemDetail*.png",
                "*05-ItemEdit*.png"
              ]
              
              # Search with depth limit (max 5 levels deep to avoid performance issues)
              max_depth = 5
              current_depth = 0
              
              # Use find command for better performance than Ruby's recursive glob
              screenshot_patterns.each do |pattern|
                # Use find command to search recursively
                find_cmd = "find '#{root}' -maxdepth #{max_depth} -type f -iname '#{pattern}' 2>/dev/null | head -50"
                found_files = `#{find_cmd}`.lines.map(&:chomp).reject(&:empty?)
                
                found_files.each do |file_path|
                  # Skip if already found or in system directories
                  next if file_path.include?("/System/") || file_path.include?("/Library/Caches/com.apple")
                  next if found_screenshots.include?(file_path)
                  
                  # Check if file looks like a screenshot (reasonable size, PNG format)
                  if File.exist?(file_path) && File.size(file_path) > 1000 # At least 1KB
                    found_screenshots << file_path
                    UI.message("     ‚úÖ Found potential screenshot: #{file_path}")
                  end
                end
              end
              
              # Also search for any PNG files in tools.fastlane directories
              fastlane_cache_pattern = "**/tools.fastlane/**/*.png"
              Dir.glob(File.join(root, fastlane_cache_pattern)).each do |file_path|
                next if found_screenshots.include?(file_path)
                if File.exist?(file_path) && File.size(file_path) > 1000
                  found_screenshots << file_path
                  UI.message("     ‚úÖ Found screenshot in fastlane cache: #{file_path}")
                end
              end
              
            rescue => e
              UI.message("     ‚ö†Ô∏è  Error searching in #{root}: #{e.message}")
            end
          end
          
          # Copy found screenshots
          if found_screenshots.any?
            UI.message("   ‚úÖ Found #{found_screenshots.count} potential screenshots via recursive search")
            found_screenshots.each do |src|
              begin
                basename = File.basename(src)
                # Try to extract screenshot name (remove device prefix if present)
                if basename.include?("-")
                  parts = basename.split("-", 2)
                  if parts.length == 2 && (parts[0].include?("iPhone") || parts[0].include?("iPad"))
                    basename = parts[1]
                  end
                end
                dst = File.join(locale_dir, basename)
                unless File.exist?(dst)
                  FileUtils.cp(src, dst)
                  extracted_count += 1
                  UI.message("   ‚úÖ Copied: #{basename} from #{File.dirname(src)}")
                end
              rescue => e
                UI.message("   ‚ö†Ô∏è  Error copying #{src}: #{e.message}")
              end
            end
          else
            UI.message("   ‚ö†Ô∏è  No screenshots found via recursive search")
          end
        end
        
        # Method 5: Recursive search for debug logs
        UI.message("   üîç Performing recursive search for debug logs...")
        log_search_roots = []
        if ENV['HOME']
          log_search_roots << ENV['HOME']
        end
        log_search_roots << Dir.home
        if derived && Dir.exist?(derived)
          log_search_roots << derived
        end
        
        found_logs = []
        log_search_roots.uniq.each do |root|
          next unless Dir.exist?(root)
          begin
            # Search for snapshot_debug.log files
            log_pattern = "**/snapshot_debug.log"
            Dir.glob(File.join(root, log_pattern)).each do |log_path|
              next if found_logs.include?(log_path)
              if File.exist?(log_path)
                found_logs << log_path
                UI.message("   ‚úÖ Found debug log: #{log_path}")
                begin
                  log_content = File.read(log_path)
                  snapshot_calls = log_content.scan(/snapshot:/).count
                  if snapshot_calls > 0
                    UI.message("     üìä Contains #{snapshot_calls} snapshot() calls")
                    # Show last few entries
                    snapshot_lines = log_content.lines.select { |l| l.include?("snapshot:") }.last(5)
                    snapshot_lines.each { |line| UI.message("       #{line.chomp}") }
                  end
                rescue => e
                  UI.message("     ‚ö†Ô∏è  Error reading log: #{e.message}")
                end
              end
            end
            
            # Also search for xcodebuild log files
            # Research shows logs are in: DerivedData/Logs/Test, ~/Library/Logs/snapshot, etc.
            xcode_log_patterns = [
              "**/snapshot/**/*.log",
              "**/Logs/snapshot/*.log",
              "**/Logs/Test/*.log",
              "**/DerivedData/**/Logs/Test/*.log",
              "**/DerivedData/**/Logs/**/*.txt",  # StandardOutputAndStandardError.txt
              "**/xcresult/**/*.log",
              "**/TestSummaries.plist"  # Test summaries may contain log references
            ]
            xcode_log_patterns.each do |pattern|
              Dir.glob(File.join(root, pattern)).each do |log_path|
                next if found_logs.include?(log_path) || File.size(log_path) > 10_000_000 # Skip huge logs (>10MB)
                if File.exist?(log_path) && File.mtime(log_path) > Time.now - 3600 # Modified in last hour
                  found_logs << log_path
                  UI.message("   ‚úÖ Found xcodebuild log: #{log_path} (#{File.size(log_path)} bytes)")
                end
              end
            end
          rescue => e
            UI.message("   ‚ö†Ô∏è  Error searching for logs in #{root}: #{e.message}")
          end
        end
        
        # Method 3: Check for debug log file (verifies snapshot() is being called)
        possible_cache_dirs.uniq.each do |cache_dir|
          debug_log_path = File.join(File.dirname(cache_dir), "snapshot_debug.log")
          if File.exist?(debug_log_path)
            UI.message("   ‚úÖ Found debug log at: #{debug_log_path}")
            debug_content = File.read(debug_log_path)
            snapshot_calls = debug_content.lines.select { |l| l.include?("snapshot:") }
            if snapshot_calls.any?
              UI.message("   ‚úÖ Debug log shows #{snapshot_calls.count} snapshot() calls:")
              snapshot_calls.last(5).each { |line| UI.message("     #{line.chomp}") }
            else
              UI.message("   ‚ö†Ô∏è  Debug log exists but no snapshot calls found")
            end
            break
          end
        end
        
        # Method 3: Check if Fastlane already extracted screenshots automatically
        # Fastlane should extract screenshots when result_bundle: true, but it might use a different location
        fastlane_extracted_dir = File.join(screenshots_dir, locale)
        if Dir.exist?(fastlane_extracted_dir)
          fastlane_screenshots = Dir.glob(File.join(fastlane_extracted_dir, "*.png"))
          if fastlane_screenshots.any?
            UI.message("   ‚úÖ Fastlane automatically extracted #{fastlane_screenshots.count} screenshots to: #{fastlane_extracted_dir}")
            extracted_count += fastlane_screenshots.count
          else
            UI.message("   ‚ö†Ô∏è  Fastlane output directory exists but no screenshots found")
          end
        end
        
        if extracted_count > 0
          UI.success("   ‚úÖ Total extracted: #{extracted_count} screenshots")
        else
          UI.message("   ‚ö†Ô∏è  No screenshots found in result bundle or cache directory")
        end
        
        # CRITICAL DIAGNOSTICS: Extract environment debug file from simulator
        # The test writes environment variables to a file we can check
        UI.message("üîç DIAGNOSTICS: Checking for environment debug file from test process...")
        begin
          # Find simulator data directory
          simulator_info = `xcrun simctl list devices --json 2>&1`
          if $?.success?
            require 'json'
            sim_data = JSON.parse(simulator_info)
            device_name_for_match = device.gsub(/[^a-zA-Z0-9]/, "")
            sim_data['devices'].each do |runtime, devices|
              devices.each do |sim|
                if sim['name'] == device || sim['name'].gsub(/[^a-zA-Z0-9]/, "") == device_name_for_match
                  if sim['dataPath']
                    env_debug_path = File.join(sim['dataPath'], "Library", "Application Support", "test_env_debug.txt")
                    if File.exist?(env_debug_path)
                      UI.message("   ‚úÖ Found environment debug file!")
                      env_debug_content = File.read(env_debug_path)
                      UI.message("   Environment variables seen by test process:")
                      env_debug_content.lines.each { |line| UI.message("     #{line.chomp}") }
                    else
                      UI.message("   ‚ö†Ô∏è  Environment debug file not found at: #{env_debug_path}")
                    end
                    break
                  end
                end
              end
            end
          end
        rescue => e
          UI.message("   ‚ö†Ô∏è  Could not check environment debug file: #{e.message}")
        end
        
        # CRITICAL DIAGNOSTICS: Summary of findings
        UI.header("üìä DIAGNOSTIC SUMMARY for #{device} (#{locale})")
        UI.message("   Screenshots extracted: #{extracted_count}")
        UI.message("   Debug log found: #{debug_log_found ? 'Yes' : 'No'}")
        UI.message("   Result bundle exists: #{File.exist?(result_bundle_to_check) ? 'Yes' : 'No'}")
        UI.message("   Cache directory checked: #{simulator_host_home_for_check}/Library/Caches/tools.fastlane/screenshots")
        UI.message("   Expected screenshots: ~#{expected_per_combination}")
        
        if extracted_count == 0
          UI.error("   ‚ùå NO SCREENSHOTS FOUND - Possible causes:")
          UI.error("      1. snapshot() not being called in tests")
          UI.error("      2. Environment variables not passed to test process")
          UI.error("      3. Cache directory not accessible from test process")
          UI.error("      4. Tests failing before reaching snapshot() calls")
          UI.error("      5. Screenshots saved to unexpected location")
        end
        
        # Incremental verification: check screenshots immediately after this device/language
        UI.message("üîç Verifying screenshots for #{device} (#{locale})...")
        locale_dir = File.join(screenshots_dir, locale)
        FileUtils.mkdir_p(locale_dir) unless File.directory?(locale_dir)
        
        # Check for screenshots (device name in filename might be sanitized)
        # CRITICAL: Use the same device name sanitization format as SnapshotHelper
        device_sanitized_for_check = device_name_sanitized || device.gsub(/[^a-zA-Z0-9]/, "")
        all_locale_shots = Dir.glob(File.join(locale_dir, "*.png"))
        device_shots = all_locale_shots.select { |f| 
          basename = File.basename(f)
          basename.include?(device_sanitized_for_check) || 
          basename.include?(device.gsub(/[^a-zA-Z0-9]/, "")) ||
          basename.include?("iPhone16ProMax") || 
          basename.include?("iPadPro13inchM4") ||
          basename.match?(/^\d{2}-/) # Screenshot names like "01-WelcomeScreen.png"
        }
        
        if all_locale_shots.empty?
          UI.error("‚ùå No screenshots found for #{device} (#{locale})")
          UI.error("   Expected location: #{locale_dir}")
          UI.error("   Expected count: ~#{expected_per_combination} screenshots")
          
          # Check log file for debugging - try multiple possible locations
          possible_log_paths = [
            File.expand_path("~/Library/Logs/snapshot/ListAll-ListAll.log"),
            File.join(derived, "Logs/Test", "*.log"),
            File.join(derived, "Logs", "*.log"),
            File.expand_path("~/Library/Developer/Xcode/DerivedData/*/Logs/Test/*.log")
          ]
          
          log_path = nil
          log_content = nil
          possible_log_paths.each do |path_pattern|
            if path_pattern.include?("*")
              # Handle glob patterns
              matches = Dir.glob(path_pattern).sort_by { |f| File.mtime(f) }.reverse
              if matches.any?
                log_path = matches.first
                break
              end
            elsif File.exist?(path_pattern)
              log_path = path_pattern
              break
            end
          end
          
          # Also check the xcresult bundle for test output and attachments
          xcresult_path = File.join(derived, "Logs/Test", "Test-ListAll-*.xcresult")
          xcresult_files = Dir.glob(xcresult_path).sort_by { |f| File.mtime(f) }.reverse
          if xcresult_files.any?
            latest_xcresult = xcresult_files.first
            UI.message("   üîç Checking xcresult bundle: #{latest_xcresult}")
            # Try to extract test output from result bundle
            begin
              # Use xcresulttool to get test summaries - using deprecated API with --legacy flag
              # NOTE: Modern API (`get test-results`) exists but requires different code structure
              # TODO: Migrate to modern API in future refactoring
              test_summary = `xcrun xcresulttool get object --legacy --format json --path "#{latest_xcresult}" 2>&1`
              if !$?.success?
                test_summary = `xcrun xcresulttool get object --format json --path "#{latest_xcresult}" 2>&1`
              end
              
              if test_summary && !test_summary.empty? && ($?.nil? || $?.success?)
                require 'json'
                summary_data = JSON.parse(test_summary)
                UI.message("   ‚úÖ xcresult bundle is valid")
                
                # Try to extract attachments (screenshots might be here)
                attachments_dir = File.join(locale_dir, "xcresult_attachments")
                FileUtils.mkdir_p(attachments_dir) unless File.directory?(attachments_dir)
                
                # CRITICAL FIX: Use correct modern API command
                # The correct command is "export attachments" not just "attachments"
                attachments_output = `xcrun xcresulttool export attachments --path "#{latest_xcresult}" --output-path "#{attachments_dir}" 2>&1`
                if !$?.success?
                  UI.message("   ‚ö†Ô∏è  export attachments failed: #{attachments_output.chomp}")
                else
                  UI.message("   ‚úÖ export attachments succeeded")
                  # Check if manifest.json was created
                  manifest_path = File.join(attachments_dir, "manifest.json")
                  if File.exist?(manifest_path)
                    UI.message("   ‚úÖ Attachment manifest created")
                  end
                end
                
                if Dir.exist?(attachments_dir)
                  png_files = Dir.glob(File.join(attachments_dir, "**", "*.{png,PNG}"))
                  if png_files.any?
                    UI.message("   ‚úÖ Found #{png_files.count} PNG files in xcresult attachments")
                    png_files.each do |src|
                      basename = File.basename(src)
                      dst = File.join(locale_dir, basename)
                      unless File.exist?(dst)
                        FileUtils.cp(src, dst)
                        extracted_count += 1
                        UI.message("   ‚úÖ Extracted from xcresult: #{basename}")
                      end
                    end
                  end
                  FileUtils.rm_rf(attachments_dir)
                end
              else
                UI.message("   ‚ö†Ô∏è  xcresult bundle validation failed: #{test_summary.chomp}")
              end
            rescue => e
              UI.message("   ‚ö†Ô∏è  Error reading xcresult: #{e.message}")
            end
          end
          
          if log_path && File.exist?(log_path)
            UI.error("   Checking log file: #{log_path}")
            log_content = File.read(log_path)
            
            # Check if tests actually ran
            if log_content.include?("testScreenshots01_WelcomeScreen") || log_content.include?("testScreenshots02_MainFlow")
              UI.message("   ‚úÖ Test methods found in log - tests are executing")
            else
              UI.error("   ‚ùå Test methods NOT found in log - tests may not be running")
            end
            
            # Check for both "snapshot:" and debug messages
            if log_content.include?("snapshot:") || log_content.include?("DEBUG: Snapshot.snapshot")
              UI.message("   ‚úÖ Found 'snapshot:' entries in log - snapshot() is being called")
              # Show last snapshot entries
              snapshot_lines = log_content.lines.select { |l| l.include?("snapshot:") || l.include?("DEBUG: Snapshot.snapshot") }.last(10)
              UI.message("   Last snapshot entries:")
              snapshot_lines.each { |line| UI.message("     #{line.chomp}") }
              UI.error("   ‚ö†Ô∏è  Screenshots were generated but not extracted by Fastlane")
              UI.error("   ‚ö†Ô∏è  This may indicate a Fastlane snapshot bug or log parsing issue")
            else
              UI.error("   ‚ùå No 'snapshot:' entries found in log")
              UI.error("   ‚ö†Ô∏è  This suggests snapshot() calls in UI tests are NOT executing")
              UI.error("   ‚ö†Ô∏è  Possible causes:")
              UI.error("      - setupSnapshot() not called before app.launch()")
              UI.error("      - snapshot() calls are failing silently")
              UI.error("      - Tests are crashing before reaching snapshot() calls")
              UI.error("      - NSLog output not being captured in log file")
              
              # Check for debug messages that might indicate where the test is failing
              if log_content.include?("DEBUG:")
                debug_lines = log_content.lines.select { |l| l.include?("DEBUG:") }.last(20)
                UI.message("   Recent DEBUG messages:")
                debug_lines.each { |line| UI.message("     #{line.chomp}") }
              else
                UI.message("   ‚ö†Ô∏è  No DEBUG messages found in log either")
              end
              
              # Check for any print statements from test code
              if log_content.include?("üîç DEBUG:")
                test_debug_lines = log_content.lines.select { |l| l.include?("üîç DEBUG:") }.last(20)
                UI.message("   Test code DEBUG messages found:")
                test_debug_lines.each { |line| UI.message("     #{line.chomp}") }
              end
              
              # Check for setupSnapshot messages
              if log_content.include?("setupSnapshot") || log_content.include?("Cache directory")
                setup_lines = log_content.lines.select { |l| l.include?("setupSnapshot") || l.include?("Cache directory") || l.include?("Screenshots directory") }.last(10)
                UI.message("   setupSnapshot() related messages:")
                setup_lines.each { |line| UI.message("     #{line.chomp}") }
              else
                UI.message("   ‚ö†Ô∏è  No setupSnapshot() messages found - this may indicate setupSnapshot() is not being called")
              end
              
              # Check for errors or warnings from SnapshotHelper
              if log_content.include?("‚ö†Ô∏è") || log_content.include?("‚ùå") || log_content.include?("ERROR:")
                error_lines = log_content.lines.select { |l| l.include?("‚ö†Ô∏è") || l.include?("‚ùå") || l.include?("ERROR:") || l.include?("screenshotsDirectory is nil") || l.include?("XCUIApplication is not set") }.last(15)
                UI.message("   SnapshotHelper errors/warnings found:")
                error_lines.each { |line| UI.message("     #{line.chomp}") }
              end
              
              # Show a sample of the log to understand what IS being captured
              UI.message("   Sample of log content (last 30 lines):")
              log_content.lines.last(30).each_with_index do |line, idx|
                # Skip very long lines that are just noise
                next if line.length > 500
                UI.message("     [#{log_content.lines.count - 30 + idx}] #{line.chomp}")
              end
            end
          else
            UI.error("   ‚ö†Ô∏è  Log file not found at #{log_path}")
          end
          
          # FAIL FAST: Stop immediately after first failure to save time
          UI.user_error!("üö® Screenshot generation failed for #{device} (#{locale}) - FAILING FAST to save time")
        else
          found_count = device_shots.empty? ? all_locale_shots.count : device_shots.count
          if found_count >= expected_per_combination
            UI.success("‚úÖ Generated #{found_count} screenshots for #{device} (#{locale})")
          else
            UI.message("‚ö†Ô∏è  Found #{found_count} screenshots for #{device} (#{locale}) (expected ~#{expected_per_combination})")
            UI.message("   Continuing... (may be partial set)")
          end
        end
      end
    end
    
    # Final verification: ensure all expected screenshots exist
    UI.header("Final verification: Checking all screenshots")
    raw_shots = Dir.glob(File.join(screenshots_dir, "**/*.png"))
    expected_total = devices.count * locales.count * expected_per_combination
    if raw_shots.empty?
      UI.user_error!("üö® iOS screenshot generation failed: No screenshots found in #{screenshots_dir}")
    elsif raw_shots.count < expected_total * 0.8  # Allow 20% tolerance
      UI.message("‚ö†Ô∏è  Found #{raw_shots.count} screenshots (expected ~#{expected_total})")
      UI.message("   Continuing with available screenshots...")
    else
      UI.success("‚úÖ Found #{raw_shots.count} total raw iOS screenshots (expected ~#{expected_total})")
    end

    # 2. Normalize new device sizes to Frameit-supported canvases
    UI.header("Normalizing screenshot sizes for Frameit compatibility")
    compat_root = File.expand_path("screenshots_compat", __dir__)
    sh "rm -rf #{compat_root}"
    locales = %w[en-US fi]
    require 'fileutils'
    require 'shellwords'
    FileUtils.mkdir_p(compat_root)
    UI.message("Compat root: #{compat_root}")
    locales.each do |loc|
      src = File.expand_path(File.join("screenshots", loc), __dir__)
      dst = File.join(compat_root, loc)
      FileUtils.mkdir_p(dst)
      Dir.glob(File.join(src, "*.png")).each do |png|
        # Skip obvious non-screenshot assets like icons
        basename = File.basename(png)
        # Only process our 5 numbered screenshots
        next unless basename =~ /-(01|02|03|04|05)-/

        # Detect size
        size = sh("identify -format '%w %h' #{Shellwords.escape(png)}").strip.split.map(&:to_i) rescue []
        target_w = target_h = nil
        if size == [1320, 2868]
          target_w, target_h = [1290, 2796]       # iPhone 6.7" classic
        elsif size == [2064, 2752]
          target_w, target_h = [2048, 2732]       # iPad Pro 12.9"
        else
          # Pass-through if already supported sizes
          target_w, target_h = size
        end

        out = File.join(dst, basename)
        if target_w && target_h && size != [0,0]
          if [target_w, target_h] == size
            FileUtils.cp(png, out)
          else
            UI.message("Resizing #{basename} #{size.inspect} -> [#{target_w}, #{target_h}]")
            sh "magick convert #{Shellwords.escape(png)} -resize #{target_w}x#{target_h}! #{Shellwords.escape(out)}"
          end
        end
      end
    end

    UI.header("Framing screenshots with Frameit")
    # 3. Frame them into a separate 'framed' directory to keep raw images
    # Frameit uses ENV['SNAPSHOT_SCREENSHOTS_PATH'] by default; override by temporarily moving/pointing path
    ENV['SNAPSHOT_SCREENSHOTS_PATH'] = compat_root
    ENV['FRAMEIT_CONFIG_PATH'] = File.expand_path('Framefile.json', __dir__)
    frameit(
      path: compat_root,
      white: true
    )

    # Move framed output to dedicated directory preserving locale structure
    framed_root = File.expand_path(File.join('screenshots','framed'), __dir__)
    FileUtils.rm_rf(framed_root)
    FileUtils.mkdir_p(framed_root)
    Dir.glob(File.join(compat_root,'*.png')) # ignore top-level stray pngs
    Dir.glob(File.join(compat_root,'*')).select { |d| File.directory?(d) }.each do |locdir|
      loc = File.basename(locdir)
      target_loc = File.join(framed_root, loc)
      FileUtils.mkdir_p(target_loc)
      Dir.glob(File.join(locdir,'*.png')).each do |png|
        FileUtils.cp(png, target_loc)
      end
    end
    
    # 4. Fail-fast check: ensure framed screenshots exist
    framed_shots = Dir.glob(File.join(framed_root, "**/*.png"))
    if framed_shots.empty?
      UI.user_error!("üö® Framing failed: No framed screenshots found in #{framed_root}")
    end
    UI.success("‚úÖ Found #{framed_shots.count} framed screenshots")

    UI.success("üñº  Framed screenshots generated at #{framed_root}")
  end

  desc "Verify framed screenshots exist for all locales"
  lane :verify_framed do
    locales = %w[en-US fi]
    prefixes = %w[01-WelcomeScreen 02-ListsHome 03-ListDetail 04-ItemDetail 05-Settings]
    missing = []
    locales.each do |loc|
      base = File.expand_path(File.join('screenshots','framed', loc), __dir__)
      unless Dir.exist?(base)
        missing << "Directory missing: #{base}"
        next
      end
      prefixes.each do |p|
        # Require framed variant specifically
        glob = Dir.glob(File.join(base, "*-", "#{p}_framed.png")) + Dir.glob(File.join(base, "*#{p}*_framed.png"))
        if glob.empty?
          missing << "#{loc}: #{p}*_framed.png"
        end
      end
    end
    if missing.any?
      UI.user_error!("Framed screenshot verification failed. Missing: \n- #{missing.join("\n- ")}")
    else
      UI.success("‚úÖ All framed screenshots present for #{locales.join(', ')}")
    end
  end

  desc "Generate watchOS screenshots (fully automated via UITests + simctl)"
  desc "Captures screenshots from Apple Watch Series 10 (46mm) for EN and FI locales"
  lane :watch_screenshots do
    UI.header("üçé‚åöÔ∏è Generating watchOS Screenshots")
    
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']
    
    # Shared derived data path for prebuild and snapshot
    derived = "./fastlane/derivedDataWatch"
    
    # CRITICAL: Pair Watch simulator with iPhone simulator
    # Without pairing, Watch tests may run on iPhone instead of Watch,
    # and screenshots will show "iPhone Disconnected" icon (violates App Store guidelines)
    # Fastlane snapshot will handle pairing automatically if devices are available,
    # but we ensure they exist and are ready
    UI.header("Preparing Watch and iPhone simulators for pairing")
    watch_device = "Apple Watch Series 10 (46mm)"  # Available in CI (Xcode 16.1)
    iphone_device = "iPhone 16 Pro Max"  # Use same device as iOS screenshots for consistency
    
    # Ensure simulators exist and are available
    # Fastlane snapshot will automatically pair them when running Watch tests
    # The key is ensuring both devices are available in the simulator list
    UI.message("Verifying simulators are available: #{iphone_device} and #{watch_device}")
    
    # Check if simulators exist
    iphone_exists = sh("xcrun simctl list devices available | grep -c '#{iphone_device}' | grep -v 'unavailable'", log: false).strip.to_i > 0 rescue false
    watch_exists = sh("xcrun simctl list devices available | grep -c '#{watch_device}' | grep -v 'unavailable'", log: false).strip.to_i > 0 rescue false
    
    if iphone_exists && watch_exists
      UI.success("‚úÖ Required simulators are available")
      UI.message("üí° Fastlane snapshot will automatically pair Watch with iPhone when running tests")
    else
      UI.important("‚ö†Ô∏è  Some simulators may not be available. Snapshot will attempt to create/pair automatically.")
    end
    
    # 0. ONE-TIME BUILD-FOR-TESTING
    # Build once, then snapshot reuses these compiled products for all languages
    # This prevents rebuilding 2x (2 languages), saving 5-8 minutes
    UI.header("Building Watch app and UI tests once for all snapshot runs")
    scan(
      scheme: "ListAllWatch Watch App",
      project: "./ListAll/ListAll.xcodeproj",
      testplan: "ListAllWatch Watch App",
      devices: [watch_device],  # Any device; we only need to populate DerivedData
      clean: true,
      build_for_testing: true,
      # Note: build_for_testing and test_without_building are mutually exclusive
      # build_for_testing means: build only, don't run tests
      # We need to build UI tests for snapshot, so don't use skip_testing here
      derived_data_path: derived,
      xcargs: "ONLY_ACTIVE_ARCH=YES CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO"
    )
    
    # 1. Raw screenshots using pre-built products
    # Note: test_without_building reuses the build from scan above
    # CRITICAL: Disable xcodebuild_formatter so Fastlane can parse NSLog("snapshot: ...") entries
    # CRITICAL: Ensure iPhone simulator stays running for Watch pairing
    UI.header("Running watch snapshot using pre-built tests")
    snapshot(
      project: "./ListAll/ListAll.xcodeproj",
      scheme: "ListAllWatch Watch App",
      testplan: "ListAllWatch Watch App",
      devices: [watch_device],
      languages: ["en-US", "fi"],
      output_directory: "./fastlane/screenshots/watch",
      clear_previous_screenshots: true,
      override_status_bar: true,
      reinstall_app: true,
      test_without_building: true,  # Reuse pre-built products
      derived_data_path: derived,
      concurrent_simulators: false,
      skip_helper_version_check: true,
      result_bundle: false,  # Disable to allow Fastlane auto-extraction
      xcodebuild_formatter: "",  # Empty string disables formatter, allowing Fastlane to parse logs
      stop_after_first_error: false  # Don't stop on first error to allow all languages to run
    )
    
    # 2. Fail-fast check: ensure raw screenshots exist before processing
    watch_raw_dir = File.expand_path("screenshots/watch", __dir__)
    raw_shots = Dir.glob(File.join(watch_raw_dir, "**/*.png"))
    if raw_shots.empty?
      UI.user_error!("üö® Watch screenshot generation failed: No screenshots found in #{watch_raw_dir}")
    end
    UI.success("‚úÖ Found #{raw_shots.count} raw watch screenshots")
    
    UI.success("üçé‚åöÔ∏è Watch screenshots generation complete!")
    UI.message("üìÅ Raw screenshots saved to: fastlane/screenshots/watch")
    
    # Normalize watch screenshots to App Store Connect required dimensions
    UI.header("üìê Normalizing watchOS screenshots to App Store Connect dimensions")
    watch_normalized_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    
    begin
      WatchScreenshotHelper.normalize_screenshots(
        watch_raw_dir,
        watch_normalized_dir,
        target_size: :series7plus  # 396x484 - Apple Watch Series 7+ (45mm)
      )
    rescue => e
      UI.user_error!("Failed to normalize watch screenshots: #{e.message}")
    end
    
    # 3. Fail-fast check: ensure normalized screenshots exist
    normalized_shots = Dir.glob(File.join(watch_normalized_dir, "**/*.png"))
    if normalized_shots.empty?
      UI.user_error!("üö® Watch screenshot normalization failed: No normalized screenshots found in #{watch_normalized_dir}")
    end
    UI.success("‚úÖ Found #{normalized_shots.count} normalized watch screenshots")
    
    # Copy normalized watch screenshots to framed directory (no framing for watchOS - standard practice)
    UI.header("üìÇ Copying normalized watchOS screenshots to unified directory")
    unified_framed_root = File.expand_path("screenshots/framed", __dir__)
    locales = %w[en-US fi]

    locales.each do |loc|
      normalized_dir = File.join(watch_normalized_dir, loc)
      next unless Dir.exist?(normalized_dir)
      framed_locale_dir = File.join(unified_framed_root, loc)
      FileUtils.mkdir_p(framed_locale_dir)

      # Copy normalized watch screenshots as-is (naked, no frame) - this is standard for watchOS
      Dir.glob(File.join(normalized_dir, "*.png")).each do |normalized|
        base = File.basename(normalized)
        target = File.join(framed_locale_dir, base)
        FileUtils.cp(normalized, target)
      end
    end

    UI.success("‚úÖ Normalized watch screenshots copied to #{unified_framed_root} (396x484, unframed)")
  end

  desc "Validate watch screenshot sizes and naming (uses App Store Connect requirements)"
  lane :verify_watch_screenshots do
    UI.header("üîç Validating watchOS Screenshots")
    watch_normalized_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    
    begin
      WatchScreenshotHelper.validate_screenshots(
        watch_normalized_dir,
        expected_count: 5,
        allowed_sizes: [:series7plus]  # Only accept 396x484 (45mm)
      )
      UI.success("‚úÖ All watch screenshots validated successfully!")
    rescue WatchScreenshotHelper::ValidationError => e
      UI.user_error!("Watch screenshot validation failed: #{e.message}")
    end
  end

  desc "Validate all delivery-ready screenshots (framed iPhone/iPad + naked Watch)"
  lane :validate_delivery_screenshots do
    UI.header("ÔøΩ Validating delivery-ready screenshots for App Store submission")
    
    locales = %w[en-US fi]
    errors = []
    warnings = []
    
    # Expected framed dimensions (Frameit output with device frames)
    iphone_framed_size = { width: 1421, height: 2909, tolerance: 50 }
    ipad_framed_size = { width: 2286, height: 3168, tolerance: 50 }
    watch_size = { width: 396, height: 484, tolerance: 0 }  # Exact match required
    
    # Check framed iPhone/iPad screenshots
    framed_dir = File.expand_path("screenshots/framed", __dir__)
    locales.each do |locale|
      locale_dir = File.join(framed_dir, locale)
      unless Dir.exist?(locale_dir)
        errors << "‚ùå Missing framed screenshots directory: #{locale_dir}"
        next
      end
      
      # Check iPhone framed screenshots
      iphone_framed = Dir.glob(File.join(locale_dir, "iPhone*_framed.png"))
      if iphone_framed.count != 5
        warnings << "‚ö†Ô∏è  #{locale}: Expected 5 iPhone framed screenshots, found #{iphone_framed.count}"
      end
      
      iphone_framed.each do |shot|
        dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
        w, h = dims.split('x').map(&:to_i)
        if (w - iphone_framed_size[:width]).abs > iphone_framed_size[:tolerance] ||
           (h - iphone_framed_size[:height]).abs > iphone_framed_size[:tolerance]
          errors << "‚ùå #{locale}/#{File.basename(shot)}: #{dims} (expected ~#{iphone_framed_size[:width]}x#{iphone_framed_size[:height]})"
        else
          puts "‚úÖ #{locale}/#{File.basename(shot)}: #{dims}"
        end
      end
      
      # Check iPad framed screenshots
      ipad_framed = Dir.glob(File.join(locale_dir, "iPad*_framed.png"))
      if ipad_framed.count != 5
        warnings << "‚ö†Ô∏è  #{locale}: Expected 5 iPad framed screenshots, found #{ipad_framed.count}"
      end
      
      ipad_framed.each do |shot|
        dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
        w, h = dims.split('x').map(&:to_i)
        if (w - ipad_framed_size[:width]).abs > ipad_framed_size[:tolerance] ||
           (h - ipad_framed_size[:height]).abs > ipad_framed_size[:tolerance]
          errors << "‚ùå #{locale}/#{File.basename(shot)}: #{dims} (expected ~#{ipad_framed_size[:width]}x#{ipad_framed_size[:height]})"
        else
          puts "‚úÖ #{locale}/#{File.basename(shot)}: #{dims}"
        end
      end
    end
    
    # Check watch naked screenshots
    watch_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    if Dir.exist?(watch_dir)
      locales.each do |locale|
        locale_dir = File.join(watch_dir, locale)
        unless Dir.exist?(locale_dir)
          errors << "‚ùå Missing watch screenshots directory: #{locale_dir}"
          next
        end
        
        watch_shots = Dir.glob(File.join(locale_dir, "*.png"))
        if watch_shots.count != 5
          warnings << "‚ö†Ô∏è  #{locale}: Expected 5 watch screenshots, found #{watch_shots.count}"
        end
        
        watch_shots.each do |shot|
          dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
          w, h = dims.split('x').map(&:to_i)
          if w != watch_size[:width] || h != watch_size[:height]
            errors << "‚ùå #{locale}/#{File.basename(shot)}: #{dims} (expected exactly #{watch_size[:width]}x#{watch_size[:height]})"
          else
            puts "‚úÖ #{locale}/#{File.basename(shot)}: #{dims}"
          end
        end
      end
    else
      warnings << "‚ö†Ô∏è  Watch screenshots directory not found: #{watch_dir}"
    end
    
    # Print summary
    puts "\n" + "=" * 70
    puts "Delivery Screenshot Validation Summary"
    puts "=" * 70
    
    if warnings.any?
      puts "\nWarnings:"
      warnings.each { |w| puts w }
    end
    
    if errors.any?
      puts "\nErrors:"
      errors.each { |e| puts e }
      puts "\n‚ùå Validation FAILED: #{errors.count} error(s)"
      UI.user_error!("Delivery screenshots validation failed")
    else
      puts "\n‚úÖ All delivery screenshots are valid and ready for App Store submission!"
      puts "\nReady for upload:"
      puts "  ‚Ä¢ iPhone: 10 framed screenshots (~1421x2909)"
      puts "  ‚Ä¢ iPad: 10 framed screenshots (~2286x3168)"
      puts "  ‚Ä¢ Watch: 10 naked screenshots (396x484)"
      puts "  ‚Ä¢ Total: 30 screenshots across EN + FI locales"
    end
  end
end
