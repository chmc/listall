# Fastlane configuration
# Docs: https://docs.fastlane.tools
require 'base64'
require 'fileutils'
require 'shellwords'
require_relative 'lib/version_helper'
require_relative 'lib/watch_screenshot_helper'
require_relative 'lib/screenshot_helper'

default_platform(:ios)

def require_asc_env!
  missing = ["ASC_KEY_ID", "ASC_ISSUER_ID", "ASC_KEY_BASE64"].reject { |k| ENV[k].to_s.strip.size > 0 }
  UI.user_error!("Missing App Store Connect API key env vars: #{missing.join(', ')}") unless missing.empty?
end

# Prepare screenshots for deliver by copying only framed versions to a clean directory
def prepare_screenshots_for_delivery(framed_path)
  delivery_path = File.expand_path("screenshots/delivery", __dir__)
  FileUtils.rm_rf(delivery_path)
  FileUtils.mkdir_p(delivery_path)
  
  locales = %w[en-US fi]
  locales.each do |locale|
    src_dir = File.join(framed_path, locale)
    dst_dir = File.join(delivery_path, locale)
    FileUtils.mkdir_p(dst_dir)
    
    # Copy only framed screenshots (exclude non-framed variants)
    Dir.glob(File.join(src_dir, "*_framed.png")).each do |framed_file|
      FileUtils.cp(framed_file, dst_dir)
    end
  end
  
  delivery_path
end


platform :ios do
  desc "Run unit and UI tests (xcodebuild like CI)"
  lane :test do
    # Mirror CI behavior with xcodebuild and non-failing exit
    sh "cd ../ListAll && xcodebuild clean build -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' -configuration Debug CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
    sh "cd ../ListAll && xcodebuild test -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' -resultBundlePath ../fastlane/test_output/ListAll.xcresult CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
  end

  desc "Run tests via scan (Fastlane)"
  lane :test_scan do
    # Prefer project since workspace is embedded in .xcodeproj
    scan(
      project: "ListAll/ListAll.xcodeproj",
      scheme: "ListAll",
      clean: true,
      result_bundle: true,
      derived_data_path: "./ListAll/build",
      devices: ["iPhone 16 Pro"], # falls back to default if not available
      fail_build: false
    )
  end

  desc "Build and upload to TestFlight"
  desc "Options:"
  desc "  bump_type: 'patch' (default), 'minor', or 'major' - Type of version increment"
  desc "  skip_version_bump: true to skip version increment (use current version)"
  lane :beta do |options|
    # Setup CI environment (creates temporary keychain)
    if ENV['CI']
      setup_ci
      # Set keychain password for Match to use when importing certs
      ENV["KEYCHAIN_PASSWORD"] = ""  # setup_ci creates keychain with empty password
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    # Handle version numbering with semantic versioning
    unless options[:skip_version_bump]
      bump_type = options[:bump_type] || 'patch'
      
      # Read current version from file
      current_version = VersionHelper.read_version
      UI.message("ðŸ“¦ Current version: #{current_version}")
      
      # Increment version
      new_version = VersionHelper.increment_version(current_version, bump_type)
      UI.important("ðŸ“¦ Bumping version (#{bump_type}): #{current_version} â†’ #{new_version}")
      
      # Update version in all targets
      VersionHelper.update_xcodeproj_version(xcodeproj_path, new_version)
      
      # Save new version to file
      VersionHelper.write_version(new_version)
      
      # Validate all targets have the same version
      unless VersionHelper.validate_versions(xcodeproj_path)
        UI.user_error!("Version validation failed. Please check that all targets have matching versions.")
      end
      
      UI.success("âœ… Version updated to #{new_version}")
    else
      current_version = VersionHelper.read_version
      UI.message("â­ï¸  Skipping version bump, using current version: #{current_version}")
    end
    
    # Increment build number automatically
    # In CI: use GitHub Actions run number, otherwise just increment by 1
    if ENV['GITHUB_RUN_NUMBER']
      increment_build_number(
        build_number: ENV['GITHUB_RUN_NUMBER'],
        xcodeproj: xcodeproj_path
      )
    else
      increment_build_number(
        xcodeproj: xcodeproj_path
      )
    end
    
    # Sync code signing with verbose output
    match(
      type: 'appstore',
      verbose: true,
      keychain_password: ENV["KEYCHAIN_PASSWORD"] || "",
      skip_set_partition_list: true  # Skip partition list in CI to avoid SecItemCopyMatching error
    )
    
    # Disable automatic code signing for Release configuration
    disable_automatic_code_signing(
      path: "ListAll/ListAll.xcodeproj",
      targets: ["ListAll", "ListAllWatch Watch App"],
      code_sign_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Update Xcode project to use the provisioning profiles from Match
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll_appstore_profile-path"],
      target_filter: "ListAll",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll.watchkitapp_appstore_profile-path"],
      target_filter: "ListAllWatch Watch App",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Build archive (gym/build_app handles exporting ipa)
    ipa_path = build_app(
      project: xcodeproj_path,
      scheme: "ListAll",
      export_method: "app-store",
      output_directory: "./ListAll/build",
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        provisioningProfiles: {
          "io.github.chmc.ListAll" => "match AppStore io.github.chmc.ListAll",
          "io.github.chmc.ListAll.watchkitapp" => "match AppStore io.github.chmc.ListAll.watchkitapp"
        }
      }
    )

    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_KEY_BASE64"]
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
        is_key_content_base64: false,
        in_house: false
      )
      pilot(
        ipa: ipa_path,
        api_key: api_key,
        distribute_external: false
      )
    else
      UI.important("ASC_* env vars not set. Skipping TestFlight upload. Archive built at: #{ipa_path}")
    end
  end

  desc "Deliver metadata/screenshots to App Store (no auto-submit)"
  lane :release do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist before attempting delivery
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("ðŸ“¸ Using framed screenshots from: #{delivery_path}")

    deliver(
      api_key: api_key,
      screenshots_path: delivery_path,
      skip_screenshots: false,
      overwrite_screenshots: true,
      skip_binary_upload: true,
      submit_for_review: false,
      force: true
    )
  end

  desc "Dry-run: Verify framed screenshots would be detected by deliver (no upload)"
  lane :release_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("ðŸ“¸ Verifying screenshots prepared for delivery from: #{delivery_path}")
    
    # List what deliver would find
    locales = %w[en-US fi]
    locales.each do |locale|
      locale_path = File.join(delivery_path, locale)
      if Dir.exist?(locale_path)
        screenshots = Dir.glob(File.join(locale_path, "*.png")).sort
        UI.header("#{locale} (#{screenshots.count} screenshots)")
        screenshots.each do |shot|
          basename = File.basename(shot)
          size = `identify -format '%wx%h' "#{shot}"`.strip rescue "unknown"
          UI.message("  #{basename} (#{size})")
        end
      else
        UI.error("Missing locale directory: #{locale_path}")
      end
    end
    
    UI.success("âœ… Framed screenshots are ready for delivery")
    UI.message("ðŸ’¡ Run 'bundle exec fastlane release' to upload to App Store Connect")
  end

  desc "Validate App Store Connect auth via API key (no uploads)"
  lane :asc_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # This will authenticate and fetch app metadata without uploading anything
    deliver(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_binary_upload: true,
      submit_for_review: false,
      run_precheck_before_submit: false,  # Precheck doesn't work with API keys
      force: true
    )
  end

  # Version management lanes
  
  desc "Show current version from all targets"
  lane :show_version do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.header("ðŸ“¦ Version Information")
    
    # Read from version file
    file_version = VersionHelper.read_version
    UI.message("Version file (.version): #{file_version}")
    
    # Read from git tag (if available)
    git_version = VersionHelper.version_from_git_tag
    UI.message("Latest git tag: #{git_version || 'none'}") if git_version
    
    # Read from Xcode project
    UI.message("\nXcode Project Versions:")
    targets = ['ListAll', 'ListAllWatch Watch App']
    targets.each do |target|
      begin
        version = get_version_number(
          xcodeproj: xcodeproj_path,
          target: target
        )
        build = get_build_number(xcodeproj: xcodeproj_path)
        UI.message("  #{target}: #{version} (#{build})")
      rescue => e
        UI.error("  #{target}: Error - #{e.message}")
      end
    end
    
    # Validate consistency
    UI.message("\n")
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("âœ… All versions are consistent")
    else
      UI.error("âŒ Version mismatch detected")
    end
  end
  
  desc "Manually set version number"
  desc "Usage: fastlane set_version version:1.2.0"
  lane :set_version do |options|
    unless options[:version]
      UI.user_error!("Please specify version with version:X.Y.Z")
    end
    
    version = options[:version]
    
    # Validate semantic version format
    unless version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Version must be in format X.Y.Z (e.g., 1.2.0)")
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.important("ðŸ“¦ Setting version to: #{version}")
    
    # Update version in all targets
    VersionHelper.update_xcodeproj_version(xcodeproj_path, version)
    
    # Save to version file
    VersionHelper.write_version(version)
    
    # Validate
    unless VersionHelper.validate_versions(xcodeproj_path)
      UI.user_error!("Version validation failed")
    end
    
    UI.success("âœ… Version set to #{version}")
    UI.message("ðŸ’¡ Don't forget to commit the changes and create a git tag:")
    UI.message("   git add .version ListAll/ListAll.xcodeproj/project.pbxproj")
    UI.message("   git commit -m 'Bump version to #{version}'")
    UI.message("   git tag v#{version}")
    UI.message("   git push origin main --tags")
  end
  
  desc "Validate that all targets have matching versions"
  lane :validate_versions do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("âœ… All versions are valid and consistent")
    else
      UI.user_error!("âŒ Version validation failed")
    end
  end
  
  desc "Generate screenshots for App Store"
  desc "Runs automated UI tests to capture screenshots for all configured devices and locales"
  lane :screenshots do
    # Capture screenshots using the snapshot tool
    snapshot
    
    UI.success("âœ… Screenshots generated successfully")
    UI.message("ðŸ“ Screenshots saved to: fastlane/screenshots")
  end

  desc "Unified App Store screenshot generation pipeline"
  desc "Generates all screenshots (iPhone, iPad, Watch) with validation and fail-fast checks"
  desc "This is the main entry point for CI/CD pipelines"
  lane :prepare_appstore do
    UI.header("ðŸš€ Starting App Store Screenshot Generation Pipeline")
    
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']
    
    begin
      # 1. Generate iPhone and iPad screenshots (with framing)
      UI.header("Step 1/2: Generating iPhone and iPad screenshots")
      screenshots_framed
      
      # 2. Generate Watch screenshots
      UI.header("Step 2/2: Generating Watch screenshots")
      watch_screenshots
      
      # 3. Final validation: ensure all expected screenshots exist
      UI.header("Final Validation: Verifying all screenshots were generated")
      validate_delivery_screenshots
      
      UI.success("ðŸŽ‰ App Store screenshot generation pipeline completed successfully!")
      UI.message("ðŸ“ All screenshots ready in: fastlane/screenshots/framed/")
      UI.message("   - iPhone/iPad: Framed screenshots")
      UI.message("   - Watch: Normalized screenshots (unframed)")
      
    rescue => e
      UI.error("âŒ Pipeline failed: #{e.message}")
      UI.error("Stack trace: #{e.backtrace.join("\n")}")
      raise
    end
  end

  desc "Generate and frame screenshots (snapshot + frameit)"
  lane :screenshots_framed do
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']
    
    # Shared derived data path for prebuild and snapshot
    derived = "./fastlane/derivedDataSnapshot"
    
    # 0. ONE-TIME BUILD-FOR-TESTING
    # Build once, then snapshot reuses these compiled products for all devices/languages
    # This prevents rebuilding 4x (2 devices Ã— 2 languages), saving 10-15 minutes
    UI.header("Building app and UI tests once for all snapshot runs")
    scan(
      scheme: "ListAll",
      project: "./ListAll/ListAll.xcodeproj",
      devices: ["iPhone 15 Pro Max"],  # Any device; we only need to populate DerivedData
      clean: true,
      build_for_testing: true,
      # Note: build_for_testing and test_without_building are mutually exclusive
      # build_for_testing means: build only, don't run tests
      # We need to build UI tests for snapshot, so don't use skip_testing here
      derived_data_path: derived,
      xcargs: "ONLY_ACTIVE_ARCH=YES CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO"
    )
    
    # 1. Raw screenshots using pre-built products
    # Snapfile contains device/language/test configs
    # Note: test_without_building reuses the build from scan above
    # CRITICAL: Disable xcodebuild_formatter so Fastlane can parse NSLog("snapshot: ...") entries
    UI.header("Running snapshot using pre-built tests")
    snapshot(
      derived_data_path: derived,
      test_without_building: true,
      xcodebuild_formatter: ""  # Empty string disables formatter, allowing Fastlane to parse logs
      # result_bundle: false is set in Snapfile to enable log-based extraction
    )
    
    # 1.5. Fail-fast check: ensure raw screenshots exist before processing
    screenshots_dir = File.expand_path("screenshots", __dir__)
    raw_shots = Dir.glob(File.join(screenshots_dir, "**/*.png"))
    if raw_shots.empty?
      UI.user_error!("ðŸš¨ iOS screenshot generation failed: No screenshots found in #{screenshots_dir}")
    end
    UI.success("âœ… Found #{raw_shots.count} raw iOS screenshots")

    # 2. Normalize new device sizes to Frameit-supported canvases
    UI.header("Normalizing screenshot sizes for Frameit compatibility")
    compat_root = File.expand_path("screenshots_compat", __dir__)
    sh "rm -rf #{compat_root}"
    locales = %w[en-US fi]
    require 'fileutils'
    require 'shellwords'
    FileUtils.mkdir_p(compat_root)
    UI.message("Compat root: #{compat_root}")
    locales.each do |loc|
      src = File.expand_path(File.join("screenshots", loc), __dir__)
      dst = File.join(compat_root, loc)
      FileUtils.mkdir_p(dst)
      Dir.glob(File.join(src, "*.png")).each do |png|
        # Skip obvious non-screenshot assets like icons
        basename = File.basename(png)
        # Only process our 5 numbered screenshots
        next unless basename =~ /-(01|02|03|04|05)-/

        # Detect size
        size = sh("identify -format '%w %h' #{Shellwords.escape(png)}").strip.split.map(&:to_i) rescue []
        target_w = target_h = nil
        if size == [1320, 2868]
          target_w, target_h = [1290, 2796]       # iPhone 6.7" classic
        elsif size == [2064, 2752]
          target_w, target_h = [2048, 2732]       # iPad Pro 12.9"
        else
          # Pass-through if already supported sizes
          target_w, target_h = size
        end

        out = File.join(dst, basename)
        if target_w && target_h && size != [0,0]
          if [target_w, target_h] == size
            FileUtils.cp(png, out)
          else
            UI.message("Resizing #{basename} #{size.inspect} -> [#{target_w}, #{target_h}]")
            sh "magick convert #{Shellwords.escape(png)} -resize #{target_w}x#{target_h}! #{Shellwords.escape(out)}"
          end
        end
      end
    end

    UI.header("Framing screenshots with Frameit")
    # 3. Frame them into a separate 'framed' directory to keep raw images
    # Frameit uses ENV['SNAPSHOT_SCREENSHOTS_PATH'] by default; override by temporarily moving/pointing path
    ENV['SNAPSHOT_SCREENSHOTS_PATH'] = compat_root
    ENV['FRAMEIT_CONFIG_PATH'] = File.expand_path('Framefile.json', __dir__)
    frameit(
      path: compat_root,
      white: true
    )

    # Move framed output to dedicated directory preserving locale structure
    framed_root = File.expand_path(File.join('screenshots','framed'), __dir__)
    FileUtils.rm_rf(framed_root)
    FileUtils.mkdir_p(framed_root)
    Dir.glob(File.join(compat_root,'*.png')) # ignore top-level stray pngs
    Dir.glob(File.join(compat_root,'*')).select { |d| File.directory?(d) }.each do |locdir|
      loc = File.basename(locdir)
      target_loc = File.join(framed_root, loc)
      FileUtils.mkdir_p(target_loc)
      Dir.glob(File.join(locdir,'*.png')).each do |png|
        FileUtils.cp(png, target_loc)
      end
    end
    
    # 4. Fail-fast check: ensure framed screenshots exist
    framed_shots = Dir.glob(File.join(framed_root, "**/*.png"))
    if framed_shots.empty?
      UI.user_error!("ðŸš¨ Framing failed: No framed screenshots found in #{framed_root}")
    end
    UI.success("âœ… Found #{framed_shots.count} framed screenshots")

    UI.success("ðŸ–¼  Framed screenshots generated at #{framed_root}")
  end

  desc "Verify framed screenshots exist for all locales"
  lane :verify_framed do
    locales = %w[en-US fi]
    prefixes = %w[01-WelcomeScreen 02-ListsHome 03-ListDetail 04-ItemDetail 05-Settings]
    missing = []
    locales.each do |loc|
      base = File.expand_path(File.join('screenshots','framed', loc), __dir__)
      unless Dir.exist?(base)
        missing << "Directory missing: #{base}"
        next
      end
      prefixes.each do |p|
        # Require framed variant specifically
        glob = Dir.glob(File.join(base, "*-", "#{p}_framed.png")) + Dir.glob(File.join(base, "*#{p}*_framed.png"))
        if glob.empty?
          missing << "#{loc}: #{p}*_framed.png"
        end
      end
    end
    if missing.any?
      UI.user_error!("Framed screenshot verification failed. Missing: \n- #{missing.join("\n- ")}")
    else
      UI.success("âœ… All framed screenshots present for #{locales.join(', ')}")
    end
  end

  desc "Generate watchOS screenshots (fully automated via UITests + simctl)"
  desc "Captures screenshots from Apple Watch Series 10 (46mm) for EN and FI locales"
  lane :watch_screenshots do
    UI.header("ðŸŽâŒšï¸ Generating watchOS Screenshots")
    
    # Setup CI keychain if running in CI (prevents signing hangs)
    setup_ci if ENV['CI']
    
    # Shared derived data path for prebuild and snapshot
    derived = "./fastlane/derivedDataWatch"
    
    # CRITICAL: Pair Watch simulator with iPhone simulator
    # Without pairing, Watch tests may run on iPhone instead of Watch,
    # and screenshots will show "iPhone Disconnected" icon (violates App Store guidelines)
    # Fastlane snapshot will handle pairing automatically if devices are available,
    # but we ensure they exist and are ready
    UI.header("Preparing Watch and iPhone simulators for pairing")
    watch_device = "Apple Watch Series 10 (46mm)"
    iphone_device = "iPhone 15 Pro Max"  # Use same device as iOS screenshots for consistency
    
    # Ensure simulators exist and are available
    # Fastlane snapshot will automatically pair them when running Watch tests
    # The key is ensuring both devices are available in the simulator list
    UI.message("Verifying simulators are available: #{iphone_device} and #{watch_device}")
    
    # Check if simulators exist
    iphone_exists = sh("xcrun simctl list devices available | grep -c '#{iphone_device}' | grep -v 'unavailable'", log: false).strip.to_i > 0 rescue false
    watch_exists = sh("xcrun simctl list devices available | grep -c '#{watch_device}' | grep -v 'unavailable'", log: false).strip.to_i > 0 rescue false
    
    if iphone_exists && watch_exists
      UI.success("âœ… Required simulators are available")
      UI.message("ðŸ’¡ Fastlane snapshot will automatically pair Watch with iPhone when running tests")
    else
      UI.important("âš ï¸  Some simulators may not be available. Snapshot will attempt to create/pair automatically.")
    end
    
    # 0. ONE-TIME BUILD-FOR-TESTING
    # Build once, then snapshot reuses these compiled products for all languages
    # This prevents rebuilding 2x (2 languages), saving 5-8 minutes
    UI.header("Building Watch app and UI tests once for all snapshot runs")
    scan(
      scheme: "ListAllWatch Watch App",
      project: "./ListAll/ListAll.xcodeproj",
      testplan: "ListAllWatch Watch App",
      devices: [watch_device],  # Any device; we only need to populate DerivedData
      clean: true,
      build_for_testing: true,
      # Note: build_for_testing and test_without_building are mutually exclusive
      # build_for_testing means: build only, don't run tests
      # We need to build UI tests for snapshot, so don't use skip_testing here
      derived_data_path: derived,
      xcargs: "ONLY_ACTIVE_ARCH=YES CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO"
    )
    
    # 1. Raw screenshots using pre-built products
    # Note: test_without_building reuses the build from scan above
    # CRITICAL: Disable xcodebuild_formatter so Fastlane can parse NSLog("snapshot: ...") entries
    # CRITICAL: Ensure iPhone simulator stays running for Watch pairing
    UI.header("Running watch snapshot using pre-built tests")
    snapshot(
      project: "./ListAll/ListAll.xcodeproj",
      scheme: "ListAllWatch Watch App",
      testplan: "ListAllWatch Watch App",
      devices: [watch_device],
      languages: ["en-US", "fi"],
      output_directory: "./fastlane/screenshots/watch",
      clear_previous_screenshots: true,
      override_status_bar: true,
      reinstall_app: true,
      test_without_building: true,  # Reuse pre-built products
      derived_data_path: derived,
      concurrent_simulators: false,
      skip_helper_version_check: true,
      result_bundle: false,  # Disable to allow Fastlane auto-extraction
      xcodebuild_formatter: "",  # Empty string disables formatter, allowing Fastlane to parse logs
      stop_after_first_error: false  # Don't stop on first error to allow all languages to run
    )
    
    # 2. Fail-fast check: ensure raw screenshots exist before processing
    watch_raw_dir = File.expand_path("screenshots/watch", __dir__)
    raw_shots = Dir.glob(File.join(watch_raw_dir, "**/*.png"))
    if raw_shots.empty?
      UI.user_error!("ðŸš¨ Watch screenshot generation failed: No screenshots found in #{watch_raw_dir}")
    end
    UI.success("âœ… Found #{raw_shots.count} raw watch screenshots")
    
    UI.success("ðŸŽâŒšï¸ Watch screenshots generation complete!")
    UI.message("ðŸ“ Raw screenshots saved to: fastlane/screenshots/watch")
    
    # Normalize watch screenshots to App Store Connect required dimensions
    UI.header("ðŸ“ Normalizing watchOS screenshots to App Store Connect dimensions")
    watch_normalized_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    
    begin
      WatchScreenshotHelper.normalize_screenshots(
        watch_raw_dir,
        watch_normalized_dir,
        target_size: :series7plus  # 396x484 - Apple Watch Series 7+ (45mm)
      )
    rescue => e
      UI.user_error!("Failed to normalize watch screenshots: #{e.message}")
    end
    
    # 3. Fail-fast check: ensure normalized screenshots exist
    normalized_shots = Dir.glob(File.join(watch_normalized_dir, "**/*.png"))
    if normalized_shots.empty?
      UI.user_error!("ðŸš¨ Watch screenshot normalization failed: No normalized screenshots found in #{watch_normalized_dir}")
    end
    UI.success("âœ… Found #{normalized_shots.count} normalized watch screenshots")
    
    # Copy normalized watch screenshots to framed directory (no framing for watchOS - standard practice)
    UI.header("ðŸ“‚ Copying normalized watchOS screenshots to unified directory")
    unified_framed_root = File.expand_path("screenshots/framed", __dir__)
    locales = %w[en-US fi]

    locales.each do |loc|
      normalized_dir = File.join(watch_normalized_dir, loc)
      next unless Dir.exist?(normalized_dir)
      framed_locale_dir = File.join(unified_framed_root, loc)
      FileUtils.mkdir_p(framed_locale_dir)

      # Copy normalized watch screenshots as-is (naked, no frame) - this is standard for watchOS
      Dir.glob(File.join(normalized_dir, "*.png")).each do |normalized|
        base = File.basename(normalized)
        target = File.join(framed_locale_dir, base)
        FileUtils.cp(normalized, target)
      end
    end

    UI.success("âœ… Normalized watch screenshots copied to #{unified_framed_root} (396x484, unframed)")
  end

  desc "Validate watch screenshot sizes and naming (uses App Store Connect requirements)"
  lane :verify_watch_screenshots do
    UI.header("ðŸ” Validating watchOS Screenshots")
    watch_normalized_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    
    begin
      WatchScreenshotHelper.validate_screenshots(
        watch_normalized_dir,
        expected_count: 5,
        allowed_sizes: [:series7plus]  # Only accept 396x484 (45mm)
      )
      UI.success("âœ… All watch screenshots validated successfully!")
    rescue WatchScreenshotHelper::ValidationError => e
      UI.user_error!("Watch screenshot validation failed: #{e.message}")
    end
  end

  desc "Validate all delivery-ready screenshots (framed iPhone/iPad + naked Watch)"
  lane :validate_delivery_screenshots do
    UI.header("ï¿½ Validating delivery-ready screenshots for App Store submission")
    
    locales = %w[en-US fi]
    errors = []
    warnings = []
    
    # Expected framed dimensions (Frameit output with device frames)
    iphone_framed_size = { width: 1421, height: 2909, tolerance: 50 }
    ipad_framed_size = { width: 2286, height: 3168, tolerance: 50 }
    watch_size = { width: 396, height: 484, tolerance: 0 }  # Exact match required
    
    # Check framed iPhone/iPad screenshots
    framed_dir = File.expand_path("screenshots/framed", __dir__)
    locales.each do |locale|
      locale_dir = File.join(framed_dir, locale)
      unless Dir.exist?(locale_dir)
        errors << "âŒ Missing framed screenshots directory: #{locale_dir}"
        next
      end
      
      # Check iPhone framed screenshots
      iphone_framed = Dir.glob(File.join(locale_dir, "iPhone*_framed.png"))
      if iphone_framed.count != 5
        warnings << "âš ï¸  #{locale}: Expected 5 iPhone framed screenshots, found #{iphone_framed.count}"
      end
      
      iphone_framed.each do |shot|
        dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
        w, h = dims.split('x').map(&:to_i)
        if (w - iphone_framed_size[:width]).abs > iphone_framed_size[:tolerance] ||
           (h - iphone_framed_size[:height]).abs > iphone_framed_size[:tolerance]
          errors << "âŒ #{locale}/#{File.basename(shot)}: #{dims} (expected ~#{iphone_framed_size[:width]}x#{iphone_framed_size[:height]})"
        else
          puts "âœ… #{locale}/#{File.basename(shot)}: #{dims}"
        end
      end
      
      # Check iPad framed screenshots
      ipad_framed = Dir.glob(File.join(locale_dir, "iPad*_framed.png"))
      if ipad_framed.count != 5
        warnings << "âš ï¸  #{locale}: Expected 5 iPad framed screenshots, found #{ipad_framed.count}"
      end
      
      ipad_framed.each do |shot|
        dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
        w, h = dims.split('x').map(&:to_i)
        if (w - ipad_framed_size[:width]).abs > ipad_framed_size[:tolerance] ||
           (h - ipad_framed_size[:height]).abs > ipad_framed_size[:tolerance]
          errors << "âŒ #{locale}/#{File.basename(shot)}: #{dims} (expected ~#{ipad_framed_size[:width]}x#{ipad_framed_size[:height]})"
        else
          puts "âœ… #{locale}/#{File.basename(shot)}: #{dims}"
        end
      end
    end
    
    # Check watch naked screenshots
    watch_dir = File.expand_path("screenshots/watch_normalized", __dir__)
    if Dir.exist?(watch_dir)
      locales.each do |locale|
        locale_dir = File.join(watch_dir, locale)
        unless Dir.exist?(locale_dir)
          errors << "âŒ Missing watch screenshots directory: #{locale_dir}"
          next
        end
        
        watch_shots = Dir.glob(File.join(locale_dir, "*.png"))
        if watch_shots.count != 5
          warnings << "âš ï¸  #{locale}: Expected 5 watch screenshots, found #{watch_shots.count}"
        end
        
        watch_shots.each do |shot|
          dims = `identify -format '%wx%h' #{Shellwords.escape(shot)}`.strip
          w, h = dims.split('x').map(&:to_i)
          if w != watch_size[:width] || h != watch_size[:height]
            errors << "âŒ #{locale}/#{File.basename(shot)}: #{dims} (expected exactly #{watch_size[:width]}x#{watch_size[:height]})"
          else
            puts "âœ… #{locale}/#{File.basename(shot)}: #{dims}"
          end
        end
      end
    else
      warnings << "âš ï¸  Watch screenshots directory not found: #{watch_dir}"
    end
    
    # Print summary
    puts "\n" + "=" * 70
    puts "Delivery Screenshot Validation Summary"
    puts "=" * 70
    
    if warnings.any?
      puts "\nWarnings:"
      warnings.each { |w| puts w }
    end
    
    if errors.any?
      puts "\nErrors:"
      errors.each { |e| puts e }
      puts "\nâŒ Validation FAILED: #{errors.count} error(s)"
      UI.user_error!("Delivery screenshots validation failed")
    else
      puts "\nâœ… All delivery screenshots are valid and ready for App Store submission!"
      puts "\nReady for upload:"
      puts "  â€¢ iPhone: 10 framed screenshots (~1421x2909)"
      puts "  â€¢ iPad: 10 framed screenshots (~2286x3168)"
      puts "  â€¢ Watch: 10 naked screenshots (396x484)"
      puts "  â€¢ Total: 30 screenshots across EN + FI locales"
    end
  end
end
