# Fastlane configuration
# Docs: https://docs.fastlane.tools
require 'base64'
require 'fileutils'
require_relative 'lib/version_helper'

default_platform(:ios)

def require_asc_env!
  missing = ["ASC_KEY_ID", "ASC_ISSUER_ID", "ASC_KEY_BASE64"].reject { |k| ENV[k].to_s.strip.size > 0 }
  UI.user_error!("Missing App Store Connect API key env vars: #{missing.join(', ')}") unless missing.empty?
end

# Prepare screenshots for deliver by copying only framed versions to a clean directory
def prepare_screenshots_for_delivery(framed_path)
  delivery_path = File.expand_path("screenshots/delivery", __dir__)
  FileUtils.rm_rf(delivery_path)
  FileUtils.mkdir_p(delivery_path)
  
  locales = %w[en-US fi]
  locales.each do |locale|
    src_dir = File.join(framed_path, locale)
    dst_dir = File.join(delivery_path, locale)
    FileUtils.mkdir_p(dst_dir)
    
    # Copy only framed screenshots (exclude non-framed variants)
    Dir.glob(File.join(src_dir, "*_framed.png")).each do |framed_file|
      FileUtils.cp(framed_file, dst_dir)
    end
  end
  
  delivery_path
end

platform :ios do
  desc "Run unit and UI tests (xcodebuild like CI)"
  lane :test do
    # Mirror CI behavior with xcodebuild and non-failing exit
    sh "cd ../ListAll && xcodebuild clean build -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' -configuration Debug CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
    sh "cd ../ListAll && xcodebuild test -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' -resultBundlePath ../fastlane/test_output/ListAll.xcresult CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
  end

  desc "Run tests via scan (Fastlane)"
  lane :test_scan do
    # Prefer project since workspace is embedded in .xcodeproj
    scan(
      project: "ListAll/ListAll.xcodeproj",
      scheme: "ListAll",
      clean: true,
      result_bundle: true,
      derived_data_path: "./ListAll/build",
      devices: ["iPhone 16 Pro"], # falls back to default if not available
      fail_build: false
    )
  end

  desc "Build and upload to TestFlight"
  desc "Options:"
  desc "  bump_type: 'patch' (default), 'minor', or 'major' - Type of version increment"
  desc "  skip_version_bump: true to skip version increment (use current version)"
  lane :beta do |options|
    # Setup CI environment (creates temporary keychain)
    if ENV['CI']
      setup_ci
      # Set keychain password for Match to use when importing certs
      ENV["KEYCHAIN_PASSWORD"] = ""  # setup_ci creates keychain with empty password
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    # Handle version numbering with semantic versioning
    unless options[:skip_version_bump]
      bump_type = options[:bump_type] || 'patch'
      
      # Read current version from file
      current_version = VersionHelper.read_version
      UI.message("ðŸ“¦ Current version: #{current_version}")
      
      # Increment version
      new_version = VersionHelper.increment_version(current_version, bump_type)
      UI.important("ðŸ“¦ Bumping version (#{bump_type}): #{current_version} â†’ #{new_version}")
      
      # Update version in all targets
      VersionHelper.update_xcodeproj_version(xcodeproj_path, new_version)
      
      # Save new version to file
      VersionHelper.write_version(new_version)
      
      # Validate all targets have the same version
      unless VersionHelper.validate_versions(xcodeproj_path)
        UI.user_error!("Version validation failed. Please check that all targets have matching versions.")
      end
      
      UI.success("âœ… Version updated to #{new_version}")
    else
      current_version = VersionHelper.read_version
      UI.message("â­ï¸  Skipping version bump, using current version: #{current_version}")
    end
    
    # Increment build number automatically
    # In CI: use GitHub Actions run number, otherwise just increment by 1
    if ENV['GITHUB_RUN_NUMBER']
      increment_build_number(
        build_number: ENV['GITHUB_RUN_NUMBER'],
        xcodeproj: xcodeproj_path
      )
    else
      increment_build_number(
        xcodeproj: xcodeproj_path
      )
    end
    
    # Sync code signing with verbose output
    match(
      type: 'appstore',
      verbose: true,
      keychain_password: ENV["KEYCHAIN_PASSWORD"] || "",
      skip_set_partition_list: true  # Skip partition list in CI to avoid SecItemCopyMatching error
    )
    
    # Disable automatic code signing for Release configuration
    disable_automatic_code_signing(
      path: "ListAll/ListAll.xcodeproj",
      targets: ["ListAll", "ListAllWatch Watch App"],
      code_sign_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Update Xcode project to use the provisioning profiles from Match
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll_appstore_profile-path"],
      target_filter: "ListAll",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll.watchkitapp_appstore_profile-path"],
      target_filter: "ListAllWatch Watch App",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Build archive (gym/build_app handles exporting ipa)
    ipa_path = build_app(
      project: xcodeproj_path,
      scheme: "ListAll",
      export_method: "app-store",
      output_directory: "./ListAll/build",
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        provisioningProfiles: {
          "io.github.chmc.ListAll" => "match AppStore io.github.chmc.ListAll",
          "io.github.chmc.ListAll.watchkitapp" => "match AppStore io.github.chmc.ListAll.watchkitapp"
        }
      }
    )

    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_KEY_BASE64"]
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
        is_key_content_base64: false,
        in_house: false
      )
      pilot(
        ipa: ipa_path,
        api_key: api_key,
        distribute_external: false
      )
    else
      UI.important("ASC_* env vars not set. Skipping TestFlight upload. Archive built at: #{ipa_path}")
    end
  end

  desc "Deliver metadata/screenshots to App Store (no auto-submit)"
  lane :release do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist before attempting delivery
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("ðŸ“¸ Using framed screenshots from: #{delivery_path}")

    deliver(
      api_key: api_key,
      screenshots_path: delivery_path,
      skip_screenshots: false,
      overwrite_screenshots: true,
      skip_binary_upload: true,
      submit_for_review: false,
      force: true
    )
  end

  desc "Dry-run: Verify framed screenshots would be detected by deliver (no upload)"
  lane :release_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # Path to framed screenshots
    framed_path = File.expand_path("screenshots/framed", __dir__)
    
    # Verify framed screenshots exist
    verify_framed
    
    # Prepare delivery directory with only framed screenshots
    delivery_path = prepare_screenshots_for_delivery(framed_path)
    
    UI.message("ðŸ“¸ Verifying screenshots prepared for delivery from: #{delivery_path}")
    
    # List what deliver would find
    locales = %w[en-US fi]
    locales.each do |locale|
      locale_path = File.join(delivery_path, locale)
      if Dir.exist?(locale_path)
        screenshots = Dir.glob(File.join(locale_path, "*.png")).sort
        UI.header("#{locale} (#{screenshots.count} screenshots)")
        screenshots.each do |shot|
          basename = File.basename(shot)
          size = `identify -format '%wx%h' "#{shot}"`.strip rescue "unknown"
          UI.message("  #{basename} (#{size})")
        end
      else
        UI.error("Missing locale directory: #{locale_path}")
      end
    end
    
    UI.success("âœ… Framed screenshots are ready for delivery")
    UI.message("ðŸ’¡ Run 'bundle exec fastlane release' to upload to App Store Connect")
  end

  desc "Validate App Store Connect auth via API key (no uploads)"
  lane :asc_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # This will authenticate and fetch app metadata without uploading anything
    deliver(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_binary_upload: true,
      submit_for_review: false,
      run_precheck_before_submit: false,  # Precheck doesn't work with API keys
      force: true
    )
  end

  # Version management lanes
  
  desc "Show current version from all targets"
  lane :show_version do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.header("ðŸ“¦ Version Information")
    
    # Read from version file
    file_version = VersionHelper.read_version
    UI.message("Version file (.version): #{file_version}")
    
    # Read from git tag (if available)
    git_version = VersionHelper.version_from_git_tag
    UI.message("Latest git tag: #{git_version || 'none'}") if git_version
    
    # Read from Xcode project
    UI.message("\nXcode Project Versions:")
    targets = ['ListAll', 'ListAllWatch Watch App']
    targets.each do |target|
      begin
        version = get_version_number(
          xcodeproj: xcodeproj_path,
          target: target
        )
        build = get_build_number(xcodeproj: xcodeproj_path)
        UI.message("  #{target}: #{version} (#{build})")
      rescue => e
        UI.error("  #{target}: Error - #{e.message}")
      end
    end
    
    # Validate consistency
    UI.message("\n")
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("âœ… All versions are consistent")
    else
      UI.error("âŒ Version mismatch detected")
    end
  end
  
  desc "Manually set version number"
  desc "Usage: fastlane set_version version:1.2.0"
  lane :set_version do |options|
    unless options[:version]
      UI.user_error!("Please specify version with version:X.Y.Z")
    end
    
    version = options[:version]
    
    # Validate semantic version format
    unless version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Version must be in format X.Y.Z (e.g., 1.2.0)")
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.important("ðŸ“¦ Setting version to: #{version}")
    
    # Update version in all targets
    VersionHelper.update_xcodeproj_version(xcodeproj_path, version)
    
    # Save to version file
    VersionHelper.write_version(version)
    
    # Validate
    unless VersionHelper.validate_versions(xcodeproj_path)
      UI.user_error!("Version validation failed")
    end
    
    UI.success("âœ… Version set to #{version}")
    UI.message("ðŸ’¡ Don't forget to commit the changes and create a git tag:")
    UI.message("   git add .version ListAll/ListAll.xcodeproj/project.pbxproj")
    UI.message("   git commit -m 'Bump version to #{version}'")
    UI.message("   git tag v#{version}")
    UI.message("   git push origin main --tags")
  end
  
  desc "Validate that all targets have matching versions"
  lane :validate_versions do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("âœ… All versions are valid and consistent")
    else
      UI.user_error!("âŒ Version validation failed")
    end
  end
  
  desc "Generate screenshots for App Store"
  desc "Runs automated UI tests to capture screenshots for all configured devices and locales"
  lane :screenshots do
    # Capture screenshots using the snapshot tool
    snapshot
    
    UI.success("âœ… Screenshots generated successfully")
    UI.message("ðŸ“ Screenshots saved to: fastlane/screenshots")
  end

  desc "Generate and frame screenshots (snapshot + frameit)"
  lane :screenshots_framed do
    # 1. Raw screenshots
    snapshot

    # 2. Normalize new device sizes to Frameit-supported canvases
    UI.header("Normalizing screenshot sizes for Frameit compatibility")
    compat_root = File.expand_path("screenshots_compat", __dir__)
    sh "rm -rf #{compat_root}"
    locales = %w[en-US fi]
    require 'fileutils'
    require 'shellwords'
    FileUtils.mkdir_p(compat_root)
    UI.message("Compat root: #{compat_root}")
    locales.each do |loc|
      src = File.expand_path(File.join("screenshots", loc), __dir__)
      dst = File.join(compat_root, loc)
      FileUtils.mkdir_p(dst)
      Dir.glob(File.join(src, "*.png")).each do |png|
        # Skip obvious non-screenshot assets like icons
        basename = File.basename(png)
        # Only process our 5 numbered screenshots
        next unless basename =~ /-(01|02|03|04|05)-/

        # Detect size
        size = sh("identify -format '%w %h' #{Shellwords.escape(png)}").strip.split.map(&:to_i) rescue []
        target_w = target_h = nil
        if size == [1320, 2868]
          target_w, target_h = [1290, 2796]       # iPhone 6.7" classic
        elsif size == [2064, 2752]
          target_w, target_h = [2048, 2732]       # iPad Pro 12.9"
        else
          # Pass-through if already supported sizes
          target_w, target_h = size
        end

        out = File.join(dst, basename)
        if target_w && target_h && size != [0,0]
          if [target_w, target_h] == size
            FileUtils.cp(png, out)
          else
            UI.message("Resizing #{basename} #{size.inspect} -> [#{target_w}, #{target_h}]")
            sh "magick convert #{Shellwords.escape(png)} -resize #{target_w}x#{target_h}! #{Shellwords.escape(out)}"
          end
        end
      end
    end

    UI.header("Framing screenshots with Frameit")
    # 3. Frame them into a separate 'framed' directory to keep raw images
    # Frameit uses ENV['SNAPSHOT_SCREENSHOTS_PATH'] by default; override by temporarily moving/pointing path
    ENV['SNAPSHOT_SCREENSHOTS_PATH'] = compat_root
    ENV['FRAMEIT_CONFIG_PATH'] = File.expand_path('Framefile.json', __dir__)
    frameit(
      path: compat_root,
      white: true
    )

    # Move framed output to dedicated directory preserving locale structure
    framed_root = File.expand_path(File.join('screenshots','framed'), __dir__)
    FileUtils.rm_rf(framed_root)
    FileUtils.mkdir_p(framed_root)
    Dir.glob(File.join(compat_root,'*.png')) # ignore top-level stray pngs
    Dir.glob(File.join(compat_root,'*')).select { |d| File.directory?(d) }.each do |locdir|
      loc = File.basename(locdir)
      target_loc = File.join(framed_root, loc)
      FileUtils.mkdir_p(target_loc)
      Dir.glob(File.join(locdir,'*.png')).each do |png|
        FileUtils.cp(png, target_loc)
      end
    end

    UI.success("ðŸ–¼  Framed screenshots generated at #{framed_root}")
  end

  desc "Verify framed screenshots exist for all locales"
  lane :verify_framed do
    locales = %w[en-US fi]
    prefixes = %w[01-WelcomeScreen 02-ListsHome 03-ListDetail 04-ItemDetail 05-Settings]
    missing = []
    locales.each do |loc|
      base = File.expand_path(File.join('screenshots','framed', loc), __dir__)
      unless Dir.exist?(base)
        missing << "Directory missing: #{base}"
        next
      end
      prefixes.each do |p|
        # Require framed variant specifically
        glob = Dir.glob(File.join(base, "*-", "#{p}_framed.png")) + Dir.glob(File.join(base, "*#{p}*_framed.png"))
        if glob.empty?
          missing << "#{loc}: #{p}*_framed.png"
        end
      end
    end
    if missing.any?
      UI.user_error!("Framed screenshot verification failed. Missing: \n- #{missing.join("\n- ")}")
    else
      UI.success("âœ… All framed screenshots present for #{locales.join(', ')}")
    end
  end
end
