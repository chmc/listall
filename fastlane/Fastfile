# Fastlane configuration
# Docs: https://docs.fastlane.tools
require 'base64'
require_relative 'lib/version_helper'

default_platform(:ios)

def require_asc_env!
  missing = ["ASC_KEY_ID", "ASC_ISSUER_ID", "ASC_KEY_BASE64"].reject { |k| ENV[k].to_s.strip.size > 0 }
  UI.user_error!("Missing App Store Connect API key env vars: #{missing.join(', ')}") unless missing.empty?
end

platform :ios do
  desc "Run unit and UI tests (xcodebuild like CI)"
  lane :test do
    # Mirror CI behavior with xcodebuild and non-failing exit
    sh "cd ../ListAll && xcodebuild clean build -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' -configuration Debug CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
    sh "cd ../ListAll && xcodebuild test -project ListAll.xcodeproj -scheme ListAll -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' -resultBundlePath ../fastlane/test_output/ListAll.xcresult CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO || true"
  end

  desc "Run tests via scan (Fastlane)"
  lane :test_scan do
    # Prefer project since workspace is embedded in .xcodeproj
    scan(
      project: "ListAll/ListAll.xcodeproj",
      scheme: "ListAll",
      clean: true,
      result_bundle: true,
      derived_data_path: "./ListAll/build",
      devices: ["iPhone 16 Pro"], # falls back to default if not available
      fail_build: false
    )
  end

  desc "Build and upload to TestFlight"
  desc "Options:"
  desc "  bump_type: 'patch' (default), 'minor', or 'major' - Type of version increment"
  desc "  skip_version_bump: true to skip version increment (use current version)"
  lane :beta do |options|
    # Setup CI environment (creates temporary keychain)
    if ENV['CI']
      setup_ci
      # Set keychain password for Match to use when importing certs
      ENV["KEYCHAIN_PASSWORD"] = ""  # setup_ci creates keychain with empty password
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    # Handle version numbering with semantic versioning
    unless options[:skip_version_bump]
      bump_type = options[:bump_type] || 'patch'
      
      # Read current version from file
      current_version = VersionHelper.read_version
      UI.message("üì¶ Current version: #{current_version}")
      
      # Increment version
      new_version = VersionHelper.increment_version(current_version, bump_type)
      UI.important("üì¶ Bumping version (#{bump_type}): #{current_version} ‚Üí #{new_version}")
      
      # Update version in all targets
      VersionHelper.update_xcodeproj_version(xcodeproj_path, new_version)
      
      # Save new version to file
      VersionHelper.write_version(new_version)
      
      # Validate all targets have the same version
      unless VersionHelper.validate_versions(xcodeproj_path)
        UI.user_error!("Version validation failed. Please check that all targets have matching versions.")
      end
      
      UI.success("‚úÖ Version updated to #{new_version}")
    else
      current_version = VersionHelper.read_version
      UI.message("‚è≠Ô∏è  Skipping version bump, using current version: #{current_version}")
    end
    
    # Increment build number automatically
    # In CI: use GitHub Actions run number, otherwise just increment by 1
    if ENV['GITHUB_RUN_NUMBER']
      increment_build_number(
        build_number: ENV['GITHUB_RUN_NUMBER'],
        xcodeproj: xcodeproj_path
      )
    else
      increment_build_number(
        xcodeproj: xcodeproj_path
      )
    end
    
    # Sync code signing with verbose output
    match(
      type: 'appstore',
      verbose: true,
      keychain_password: ENV["KEYCHAIN_PASSWORD"] || "",
      skip_set_partition_list: true  # Skip partition list in CI to avoid SecItemCopyMatching error
    )
    
    # Disable automatic code signing for Release configuration
    disable_automatic_code_signing(
      path: "ListAll/ListAll.xcodeproj",
      targets: ["ListAll", "ListAllWatch Watch App"],
      code_sign_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Update Xcode project to use the provisioning profiles from Match
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll_appstore_profile-path"],
      target_filter: "ListAll",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    update_project_provisioning(
      xcodeproj: "ListAll/ListAll.xcodeproj",
      profile: ENV["sigh_io.github.chmc.ListAll.watchkitapp_appstore_profile-path"],
      target_filter: "ListAllWatch Watch App",
      build_configuration: "Release",
      code_signing_identity: "Apple Distribution: Aleksi Sutela (M9BR5FY93A)"
    )
    
    # Build archive (gym/build_app handles exporting ipa)
    ipa_path = build_app(
      project: xcodeproj_path,
      scheme: "ListAll",
      export_method: "app-store",
      output_directory: "./ListAll/build",
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        provisioningProfiles: {
          "io.github.chmc.ListAll" => "match AppStore io.github.chmc.ListAll",
          "io.github.chmc.ListAll.watchkitapp" => "match AppStore io.github.chmc.ListAll.watchkitapp"
        }
      }
    )

    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_KEY_BASE64"]
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
        is_key_content_base64: false,
        in_house: false
      )
      pilot(
        ipa: ipa_path,
        api_key: api_key,
        distribute_external: false
      )
    else
      UI.important("ASC_* env vars not set. Skipping TestFlight upload. Archive built at: #{ipa_path}")
    end
  end

  desc "Deliver metadata/screenshots to App Store (no auto-submit)"
  lane :release do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    deliver(
      api_key: api_key,
      skip_screenshots: true, # will be set to false in later phases
      skip_binary_upload: true,
      submit_for_review: false,
      force: true
    )
  end

  desc "Validate App Store Connect auth via API key (no uploads)"
  lane :asc_dry_run do
    require_asc_env!
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: Base64.decode64(ENV["ASC_KEY_BASE64"]),
      is_key_content_base64: false,
      in_house: false
    )

    # This will authenticate and fetch app metadata without uploading anything
    deliver(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_binary_upload: true,
      submit_for_review: false,
      run_precheck_before_submit: false,  # Precheck doesn't work with API keys
      force: true
    )
  end

  # Version management lanes
  
  desc "Show current version from all targets"
  lane :show_version do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.header("üì¶ Version Information")
    
    # Read from version file
    file_version = VersionHelper.read_version
    UI.message("Version file (.version): #{file_version}")
    
    # Read from git tag (if available)
    git_version = VersionHelper.version_from_git_tag
    UI.message("Latest git tag: #{git_version || 'none'}") if git_version
    
    # Read from Xcode project
    UI.message("\nXcode Project Versions:")
    targets = ['ListAll', 'ListAllWatch Watch App']
    targets.each do |target|
      begin
        version = get_version_number(
          xcodeproj: xcodeproj_path,
          target: target
        )
        build = get_build_number(xcodeproj: xcodeproj_path)
        UI.message("  #{target}: #{version} (#{build})")
      rescue => e
        UI.error("  #{target}: Error - #{e.message}")
      end
    end
    
    # Validate consistency
    UI.message("\n")
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("‚úÖ All versions are consistent")
    else
      UI.error("‚ùå Version mismatch detected")
    end
  end
  
  desc "Manually set version number"
  desc "Usage: fastlane set_version version:1.2.0"
  lane :set_version do |options|
    unless options[:version]
      UI.user_error!("Please specify version with version:X.Y.Z")
    end
    
    version = options[:version]
    
    # Validate semantic version format
    unless version.match?(/^\d+\.\d+\.\d+$/)
      UI.user_error!("Version must be in format X.Y.Z (e.g., 1.2.0)")
    end
    
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    UI.important("üì¶ Setting version to: #{version}")
    
    # Update version in all targets
    VersionHelper.update_xcodeproj_version(xcodeproj_path, version)
    
    # Save to version file
    VersionHelper.write_version(version)
    
    # Validate
    unless VersionHelper.validate_versions(xcodeproj_path)
      UI.user_error!("Version validation failed")
    end
    
    UI.success("‚úÖ Version set to #{version}")
    UI.message("üí° Don't forget to commit the changes and create a git tag:")
    UI.message("   git add .version ListAll/ListAll.xcodeproj/project.pbxproj")
    UI.message("   git commit -m 'Bump version to #{version}'")
    UI.message("   git tag v#{version}")
    UI.message("   git push origin main --tags")
  end
  
  desc "Validate that all targets have matching versions"
  lane :validate_versions do
    xcodeproj_path = "ListAll/ListAll.xcodeproj"
    
    if VersionHelper.validate_versions(xcodeproj_path)
      UI.success("‚úÖ All versions are valid and consistent")
    else
      UI.user_error!("‚ùå Version validation failed")
    end
  end
end
